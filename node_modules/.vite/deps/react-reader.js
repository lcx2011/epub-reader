import {
  require_debounce,
  require_event_emitter,
  require_jszip,
  require_lib,
  require_localforage,
  require_marks,
  require_path,
  require_throttle
} from "./chunk-GROAYRC2.js";
import {
  require_react
} from "./chunk-NKBGLYTV.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/epubjs/lib/utils/core.js
var require_core = __commonJS({
  "node_modules/epubjs/lib/utils/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RangeObject = void 0;
    exports.blob2base64 = blob2base64;
    exports.borders = borders;
    exports.bounds = bounds;
    exports.createBase64Url = createBase64Url;
    exports.createBlob = createBlob;
    exports.createBlobUrl = createBlobUrl;
    exports.defaults = defaults;
    exports.defer = defer;
    exports.documentHeight = documentHeight;
    exports.extend = extend;
    exports.filterChildren = filterChildren;
    exports.findChildren = findChildren;
    exports.getParentByTagName = getParentByTagName;
    exports.indexOfElementNode = indexOfElementNode;
    exports.indexOfNode = indexOfNode;
    exports.indexOfSorted = indexOfSorted;
    exports.indexOfTextNode = indexOfTextNode;
    exports.insert = insert;
    exports.isElement = isElement;
    exports.isFloat = isFloat;
    exports.isNumber = isNumber;
    exports.isXml = isXml;
    exports.locationOf = locationOf;
    exports.nodeBounds = nodeBounds;
    exports.parents = parents;
    exports.parse = parse;
    exports.prefixed = prefixed;
    exports.qs = qs;
    exports.qsa = qsa;
    exports.qsp = qsp;
    exports.querySelectorByType = querySelectorByType;
    exports.requestAnimationFrame = void 0;
    exports.revokeBlobUrl = revokeBlobUrl;
    exports.sprint = sprint;
    exports.treeWalker = treeWalker;
    exports.type = type;
    exports.uuid = uuid;
    exports.walk = walk;
    exports.windowBounds = windowBounds;
    var _xmldom = require_lib();
    var requestAnimationFrame2 = typeof window != "undefined" ? window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame : false;
    exports.requestAnimationFrame = requestAnimationFrame2;
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var _URL = typeof URL != "undefined" ? URL : typeof window != "undefined" ? window.URL || window.webkitURL || window.mozURL : void 0;
    function uuid() {
      var d = (/* @__PURE__ */ new Date()).getTime();
      var uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == "x" ? r : r & 7 | 8).toString(16);
      });
      return uuid2;
    }
    function documentHeight() {
      return Math.max(document.documentElement.clientHeight, document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight);
    }
    function isElement(obj) {
      return !!(obj && obj.nodeType == 1);
    }
    function isNumber(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function isFloat(n) {
      let f = parseFloat(n);
      if (isNumber(n) === false) {
        return false;
      }
      if (typeof n === "string" && n.indexOf(".") > -1) {
        return true;
      }
      return Math.floor(f) !== f;
    }
    function prefixed(unprefixed) {
      var vendors = ["Webkit", "webkit", "Moz", "O", "ms"];
      var prefixes = ["-webkit-", "-webkit-", "-moz-", "-o-", "-ms-"];
      var lower = unprefixed.toLowerCase();
      var length = vendors.length;
      if (typeof document === "undefined" || typeof document.body.style[lower] != "undefined") {
        return unprefixed;
      }
      for (var i = 0; i < length; i++) {
        if (typeof document.body.style[prefixes[i] + lower] != "undefined") {
          return prefixes[i] + lower;
        }
      }
      return unprefixed;
    }
    function defaults(obj) {
      for (var i = 1, length = arguments.length; i < length; i++) {
        var source = arguments[i];
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
      return obj;
    }
    function extend(target) {
      var sources = [].slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) return;
        Object.getOwnPropertyNames(source).forEach(function(propName) {
          Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
        });
      });
      return target;
    }
    function insert(item, array, compareFunction) {
      var location = locationOf(item, array, compareFunction);
      array.splice(location, 0, item);
      return location;
    }
    function locationOf(item, array, compareFunction, _start, _end) {
      var start = _start || 0;
      var end = _end || array.length;
      var pivot = parseInt(start + (end - start) / 2);
      var compared;
      if (!compareFunction) {
        compareFunction = function(a, b) {
          if (a > b) return 1;
          if (a < b) return -1;
          if (a == b) return 0;
        };
      }
      if (end - start <= 0) {
        return pivot;
      }
      compared = compareFunction(array[pivot], item);
      if (end - start === 1) {
        return compared >= 0 ? pivot : pivot + 1;
      }
      if (compared === 0) {
        return pivot;
      }
      if (compared === -1) {
        return locationOf(item, array, compareFunction, pivot, end);
      } else {
        return locationOf(item, array, compareFunction, start, pivot);
      }
    }
    function indexOfSorted(item, array, compareFunction, _start, _end) {
      var start = _start || 0;
      var end = _end || array.length;
      var pivot = parseInt(start + (end - start) / 2);
      var compared;
      if (!compareFunction) {
        compareFunction = function(a, b) {
          if (a > b) return 1;
          if (a < b) return -1;
          if (a == b) return 0;
        };
      }
      if (end - start <= 0) {
        return -1;
      }
      compared = compareFunction(array[pivot], item);
      if (end - start === 1) {
        return compared === 0 ? pivot : -1;
      }
      if (compared === 0) {
        return pivot;
      }
      if (compared === -1) {
        return indexOfSorted(item, array, compareFunction, pivot, end);
      } else {
        return indexOfSorted(item, array, compareFunction, start, pivot);
      }
    }
    function bounds(el) {
      var style = window.getComputedStyle(el);
      var widthProps = ["width", "paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"];
      var heightProps = ["height", "paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"];
      var width = 0;
      var height = 0;
      widthProps.forEach(function(prop) {
        width += parseFloat(style[prop]) || 0;
      });
      heightProps.forEach(function(prop) {
        height += parseFloat(style[prop]) || 0;
      });
      return {
        height,
        width
      };
    }
    function borders(el) {
      var style = window.getComputedStyle(el);
      var widthProps = ["paddingRight", "paddingLeft", "marginRight", "marginLeft", "borderRightWidth", "borderLeftWidth"];
      var heightProps = ["paddingTop", "paddingBottom", "marginTop", "marginBottom", "borderTopWidth", "borderBottomWidth"];
      var width = 0;
      var height = 0;
      widthProps.forEach(function(prop) {
        width += parseFloat(style[prop]) || 0;
      });
      heightProps.forEach(function(prop) {
        height += parseFloat(style[prop]) || 0;
      });
      return {
        height,
        width
      };
    }
    function nodeBounds(node) {
      let elPos;
      let doc = node.ownerDocument;
      if (node.nodeType == Node.TEXT_NODE) {
        let elRange = doc.createRange();
        elRange.selectNodeContents(node);
        elPos = elRange.getBoundingClientRect();
      } else {
        elPos = node.getBoundingClientRect();
      }
      return elPos;
    }
    function windowBounds() {
      var width = window.innerWidth;
      var height = window.innerHeight;
      return {
        top: 0,
        left: 0,
        right: width,
        bottom: height,
        width,
        height
      };
    }
    function indexOfNode(node, typeId) {
      var parent2 = node.parentNode;
      var children = parent2.childNodes;
      var sib;
      var index = -1;
      for (var i = 0; i < children.length; i++) {
        sib = children[i];
        if (sib.nodeType === typeId) {
          index++;
        }
        if (sib == node) break;
      }
      return index;
    }
    function indexOfTextNode(textNode) {
      return indexOfNode(textNode, TEXT_NODE);
    }
    function indexOfElementNode(elementNode) {
      return indexOfNode(elementNode, ELEMENT_NODE);
    }
    function isXml(ext) {
      return ["xml", "opf", "ncx"].indexOf(ext) > -1;
    }
    function createBlob(content, mime) {
      return new Blob([content], {
        type: mime
      });
    }
    function createBlobUrl(content, mime) {
      var tempUrl;
      var blob = createBlob(content, mime);
      tempUrl = _URL.createObjectURL(blob);
      return tempUrl;
    }
    function revokeBlobUrl(url) {
      return _URL.revokeObjectURL(url);
    }
    function createBase64Url(content, mime) {
      var data;
      var datauri;
      if (typeof content !== "string") {
        return;
      }
      data = btoa(content);
      datauri = "data:" + mime + ";base64," + data;
      return datauri;
    }
    function type(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1);
    }
    function parse(markup, mime, forceXMLDom) {
      var doc;
      var Parser;
      if (typeof DOMParser === "undefined" || forceXMLDom) {
        Parser = _xmldom.DOMParser;
      } else {
        Parser = DOMParser;
      }
      if (markup.charCodeAt(0) === 65279) {
        markup = markup.slice(1);
      }
      doc = new Parser().parseFromString(markup, mime);
      return doc;
    }
    function qs(el, sel) {
      var elements;
      if (!el) {
        throw new Error("No Element Provided");
      }
      if (typeof el.querySelector != "undefined") {
        return el.querySelector(sel);
      } else {
        elements = el.getElementsByTagName(sel);
        if (elements.length) {
          return elements[0];
        }
      }
    }
    function qsa(el, sel) {
      if (typeof el.querySelector != "undefined") {
        return el.querySelectorAll(sel);
      } else {
        return el.getElementsByTagName(sel);
      }
    }
    function qsp(el, sel, props) {
      var q, filtered;
      if (typeof el.querySelector != "undefined") {
        sel += "[";
        for (var prop in props) {
          sel += prop + "~='" + props[prop] + "'";
        }
        sel += "]";
        return el.querySelector(sel);
      } else {
        q = el.getElementsByTagName(sel);
        filtered = Array.prototype.slice.call(q, 0).filter(function(el2) {
          for (var prop2 in props) {
            if (el2.getAttribute(prop2) === props[prop2]) {
              return true;
            }
          }
          return false;
        });
        if (filtered) {
          return filtered[0];
        }
      }
    }
    function sprint(root, func) {
      var doc = root.ownerDocument || root;
      if (typeof doc.createTreeWalker !== "undefined") {
        treeWalker(root, func, NodeFilter.SHOW_TEXT);
      } else {
        walk(root, function(node) {
          if (node && node.nodeType === 3) {
            func(node);
          }
        }, true);
      }
    }
    function treeWalker(root, func, filter) {
      var treeWalker2 = document.createTreeWalker(root, filter, null, false);
      let node;
      while (node = treeWalker2.nextNode()) {
        func(node);
      }
    }
    function walk(node, callback) {
      if (callback(node)) {
        return true;
      }
      node = node.firstChild;
      if (node) {
        do {
          let walked = walk(node, callback);
          if (walked) {
            return true;
          }
          node = node.nextSibling;
        } while (node);
      }
    }
    function blob2base64(blob) {
      return new Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = function() {
          resolve(reader.result);
        };
      });
    }
    function defer() {
      this.resolve = null;
      this.reject = null;
      this.id = uuid();
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      Object.freeze(this);
    }
    function querySelectorByType(html, element, type2) {
      var query;
      if (typeof html.querySelector != "undefined") {
        query = html.querySelector(`${element}[*|type="${type2}"]`);
      }
      if (!query || query.length === 0) {
        query = qsa(html, element);
        for (var i = 0; i < query.length; i++) {
          if (query[i].getAttributeNS("http://www.idpf.org/2007/ops", "type") === type2 || query[i].getAttribute("epub:type") === type2) {
            return query[i];
          }
        }
      } else {
        return query;
      }
    }
    function findChildren(el) {
      var result = [];
      var childNodes = el.childNodes;
      for (var i = 0; i < childNodes.length; i++) {
        let node = childNodes[i];
        if (node.nodeType === 1) {
          result.push(node);
        }
      }
      return result;
    }
    function parents(node) {
      var nodes = [node];
      for (; node; node = node.parentNode) {
        nodes.unshift(node);
      }
      return nodes;
    }
    function filterChildren(el, nodeName, single) {
      var result = [];
      var childNodes = el.childNodes;
      for (var i = 0; i < childNodes.length; i++) {
        let node = childNodes[i];
        if (node.nodeType === 1 && node.nodeName.toLowerCase() === nodeName) {
          if (single) {
            return node;
          } else {
            result.push(node);
          }
        }
      }
      if (!single) {
        return result;
      }
    }
    function getParentByTagName(node, tagname) {
      let parent2;
      if (node === null || tagname === "") return;
      parent2 = node.parentNode;
      while (parent2.nodeType === 1) {
        if (parent2.tagName.toLowerCase() === tagname) {
          return parent2;
        }
        parent2 = parent2.parentNode;
      }
    }
    var RangeObject = class {
      constructor() {
        this.collapsed = false;
        this.commonAncestorContainer = void 0;
        this.endContainer = void 0;
        this.endOffset = void 0;
        this.startContainer = void 0;
        this.startOffset = void 0;
      }
      setStart(startNode, startOffset) {
        this.startContainer = startNode;
        this.startOffset = startOffset;
        if (!this.endContainer) {
          this.collapse(true);
        } else {
          this.commonAncestorContainer = this._commonAncestorContainer();
        }
        this._checkCollapsed();
      }
      setEnd(endNode, endOffset) {
        this.endContainer = endNode;
        this.endOffset = endOffset;
        if (!this.startContainer) {
          this.collapse(false);
        } else {
          this.collapsed = false;
          this.commonAncestorContainer = this._commonAncestorContainer();
        }
        this._checkCollapsed();
      }
      collapse(toStart) {
        this.collapsed = true;
        if (toStart) {
          this.endContainer = this.startContainer;
          this.endOffset = this.startOffset;
          this.commonAncestorContainer = this.startContainer.parentNode;
        } else {
          this.startContainer = this.endContainer;
          this.startOffset = this.endOffset;
          this.commonAncestorContainer = this.endOffset.parentNode;
        }
      }
      selectNode(referenceNode) {
        let parent2 = referenceNode.parentNode;
        let index = Array.prototype.indexOf.call(parent2.childNodes, referenceNode);
        this.setStart(parent2, index);
        this.setEnd(parent2, index + 1);
      }
      selectNodeContents(referenceNode) {
        let end = referenceNode.childNodes[referenceNode.childNodes - 1];
        let endIndex = referenceNode.nodeType === 3 ? referenceNode.textContent.length : parent.childNodes.length;
        this.setStart(referenceNode, 0);
        this.setEnd(referenceNode, endIndex);
      }
      _commonAncestorContainer(startContainer, endContainer) {
        var startParents = parents(startContainer || this.startContainer);
        var endParents = parents(endContainer || this.endContainer);
        if (startParents[0] != endParents[0]) return void 0;
        for (var i = 0; i < startParents.length; i++) {
          if (startParents[i] != endParents[i]) {
            return startParents[i - 1];
          }
        }
      }
      _checkCollapsed() {
        if (this.startContainer === this.endContainer && this.startOffset === this.endOffset) {
          this.collapsed = true;
        } else {
          this.collapsed = false;
        }
      }
      toString() {
      }
    };
    exports.RangeObject = RangeObject;
  }
});

// node_modules/epubjs/lib/utils/path.js
var require_path2 = __commonJS({
  "node_modules/epubjs/lib/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _pathWebpack = _interopRequireDefault(require_path());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Path = class {
      constructor(pathString) {
        var protocol;
        var parsed;
        protocol = pathString.indexOf("://");
        if (protocol > -1) {
          pathString = new URL(pathString).pathname;
        }
        parsed = this.parse(pathString);
        this.path = pathString;
        if (this.isDirectory(pathString)) {
          this.directory = pathString;
        } else {
          this.directory = parsed.dir + "/";
        }
        this.filename = parsed.base;
        this.extension = parsed.ext.slice(1);
      }
      /**
       * Parse the path: https://nodejs.org/api/path.html#path_path_parse_path
       * @param	{string} what
       * @returns {object}
       */
      parse(what) {
        return _pathWebpack.default.parse(what);
      }
      /**
       * @param	{string} what
       * @returns {boolean}
       */
      isAbsolute(what) {
        return _pathWebpack.default.isAbsolute(what || this.path);
      }
      /**
       * Check if path ends with a directory
       * @param	{string} what
       * @returns {boolean}
       */
      isDirectory(what) {
        return what.charAt(what.length - 1) === "/";
      }
      /**
       * Resolve a path against the directory of the Path
       *
       * https://nodejs.org/api/path.html#path_path_resolve_paths
       * @param	{string} what
       * @returns {string} resolved
       */
      resolve(what) {
        return _pathWebpack.default.resolve(this.directory, what);
      }
      /**
       * Resolve a path relative to the directory of the Path
       *
       * https://nodejs.org/api/path.html#path_path_relative_from_to
       * @param	{string} what
       * @returns {string} relative
       */
      relative(what) {
        var isAbsolute = what && what.indexOf("://") > -1;
        if (isAbsolute) {
          return what;
        }
        return _pathWebpack.default.relative(this.directory, what);
      }
      splitPath(filename) {
        return this.splitPathRe.exec(filename).slice(1);
      }
      /**
       * Return the path string
       * @returns {string} path
       */
      toString() {
        return this.path;
      }
    };
    var _default = Path;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/url.js
var require_url = __commonJS({
  "node_modules/epubjs/lib/utils/url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _path = _interopRequireDefault(require_path2());
    var _pathWebpack = _interopRequireDefault(require_path());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Url = class {
      constructor(urlString, baseString) {
        var absolute = urlString.indexOf("://") > -1;
        var pathname = urlString;
        var basePath;
        this.Url = void 0;
        this.href = urlString;
        this.protocol = "";
        this.origin = "";
        this.hash = "";
        this.hash = "";
        this.search = "";
        this.base = baseString;
        if (!absolute && baseString !== false && typeof baseString !== "string" && window && window.location) {
          this.base = window.location.href;
        }
        if (absolute || this.base) {
          try {
            if (this.base) {
              this.Url = new URL(urlString, this.base);
            } else {
              this.Url = new URL(urlString);
            }
            this.href = this.Url.href;
            this.protocol = this.Url.protocol;
            this.origin = this.Url.origin;
            this.hash = this.Url.hash;
            this.search = this.Url.search;
            pathname = this.Url.pathname + (this.Url.search ? this.Url.search : "");
          } catch (e) {
            this.Url = void 0;
            if (this.base) {
              basePath = new _path.default(this.base);
              pathname = basePath.resolve(pathname);
            }
          }
        }
        this.Path = new _path.default(pathname);
        this.directory = this.Path.directory;
        this.filename = this.Path.filename;
        this.extension = this.Path.extension;
      }
      /**
       * @returns {Path}
       */
      path() {
        return this.Path;
      }
      /**
       * Resolves a relative path to a absolute url
       * @param {string} what
       * @returns {string} url
       */
      resolve(what) {
        var isAbsolute = what.indexOf("://") > -1;
        var fullpath;
        if (isAbsolute) {
          return what;
        }
        fullpath = _pathWebpack.default.resolve(this.directory, what);
        return this.origin + fullpath;
      }
      /**
       * Resolve a path relative to the url
       * @param {string} what
       * @returns {string} path
       */
      relative(what) {
        return _pathWebpack.default.relative(what, this.directory);
      }
      /**
       * @returns {string}
       */
      toString() {
        return this.href;
      }
    };
    var _default = Url;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/epubcfi.js
var require_epubcfi = __commonJS({
  "node_modules/epubjs/lib/epubcfi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var DOCUMENT_NODE = 9;
    var EpubCFI = class _EpubCFI {
      constructor(cfiFrom, base, ignoreClass) {
        var type;
        this.str = "";
        this.base = {};
        this.spinePos = 0;
        this.range = false;
        this.path = {};
        this.start = null;
        this.end = null;
        if (!(this instanceof _EpubCFI)) {
          return new _EpubCFI(cfiFrom, base, ignoreClass);
        }
        if (typeof base === "string") {
          this.base = this.parseComponent(base);
        } else if (typeof base === "object" && base.steps) {
          this.base = base;
        }
        type = this.checkType(cfiFrom);
        if (type === "string") {
          this.str = cfiFrom;
          return (0, _core.extend)(this, this.parse(cfiFrom));
        } else if (type === "range") {
          return (0, _core.extend)(this, this.fromRange(cfiFrom, this.base, ignoreClass));
        } else if (type === "node") {
          return (0, _core.extend)(this, this.fromNode(cfiFrom, this.base, ignoreClass));
        } else if (type === "EpubCFI" && cfiFrom.path) {
          return cfiFrom;
        } else if (!cfiFrom) {
          return this;
        } else {
          throw new TypeError("not a valid argument for EpubCFI");
        }
      }
      /**
       * Check the type of constructor input
       * @private
       */
      checkType(cfi) {
        if (this.isCfiString(cfi)) {
          return "string";
        } else if (cfi && typeof cfi === "object" && ((0, _core.type)(cfi) === "Range" || typeof cfi.startContainer != "undefined")) {
          return "range";
        } else if (cfi && typeof cfi === "object" && typeof cfi.nodeType != "undefined") {
          return "node";
        } else if (cfi && typeof cfi === "object" && cfi instanceof _EpubCFI) {
          return "EpubCFI";
        } else {
          return false;
        }
      }
      /**
       * Parse a cfi string to a CFI object representation
       * @param {string} cfiStr
       * @returns {object} cfi
       */
      parse(cfiStr) {
        var cfi = {
          spinePos: -1,
          range: false,
          base: {},
          path: {},
          start: null,
          end: null
        };
        var baseComponent, pathComponent, range;
        if (typeof cfiStr !== "string") {
          return {
            spinePos: -1
          };
        }
        if (cfiStr.indexOf("epubcfi(") === 0 && cfiStr[cfiStr.length - 1] === ")") {
          cfiStr = cfiStr.slice(8, cfiStr.length - 1);
        }
        baseComponent = this.getChapterComponent(cfiStr);
        if (!baseComponent) {
          return {
            spinePos: -1
          };
        }
        cfi.base = this.parseComponent(baseComponent);
        pathComponent = this.getPathComponent(cfiStr);
        cfi.path = this.parseComponent(pathComponent);
        range = this.getRange(cfiStr);
        if (range) {
          cfi.range = true;
          cfi.start = this.parseComponent(range[0]);
          cfi.end = this.parseComponent(range[1]);
        }
        cfi.spinePos = cfi.base.steps[1].index;
        return cfi;
      }
      parseComponent(componentStr) {
        var component = {
          steps: [],
          terminal: {
            offset: null,
            assertion: null
          }
        };
        var parts = componentStr.split(":");
        var steps = parts[0].split("/");
        var terminal;
        if (parts.length > 1) {
          terminal = parts[1];
          component.terminal = this.parseTerminal(terminal);
        }
        if (steps[0] === "") {
          steps.shift();
        }
        component.steps = steps.map((function(step) {
          return this.parseStep(step);
        }).bind(this));
        return component;
      }
      parseStep(stepStr) {
        var type, num, index, has_brackets, id;
        has_brackets = stepStr.match(/\[(.*)\]/);
        if (has_brackets && has_brackets[1]) {
          id = has_brackets[1];
        }
        num = parseInt(stepStr);
        if (isNaN(num)) {
          return;
        }
        if (num % 2 === 0) {
          type = "element";
          index = num / 2 - 1;
        } else {
          type = "text";
          index = (num - 1) / 2;
        }
        return {
          "type": type,
          "index": index,
          "id": id || null
        };
      }
      parseTerminal(termialStr) {
        var characterOffset, textLocationAssertion;
        var assertion = termialStr.match(/\[(.*)\]/);
        if (assertion && assertion[1]) {
          characterOffset = parseInt(termialStr.split("[")[0]);
          textLocationAssertion = assertion[1];
        } else {
          characterOffset = parseInt(termialStr);
        }
        if (!(0, _core.isNumber)(characterOffset)) {
          characterOffset = null;
        }
        return {
          "offset": characterOffset,
          "assertion": textLocationAssertion
        };
      }
      getChapterComponent(cfiStr) {
        var indirection = cfiStr.split("!");
        return indirection[0];
      }
      getPathComponent(cfiStr) {
        var indirection = cfiStr.split("!");
        if (indirection[1]) {
          let ranges = indirection[1].split(",");
          return ranges[0];
        }
      }
      getRange(cfiStr) {
        var ranges = cfiStr.split(",");
        if (ranges.length === 3) {
          return [ranges[1], ranges[2]];
        }
        return false;
      }
      getCharecterOffsetComponent(cfiStr) {
        var splitStr = cfiStr.split(":");
        return splitStr[1] || "";
      }
      joinSteps(steps) {
        if (!steps) {
          return "";
        }
        return steps.map(function(part) {
          var segment = "";
          if (part.type === "element") {
            segment += (part.index + 1) * 2;
          }
          if (part.type === "text") {
            segment += 1 + 2 * part.index;
          }
          if (part.id) {
            segment += "[" + part.id + "]";
          }
          return segment;
        }).join("/");
      }
      segmentString(segment) {
        var segmentString = "/";
        segmentString += this.joinSteps(segment.steps);
        if (segment.terminal && segment.terminal.offset != null) {
          segmentString += ":" + segment.terminal.offset;
        }
        if (segment.terminal && segment.terminal.assertion != null) {
          segmentString += "[" + segment.terminal.assertion + "]";
        }
        return segmentString;
      }
      /**
       * Convert CFI to a epubcfi(...) string
       * @returns {string} epubcfi
       */
      toString() {
        var cfiString = "epubcfi(";
        cfiString += this.segmentString(this.base);
        cfiString += "!";
        cfiString += this.segmentString(this.path);
        if (this.range && this.start) {
          cfiString += ",";
          cfiString += this.segmentString(this.start);
        }
        if (this.range && this.end) {
          cfiString += ",";
          cfiString += this.segmentString(this.end);
        }
        cfiString += ")";
        return cfiString;
      }
      /**
       * Compare which of two CFIs is earlier in the text
       * @returns {number} First is earlier = -1, Second is earlier = 1, They are equal = 0
       */
      compare(cfiOne, cfiTwo) {
        var stepsA, stepsB;
        var terminalA, terminalB;
        var rangeAStartSteps, rangeAEndSteps;
        var rangeBEndSteps, rangeBEndSteps;
        var rangeAStartTerminal, rangeAEndTerminal;
        var rangeBStartTerminal, rangeBEndTerminal;
        if (typeof cfiOne === "string") {
          cfiOne = new _EpubCFI(cfiOne);
        }
        if (typeof cfiTwo === "string") {
          cfiTwo = new _EpubCFI(cfiTwo);
        }
        if (cfiOne.spinePos > cfiTwo.spinePos) {
          return 1;
        }
        if (cfiOne.spinePos < cfiTwo.spinePos) {
          return -1;
        }
        if (cfiOne.range) {
          stepsA = cfiOne.path.steps.concat(cfiOne.start.steps);
          terminalA = cfiOne.start.terminal;
        } else {
          stepsA = cfiOne.path.steps;
          terminalA = cfiOne.path.terminal;
        }
        if (cfiTwo.range) {
          stepsB = cfiTwo.path.steps.concat(cfiTwo.start.steps);
          terminalB = cfiTwo.start.terminal;
        } else {
          stepsB = cfiTwo.path.steps;
          terminalB = cfiTwo.path.terminal;
        }
        for (var i = 0; i < stepsA.length; i++) {
          if (!stepsA[i]) {
            return -1;
          }
          if (!stepsB[i]) {
            return 1;
          }
          if (stepsA[i].index > stepsB[i].index) {
            return 1;
          }
          if (stepsA[i].index < stepsB[i].index) {
            return -1;
          }
        }
        if (stepsA.length < stepsB.length) {
          return -1;
        }
        if (terminalA.offset > terminalB.offset) {
          return 1;
        }
        if (terminalA.offset < terminalB.offset) {
          return -1;
        }
        return 0;
      }
      step(node) {
        var nodeType = node.nodeType === TEXT_NODE ? "text" : "element";
        return {
          "id": node.id,
          "tagName": node.tagName,
          "type": nodeType,
          "index": this.position(node)
        };
      }
      filteredStep(node, ignoreClass) {
        var filteredNode = this.filter(node, ignoreClass);
        var nodeType;
        if (!filteredNode) {
          return;
        }
        nodeType = filteredNode.nodeType === TEXT_NODE ? "text" : "element";
        return {
          "id": filteredNode.id,
          "tagName": filteredNode.tagName,
          "type": nodeType,
          "index": this.filteredPosition(filteredNode, ignoreClass)
        };
      }
      pathTo(node, offset, ignoreClass) {
        var segment = {
          steps: [],
          terminal: {
            offset: null,
            assertion: null
          }
        };
        var currentNode = node;
        var step;
        while (currentNode && currentNode.parentNode && currentNode.parentNode.nodeType != DOCUMENT_NODE) {
          if (ignoreClass) {
            step = this.filteredStep(currentNode, ignoreClass);
          } else {
            step = this.step(currentNode);
          }
          if (step) {
            segment.steps.unshift(step);
          }
          currentNode = currentNode.parentNode;
        }
        if (offset != null && offset >= 0) {
          segment.terminal.offset = offset;
          if (segment.steps[segment.steps.length - 1].type != "text") {
            segment.steps.push({
              "type": "text",
              "index": 0
            });
          }
        }
        return segment;
      }
      equalStep(stepA, stepB) {
        if (!stepA || !stepB) {
          return false;
        }
        if (stepA.index === stepB.index && stepA.id === stepB.id && stepA.type === stepB.type) {
          return true;
        }
        return false;
      }
      /**
       * Create a CFI object from a Range
       * @param {Range} range
       * @param {string | object} base
       * @param {string} [ignoreClass]
       * @returns {object} cfi
       */
      fromRange(range, base, ignoreClass) {
        var cfi = {
          range: false,
          base: {},
          path: {},
          start: null,
          end: null
        };
        var start = range.startContainer;
        var end = range.endContainer;
        var startOffset = range.startOffset;
        var endOffset = range.endOffset;
        var needsIgnoring = false;
        if (ignoreClass) {
          needsIgnoring = start.ownerDocument.querySelector("." + ignoreClass) != null;
        }
        if (typeof base === "string") {
          cfi.base = this.parseComponent(base);
          cfi.spinePos = cfi.base.steps[1].index;
        } else if (typeof base === "object") {
          cfi.base = base;
        }
        if (range.collapsed) {
          if (needsIgnoring) {
            startOffset = this.patchOffset(start, startOffset, ignoreClass);
          }
          cfi.path = this.pathTo(start, startOffset, ignoreClass);
        } else {
          cfi.range = true;
          if (needsIgnoring) {
            startOffset = this.patchOffset(start, startOffset, ignoreClass);
          }
          cfi.start = this.pathTo(start, startOffset, ignoreClass);
          if (needsIgnoring) {
            endOffset = this.patchOffset(end, endOffset, ignoreClass);
          }
          cfi.end = this.pathTo(end, endOffset, ignoreClass);
          cfi.path = {
            steps: [],
            terminal: null
          };
          var len = cfi.start.steps.length;
          var i;
          for (i = 0; i < len; i++) {
            if (this.equalStep(cfi.start.steps[i], cfi.end.steps[i])) {
              if (i === len - 1) {
                if (cfi.start.terminal === cfi.end.terminal) {
                  cfi.path.steps.push(cfi.start.steps[i]);
                  cfi.range = false;
                }
              } else {
                cfi.path.steps.push(cfi.start.steps[i]);
              }
            } else {
              break;
            }
          }
          cfi.start.steps = cfi.start.steps.slice(cfi.path.steps.length);
          cfi.end.steps = cfi.end.steps.slice(cfi.path.steps.length);
        }
        return cfi;
      }
      /**
       * Create a CFI object from a Node
       * @param {Node} anchor
       * @param {string | object} base
       * @param {string} [ignoreClass]
       * @returns {object} cfi
       */
      fromNode(anchor, base, ignoreClass) {
        var cfi = {
          range: false,
          base: {},
          path: {},
          start: null,
          end: null
        };
        if (typeof base === "string") {
          cfi.base = this.parseComponent(base);
          cfi.spinePos = cfi.base.steps[1].index;
        } else if (typeof base === "object") {
          cfi.base = base;
        }
        cfi.path = this.pathTo(anchor, null, ignoreClass);
        return cfi;
      }
      filter(anchor, ignoreClass) {
        var needsIgnoring;
        var sibling;
        var parent2, previousSibling, nextSibling;
        var isText = false;
        if (anchor.nodeType === TEXT_NODE) {
          isText = true;
          parent2 = anchor.parentNode;
          needsIgnoring = anchor.parentNode.classList.contains(ignoreClass);
        } else {
          isText = false;
          needsIgnoring = anchor.classList.contains(ignoreClass);
        }
        if (needsIgnoring && isText) {
          previousSibling = parent2.previousSibling;
          nextSibling = parent2.nextSibling;
          if (previousSibling && previousSibling.nodeType === TEXT_NODE) {
            sibling = previousSibling;
          } else if (nextSibling && nextSibling.nodeType === TEXT_NODE) {
            sibling = nextSibling;
          }
          if (sibling) {
            return sibling;
          } else {
            return anchor;
          }
        } else if (needsIgnoring && !isText) {
          return false;
        } else {
          return anchor;
        }
      }
      patchOffset(anchor, offset, ignoreClass) {
        if (anchor.nodeType != TEXT_NODE) {
          throw new Error("Anchor must be a text node");
        }
        var curr = anchor;
        var totalOffset = offset;
        if (anchor.parentNode.classList.contains(ignoreClass)) {
          curr = anchor.parentNode;
        }
        while (curr.previousSibling) {
          if (curr.previousSibling.nodeType === ELEMENT_NODE) {
            if (curr.previousSibling.classList.contains(ignoreClass)) {
              totalOffset += curr.previousSibling.textContent.length;
            } else {
              break;
            }
          } else {
            totalOffset += curr.previousSibling.textContent.length;
          }
          curr = curr.previousSibling;
        }
        return totalOffset;
      }
      normalizedMap(children, nodeType, ignoreClass) {
        var output = {};
        var prevIndex = -1;
        var i, len = children.length;
        var currNodeType;
        var prevNodeType;
        for (i = 0; i < len; i++) {
          currNodeType = children[i].nodeType;
          if (currNodeType === ELEMENT_NODE && children[i].classList.contains(ignoreClass)) {
            currNodeType = TEXT_NODE;
          }
          if (i > 0 && currNodeType === TEXT_NODE && prevNodeType === TEXT_NODE) {
            output[i] = prevIndex;
          } else if (nodeType === currNodeType) {
            prevIndex = prevIndex + 1;
            output[i] = prevIndex;
          }
          prevNodeType = currNodeType;
        }
        return output;
      }
      position(anchor) {
        var children, index;
        if (anchor.nodeType === ELEMENT_NODE) {
          children = anchor.parentNode.children;
          if (!children) {
            children = (0, _core.findChildren)(anchor.parentNode);
          }
          index = Array.prototype.indexOf.call(children, anchor);
        } else {
          children = this.textNodes(anchor.parentNode);
          index = children.indexOf(anchor);
        }
        return index;
      }
      filteredPosition(anchor, ignoreClass) {
        var children, index, map;
        if (anchor.nodeType === ELEMENT_NODE) {
          children = anchor.parentNode.children;
          map = this.normalizedMap(children, ELEMENT_NODE, ignoreClass);
        } else {
          children = anchor.parentNode.childNodes;
          if (anchor.parentNode.classList.contains(ignoreClass)) {
            anchor = anchor.parentNode;
            children = anchor.parentNode.childNodes;
          }
          map = this.normalizedMap(children, TEXT_NODE, ignoreClass);
        }
        index = Array.prototype.indexOf.call(children, anchor);
        return map[index];
      }
      stepsToXpath(steps) {
        var xpath = [".", "*"];
        steps.forEach(function(step) {
          var position = step.index + 1;
          if (step.id) {
            xpath.push("*[position()=" + position + " and @id='" + step.id + "']");
          } else if (step.type === "text") {
            xpath.push("text()[" + position + "]");
          } else {
            xpath.push("*[" + position + "]");
          }
        });
        return xpath.join("/");
      }
      /*
      	To get the last step if needed:
      	// Get the terminal step
      lastStep = steps[steps.length-1];
      // Get the query string
      query = this.stepsToQuery(steps);
      // Find the containing element
      startContainerParent = doc.querySelector(query);
      // Find the text node within that element
      if(startContainerParent && lastStep.type == "text") {
      	container = startContainerParent.childNodes[lastStep.index];
      }
      */
      stepsToQuerySelector(steps) {
        var query = ["html"];
        steps.forEach(function(step) {
          var position = step.index + 1;
          if (step.id) {
            query.push("#" + step.id);
          } else if (step.type === "text") {
          } else {
            query.push("*:nth-child(" + position + ")");
          }
        });
        return query.join(">");
      }
      textNodes(container, ignoreClass) {
        return Array.prototype.slice.call(container.childNodes).filter(function(node) {
          if (node.nodeType === TEXT_NODE) {
            return true;
          } else if (ignoreClass && node.classList.contains(ignoreClass)) {
            return true;
          }
          return false;
        });
      }
      walkToNode(steps, _doc, ignoreClass) {
        var doc = _doc || document;
        var container = doc.documentElement;
        var children;
        var step;
        var len = steps.length;
        var i;
        for (i = 0; i < len; i++) {
          step = steps[i];
          if (step.type === "element") {
            if (step.id) {
              container = doc.getElementById(step.id);
            } else {
              children = container.children || (0, _core.findChildren)(container);
              container = children[step.index];
            }
          } else if (step.type === "text") {
            container = this.textNodes(container, ignoreClass)[step.index];
          }
          if (!container) {
            break;
          }
        }
        return container;
      }
      findNode(steps, _doc, ignoreClass) {
        var doc = _doc || document;
        var container;
        var xpath;
        if (!ignoreClass && typeof doc.evaluate != "undefined") {
          xpath = this.stepsToXpath(steps);
          container = doc.evaluate(xpath, doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
        } else if (ignoreClass) {
          container = this.walkToNode(steps, doc, ignoreClass);
        } else {
          container = this.walkToNode(steps, doc);
        }
        return container;
      }
      fixMiss(steps, offset, _doc, ignoreClass) {
        var container = this.findNode(steps.slice(0, -1), _doc, ignoreClass);
        var children = container.childNodes;
        var map = this.normalizedMap(children, TEXT_NODE, ignoreClass);
        var child;
        var len;
        var lastStepIndex = steps[steps.length - 1].index;
        for (let childIndex in map) {
          if (!map.hasOwnProperty(childIndex)) return;
          if (map[childIndex] === lastStepIndex) {
            child = children[childIndex];
            len = child.textContent.length;
            if (offset > len) {
              offset = offset - len;
            } else {
              if (child.nodeType === ELEMENT_NODE) {
                container = child.childNodes[0];
              } else {
                container = child;
              }
              break;
            }
          }
        }
        return {
          container,
          offset
        };
      }
      /**
       * Creates a DOM range representing a CFI
       * @param {document} _doc document referenced in the base
       * @param {string} [ignoreClass]
       * @return {Range}
       */
      toRange(_doc, ignoreClass) {
        var doc = _doc || document;
        var range;
        var start, end, startContainer, endContainer;
        var cfi = this;
        var startSteps, endSteps;
        var needsIgnoring = ignoreClass ? doc.querySelector("." + ignoreClass) != null : false;
        var missed;
        if (typeof doc.createRange !== "undefined") {
          range = doc.createRange();
        } else {
          range = new _core.RangeObject();
        }
        if (cfi.range) {
          start = cfi.start;
          startSteps = cfi.path.steps.concat(start.steps);
          startContainer = this.findNode(startSteps, doc, needsIgnoring ? ignoreClass : null);
          end = cfi.end;
          endSteps = cfi.path.steps.concat(end.steps);
          endContainer = this.findNode(endSteps, doc, needsIgnoring ? ignoreClass : null);
        } else {
          start = cfi.path;
          startSteps = cfi.path.steps;
          startContainer = this.findNode(cfi.path.steps, doc, needsIgnoring ? ignoreClass : null);
        }
        if (startContainer) {
          try {
            if (start.terminal.offset != null) {
              range.setStart(startContainer, start.terminal.offset);
            } else {
              range.setStart(startContainer, 0);
            }
          } catch (e) {
            missed = this.fixMiss(startSteps, start.terminal.offset, doc, needsIgnoring ? ignoreClass : null);
            range.setStart(missed.container, missed.offset);
          }
        } else {
          console.log("No startContainer found for", this.toString());
          return null;
        }
        if (endContainer) {
          try {
            if (end.terminal.offset != null) {
              range.setEnd(endContainer, end.terminal.offset);
            } else {
              range.setEnd(endContainer, 0);
            }
          } catch (e) {
            missed = this.fixMiss(endSteps, cfi.end.terminal.offset, doc, needsIgnoring ? ignoreClass : null);
            range.setEnd(missed.container, missed.offset);
          }
        }
        return range;
      }
      /**
       * Check if a string is wrapped with "epubcfi()"
       * @param {string} str
       * @returns {boolean}
       */
      isCfiString(str) {
        if (typeof str === "string" && str.indexOf("epubcfi(") === 0 && str[str.length - 1] === ")") {
          return true;
        }
        return false;
      }
      generateChapterComponent(_spineNodeIndex, _pos, id) {
        var pos = parseInt(_pos), spineNodeIndex = (_spineNodeIndex + 1) * 2, cfi = "/" + spineNodeIndex + "/";
        cfi += (pos + 1) * 2;
        if (id) {
          cfi += "[" + id + "]";
        }
        return cfi;
      }
      /**
       * Collapse a CFI Range to a single CFI Position
       * @param {boolean} [toStart=false]
       */
      collapse(toStart) {
        if (!this.range) {
          return;
        }
        this.range = false;
        if (toStart) {
          this.path.steps = this.path.steps.concat(this.start.steps);
          this.path.terminal = this.start.terminal;
        } else {
          this.path.steps = this.path.steps.concat(this.end.steps);
          this.path.terminal = this.end.terminal;
        }
      }
    };
    var _default = EpubCFI;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/hook.js
var require_hook = __commonJS({
  "node_modules/epubjs/lib/utils/hook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Hook = class {
      constructor(context) {
        this.context = context || this;
        this.hooks = [];
      }
      /**
       * Adds a function to be run before a hook completes
       * @example this.content.register(function(){...});
       */
      register() {
        for (var i = 0; i < arguments.length; ++i) {
          if (typeof arguments[i] === "function") {
            this.hooks.push(arguments[i]);
          } else {
            for (var j = 0; j < arguments[i].length; ++j) {
              this.hooks.push(arguments[i][j]);
            }
          }
        }
      }
      /**
       * Removes a function
       * @example this.content.deregister(function(){...});
       */
      deregister(func) {
        let hook;
        for (let i = 0; i < this.hooks.length; i++) {
          hook = this.hooks[i];
          if (hook === func) {
            this.hooks.splice(i, 1);
            break;
          }
        }
      }
      /**
       * Triggers a hook to run all functions
       * @example this.content.trigger(args).then(function(){...});
       */
      trigger() {
        var args = arguments;
        var context = this.context;
        var promises = [];
        this.hooks.forEach(function(task) {
          try {
            var executing = task.apply(context, args);
          } catch (err) {
            console.log(err);
          }
          if (executing && typeof executing["then"] === "function") {
            promises.push(executing);
          }
        });
        return Promise.all(promises);
      }
      // Adds a function to be run before a hook completes
      list() {
        return this.hooks;
      }
      clear() {
        return this.hooks = [];
      }
    };
    var _default = Hook;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/replacements.js
var require_replacements = __commonJS({
  "node_modules/epubjs/lib/utils/replacements.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.replaceBase = replaceBase;
    exports.replaceCanonical = replaceCanonical;
    exports.replaceLinks = replaceLinks;
    exports.replaceMeta = replaceMeta;
    exports.substitute = substitute;
    var _core = require_core();
    var _url = _interopRequireDefault(require_url());
    var _path = _interopRequireDefault(require_path2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function replaceBase(doc, section) {
      var base;
      var head;
      var url = section.url;
      var absolute = url.indexOf("://") > -1;
      if (!doc) {
        return;
      }
      head = (0, _core.qs)(doc, "head");
      base = (0, _core.qs)(head, "base");
      if (!base) {
        base = doc.createElement("base");
        head.insertBefore(base, head.firstChild);
      }
      if (!absolute && window && window.location) {
        url = window.location.origin + url;
      }
      base.setAttribute("href", url);
    }
    function replaceCanonical(doc, section) {
      var head;
      var link;
      var url = section.canonical;
      if (!doc) {
        return;
      }
      head = (0, _core.qs)(doc, "head");
      link = (0, _core.qs)(head, "link[rel='canonical']");
      if (link) {
        link.setAttribute("href", url);
      } else {
        link = doc.createElement("link");
        link.setAttribute("rel", "canonical");
        link.setAttribute("href", url);
        head.appendChild(link);
      }
    }
    function replaceMeta(doc, section) {
      var head;
      var meta;
      var id = section.idref;
      if (!doc) {
        return;
      }
      head = (0, _core.qs)(doc, "head");
      meta = (0, _core.qs)(head, "link[property='dc.identifier']");
      if (meta) {
        meta.setAttribute("content", id);
      } else {
        meta = doc.createElement("meta");
        meta.setAttribute("name", "dc.identifier");
        meta.setAttribute("content", id);
        head.appendChild(meta);
      }
    }
    function replaceLinks(contents, fn) {
      var links = contents.querySelectorAll("a[href]");
      if (!links.length) {
        return;
      }
      var base = (0, _core.qs)(contents.ownerDocument, "base");
      var location = base ? base.getAttribute("href") : void 0;
      var replaceLink = (function(link) {
        var href = link.getAttribute("href");
        if (href.indexOf("mailto:") === 0) {
          return;
        }
        var absolute = href.indexOf("://") > -1;
        if (absolute) {
          link.setAttribute("target", "_blank");
        } else {
          var linkUrl;
          try {
            linkUrl = new _url.default(href, location);
          } catch (error) {
          }
          link.onclick = function() {
            if (linkUrl && linkUrl.hash) {
              fn(linkUrl.Path.path + linkUrl.hash);
            } else if (linkUrl) {
              fn(linkUrl.Path.path);
            } else {
              fn(href);
            }
            return false;
          };
        }
      }).bind(this);
      for (var i = 0; i < links.length; i++) {
        replaceLink(links[i]);
      }
    }
    function substitute(content, urls, replacements) {
      urls.forEach(function(url, i) {
        if (url && replacements[i]) {
          url = url.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
          content = content.replace(new RegExp(url, "g"), replacements[i]);
        }
      });
      return content;
    }
  }
});

// node_modules/epubjs/lib/utils/request.js
var require_request = __commonJS({
  "node_modules/epubjs/lib/utils/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _path = _interopRequireDefault(require_path2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function request(url, type, withCredentials, headers) {
      var supportsURL = typeof window != "undefined" ? window.URL : false;
      var BLOB_RESPONSE = supportsURL ? "blob" : "arraybuffer";
      var deferred = new _core.defer();
      var xhr = new XMLHttpRequest();
      var xhrPrototype = XMLHttpRequest.prototype;
      var header;
      if (!("overrideMimeType" in xhrPrototype)) {
        Object.defineProperty(xhrPrototype, "overrideMimeType", {
          value: function xmlHttpRequestOverrideMimeType() {
          }
        });
      }
      if (withCredentials) {
        xhr.withCredentials = true;
      }
      xhr.onreadystatechange = handler;
      xhr.onerror = err;
      xhr.open("GET", url, true);
      for (header in headers) {
        xhr.setRequestHeader(header, headers[header]);
      }
      if (type == "json") {
        xhr.setRequestHeader("Accept", "application/json");
      }
      if (!type) {
        type = new _path.default(url).extension;
      }
      if (type == "blob") {
        xhr.responseType = BLOB_RESPONSE;
      }
      if ((0, _core.isXml)(type)) {
        xhr.overrideMimeType("text/xml");
      }
      if (type == "xhtml") {
      }
      if (type == "html" || type == "htm") {
      }
      if (type == "binary") {
        xhr.responseType = "arraybuffer";
      }
      xhr.send();
      function err(e) {
        deferred.reject(e);
      }
      function handler() {
        if (this.readyState === XMLHttpRequest.DONE) {
          var responseXML = false;
          if (this.responseType === "" || this.responseType === "document") {
            responseXML = this.responseXML;
          }
          if (this.status === 200 || this.status === 0 || responseXML) {
            var r;
            if (!this.response && !responseXML) {
              deferred.reject({
                status: this.status,
                message: "Empty Response",
                stack: new Error().stack
              });
              return deferred.promise;
            }
            if (this.status === 403) {
              deferred.reject({
                status: this.status,
                response: this.response,
                message: "Forbidden",
                stack: new Error().stack
              });
              return deferred.promise;
            }
            if (responseXML) {
              r = this.responseXML;
            } else if ((0, _core.isXml)(type)) {
              r = (0, _core.parse)(this.response, "text/xml");
            } else if (type == "xhtml") {
              r = (0, _core.parse)(this.response, "application/xhtml+xml");
            } else if (type == "html" || type == "htm") {
              r = (0, _core.parse)(this.response, "text/html");
            } else if (type == "json") {
              r = JSON.parse(this.response);
            } else if (type == "blob") {
              if (supportsURL) {
                r = this.response;
              } else {
                r = new Blob([this.response]);
              }
            } else {
              r = this.response;
            }
            deferred.resolve(r);
          } else {
            deferred.reject({
              status: this.status,
              message: this.response,
              stack: new Error().stack
            });
          }
        }
      }
      return deferred.promise;
    }
    var _default = request;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/section.js
var require_section = __commonJS({
  "node_modules/epubjs/lib/section.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _hook = _interopRequireDefault(require_hook());
    var _replacements = require_replacements();
    var _request2 = _interopRequireDefault(require_request());
    var _xmldom = require_lib();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Section = class {
      constructor(item, hooks) {
        this.idref = item.idref;
        this.linear = item.linear === "yes";
        this.properties = item.properties;
        this.index = item.index;
        this.href = item.href;
        this.url = item.url;
        this.canonical = item.canonical;
        this.next = item.next;
        this.prev = item.prev;
        this.cfiBase = item.cfiBase;
        if (hooks) {
          this.hooks = hooks;
        } else {
          this.hooks = {};
          this.hooks.serialize = new _hook.default(this);
          this.hooks.content = new _hook.default(this);
        }
        this.document = void 0;
        this.contents = void 0;
        this.output = void 0;
      }
      /**
       * Load the section from its url
       * @param  {method} [_request] a request method to use for loading
       * @return {document} a promise with the xml document
       */
      load(_request) {
        var request = _request || this.request || _request2.default;
        var loading = new _core.defer();
        var loaded = loading.promise;
        if (this.contents) {
          loading.resolve(this.contents);
        } else {
          request(this.url).then((function(xml) {
            this.document = xml;
            this.contents = xml.documentElement;
            return this.hooks.content.trigger(this.document, this);
          }).bind(this)).then((function() {
            loading.resolve(this.contents);
          }).bind(this)).catch(function(error) {
            loading.reject(error);
          });
        }
        return loaded;
      }
      /**
       * Adds a base tag for resolving urls in the section
       * @private
       */
      base() {
        return (0, _replacements.replaceBase)(this.document, this);
      }
      /**
       * Render the contents of a section
       * @param  {method} [_request] a request method to use for loading
       * @return {string} output a serialized XML Document
       */
      render(_request) {
        var rendering = new _core.defer();
        var rendered = rendering.promise;
        this.output;
        this.load(_request).then((function(contents) {
          var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
          var isIE = userAgent.indexOf("Trident") >= 0;
          var Serializer;
          if (typeof XMLSerializer === "undefined" || isIE) {
            Serializer = _xmldom.DOMParser;
          } else {
            Serializer = XMLSerializer;
          }
          var serializer = new Serializer();
          this.output = serializer.serializeToString(contents);
          return this.output;
        }).bind(this)).then((function() {
          return this.hooks.serialize.trigger(this.output, this);
        }).bind(this)).then((function() {
          rendering.resolve(this.output);
        }).bind(this)).catch(function(error) {
          rendering.reject(error);
        });
        return rendered;
      }
      /**
       * Find a string in a section
       * @param  {string} _query The query string to find
       * @return {object[]} A list of matches, with form {cfi, excerpt}
       */
      find(_query) {
        var section = this;
        var matches = [];
        var query = _query.toLowerCase();
        var find = function(node) {
          var text = node.textContent.toLowerCase();
          var range = section.document.createRange();
          var cfi;
          var pos;
          var last = -1;
          var excerpt;
          var limit = 150;
          while (pos != -1) {
            pos = text.indexOf(query, last + 1);
            if (pos != -1) {
              range = section.document.createRange();
              range.setStart(node, pos);
              range.setEnd(node, pos + query.length);
              cfi = section.cfiFromRange(range);
              if (node.textContent.length < limit) {
                excerpt = node.textContent;
              } else {
                excerpt = node.textContent.substring(pos - limit / 2, pos + limit / 2);
                excerpt = "..." + excerpt + "...";
              }
              matches.push({
                cfi,
                excerpt
              });
            }
            last = pos;
          }
        };
        (0, _core.sprint)(section.document, function(node) {
          find(node);
        });
        return matches;
      }
      /**
       * Search a string in multiple sequential Element of the section. If the document.createTreeWalker api is missed(eg: IE8), use `find` as a fallback.
       * @param  {string} _query The query string to search
       * @param  {int} maxSeqEle The maximum number of Element that are combined for search, default value is 5.
       * @return {object[]} A list of matches, with form {cfi, excerpt}
       */
      search(_query, maxSeqEle = 5) {
        if (typeof document.createTreeWalker == "undefined") {
          return this.find(_query);
        }
        let matches = [];
        const excerptLimit = 150;
        const section = this;
        const query = _query.toLowerCase();
        const search = function(nodeList2) {
          const textWithCase = nodeList2.reduce((acc, current) => {
            return acc + current.textContent;
          }, "");
          const text = textWithCase.toLowerCase();
          const pos = text.indexOf(query);
          if (pos != -1) {
            const startNodeIndex = 0, endPos = pos + query.length;
            let endNodeIndex = 0, l = 0;
            if (pos < nodeList2[startNodeIndex].length) {
              let cfi;
              while (endNodeIndex < nodeList2.length - 1) {
                l += nodeList2[endNodeIndex].length;
                if (endPos <= l) {
                  break;
                }
                endNodeIndex += 1;
              }
              let startNode = nodeList2[startNodeIndex], endNode = nodeList2[endNodeIndex];
              let range = section.document.createRange();
              range.setStart(startNode, pos);
              let beforeEndLengthCount = nodeList2.slice(0, endNodeIndex).reduce((acc, current) => {
                return acc + current.textContent.length;
              }, 0);
              range.setEnd(endNode, beforeEndLengthCount > endPos ? endPos : endPos - beforeEndLengthCount);
              cfi = section.cfiFromRange(range);
              let excerpt = nodeList2.slice(0, endNodeIndex + 1).reduce((acc, current) => {
                return acc + current.textContent;
              }, "");
              if (excerpt.length > excerptLimit) {
                excerpt = excerpt.substring(pos - excerptLimit / 2, pos + excerptLimit / 2);
                excerpt = "..." + excerpt + "...";
              }
              matches.push({
                cfi,
                excerpt
              });
            }
          }
        };
        const treeWalker = document.createTreeWalker(section.document, NodeFilter.SHOW_TEXT, null, false);
        let node, nodeList = [];
        while (node = treeWalker.nextNode()) {
          nodeList.push(node);
          if (nodeList.length == maxSeqEle) {
            search(nodeList.slice(0, maxSeqEle));
            nodeList = nodeList.slice(1, maxSeqEle);
          }
        }
        if (nodeList.length > 0) {
          search(nodeList);
        }
        return matches;
      }
      /**
      * Reconciles the current chapters layout properties with
      * the global layout properties.
      * @param {object} globalLayout  The global layout settings object, chapter properties string
      * @return {object} layoutProperties Object with layout properties
      */
      reconcileLayoutSettings(globalLayout) {
        var settings = {
          layout: globalLayout.layout,
          spread: globalLayout.spread,
          orientation: globalLayout.orientation
        };
        this.properties.forEach(function(prop) {
          var rendition = prop.replace("rendition:", "");
          var split = rendition.indexOf("-");
          var property, value;
          if (split != -1) {
            property = rendition.slice(0, split);
            value = rendition.slice(split + 1);
            settings[property] = value;
          }
        });
        return settings;
      }
      /**
       * Get a CFI from a Range in the Section
       * @param  {range} _range
       * @return {string} cfi an EpubCFI string
       */
      cfiFromRange(_range) {
        return new _epubcfi.default(_range, this.cfiBase).toString();
      }
      /**
       * Get a CFI from an Element in the Section
       * @param  {element} el
       * @return {string} cfi an EpubCFI string
       */
      cfiFromElement(el) {
        return new _epubcfi.default(el, this.cfiBase).toString();
      }
      /**
       * Unload the section document
       */
      unload() {
        this.document = void 0;
        this.contents = void 0;
        this.output = void 0;
      }
      destroy() {
        this.unload();
        this.hooks.serialize.clear();
        this.hooks.content.clear();
        this.hooks = void 0;
        this.idref = void 0;
        this.linear = void 0;
        this.properties = void 0;
        this.index = void 0;
        this.href = void 0;
        this.url = void 0;
        this.next = void 0;
        this.prev = void 0;
        this.cfiBase = void 0;
      }
    };
    var _default = Section;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/spine.js
var require_spine = __commonJS({
  "node_modules/epubjs/lib/spine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _hook = _interopRequireDefault(require_hook());
    var _section = _interopRequireDefault(require_section());
    var _replacements = require_replacements();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Spine = class {
      constructor() {
        this.spineItems = [];
        this.spineByHref = {};
        this.spineById = {};
        this.hooks = {};
        this.hooks.serialize = new _hook.default();
        this.hooks.content = new _hook.default();
        this.hooks.content.register(_replacements.replaceBase);
        this.hooks.content.register(_replacements.replaceCanonical);
        this.hooks.content.register(_replacements.replaceMeta);
        this.epubcfi = new _epubcfi.default();
        this.loaded = false;
        this.items = void 0;
        this.manifest = void 0;
        this.spineNodeIndex = void 0;
        this.baseUrl = void 0;
        this.length = void 0;
      }
      /**
       * Unpack items from a opf into spine items
       * @param  {Packaging} _package
       * @param  {method} resolver URL resolver
       * @param  {method} canonical Resolve canonical url
       */
      unpack(_package, resolver, canonical) {
        this.items = _package.spine;
        this.manifest = _package.manifest;
        this.spineNodeIndex = _package.spineNodeIndex;
        this.baseUrl = _package.baseUrl || _package.basePath || "";
        this.length = this.items.length;
        this.items.forEach((item, index) => {
          var manifestItem = this.manifest[item.idref];
          var spineItem;
          item.index = index;
          item.cfiBase = this.epubcfi.generateChapterComponent(this.spineNodeIndex, item.index, item.id);
          if (item.href) {
            item.url = resolver(item.href, true);
            item.canonical = canonical(item.href);
          }
          if (manifestItem) {
            item.href = manifestItem.href;
            item.url = resolver(item.href, true);
            item.canonical = canonical(item.href);
            if (manifestItem.properties.length) {
              item.properties.push.apply(item.properties, manifestItem.properties);
            }
          }
          if (item.linear === "yes") {
            item.prev = (function() {
              let prevIndex = item.index;
              while (prevIndex > 0) {
                let prev = this.get(prevIndex - 1);
                if (prev && prev.linear) {
                  return prev;
                }
                prevIndex -= 1;
              }
              return;
            }).bind(this);
            item.next = (function() {
              let nextIndex = item.index;
              while (nextIndex < this.spineItems.length - 1) {
                let next = this.get(nextIndex + 1);
                if (next && next.linear) {
                  return next;
                }
                nextIndex += 1;
              }
              return;
            }).bind(this);
          } else {
            item.prev = function() {
              return;
            };
            item.next = function() {
              return;
            };
          }
          spineItem = new _section.default(item, this.hooks);
          this.append(spineItem);
        });
        this.loaded = true;
      }
      /**
       * Get an item from the spine
       * @param  {string|number} [target]
       * @return {Section} section
       * @example spine.get();
       * @example spine.get(1);
       * @example spine.get("chap1.html");
       * @example spine.get("#id1234");
       */
      get(target) {
        var index = 0;
        if (typeof target === "undefined") {
          while (index < this.spineItems.length) {
            let next = this.spineItems[index];
            if (next && next.linear) {
              break;
            }
            index += 1;
          }
        } else if (this.epubcfi.isCfiString(target)) {
          let cfi = new _epubcfi.default(target);
          index = cfi.spinePos;
        } else if (typeof target === "number" || isNaN(target) === false) {
          index = target;
        } else if (typeof target === "string" && target.indexOf("#") === 0) {
          index = this.spineById[target.substring(1)];
        } else if (typeof target === "string") {
          target = target.split("#")[0];
          index = this.spineByHref[target] || this.spineByHref[encodeURI(target)];
        }
        return this.spineItems[index] || null;
      }
      /**
       * Append a Section to the Spine
       * @private
       * @param  {Section} section
       */
      append(section) {
        var index = this.spineItems.length;
        section.index = index;
        this.spineItems.push(section);
        this.spineByHref[decodeURI(section.href)] = index;
        this.spineByHref[encodeURI(section.href)] = index;
        this.spineByHref[section.href] = index;
        this.spineById[section.idref] = index;
        return index;
      }
      /**
       * Prepend a Section to the Spine
       * @private
       * @param  {Section} section
       */
      prepend(section) {
        this.spineByHref[section.href] = 0;
        this.spineById[section.idref] = 0;
        this.spineItems.forEach(function(item, index) {
          item.index = index;
        });
        return 0;
      }
      // insert(section, index) {
      //
      // };
      /**
       * Remove a Section from the Spine
       * @private
       * @param  {Section} section
       */
      remove(section) {
        var index = this.spineItems.indexOf(section);
        if (index > -1) {
          delete this.spineByHref[section.href];
          delete this.spineById[section.idref];
          return this.spineItems.splice(index, 1);
        }
      }
      /**
       * Loop over the Sections in the Spine
       * @return {method} forEach
       */
      each() {
        return this.spineItems.forEach.apply(this.spineItems, arguments);
      }
      /**
       * Find the first Section in the Spine
       * @return {Section} first section
       */
      first() {
        let index = 0;
        do {
          let next = this.get(index);
          if (next && next.linear) {
            return next;
          }
          index += 1;
        } while (index < this.spineItems.length);
      }
      /**
       * Find the last Section in the Spine
       * @return {Section} last section
       */
      last() {
        let index = this.spineItems.length - 1;
        do {
          let prev = this.get(index);
          if (prev && prev.linear) {
            return prev;
          }
          index -= 1;
        } while (index >= 0);
      }
      destroy() {
        this.each((section) => section.destroy());
        this.spineItems = void 0;
        this.spineByHref = void 0;
        this.spineById = void 0;
        this.hooks.serialize.clear();
        this.hooks.content.clear();
        this.hooks = void 0;
        this.epubcfi = void 0;
        this.loaded = false;
        this.items = void 0;
        this.manifest = void 0;
        this.spineNodeIndex = void 0;
        this.baseUrl = void 0;
        this.length = void 0;
      }
    };
    var _default = Spine;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/queue.js
var require_queue = __commonJS({
  "node_modules/epubjs/lib/utils/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.Task = void 0;
    var _core = require_core();
    var Queue = class {
      constructor(context) {
        this._q = [];
        this.context = context;
        this.tick = _core.requestAnimationFrame;
        this.running = false;
        this.paused = false;
      }
      /**
       * Add an item to the queue
       * @return {Promise}
       */
      enqueue() {
        var deferred, promise;
        var queued;
        var task = [].shift.call(arguments);
        var args = arguments;
        if (!task) {
          throw new Error("No Task Provided");
        }
        if (typeof task === "function") {
          deferred = new _core.defer();
          promise = deferred.promise;
          queued = {
            "task": task,
            "args": args,
            //"context"  : context,
            "deferred": deferred,
            "promise": promise
          };
        } else {
          queued = {
            "promise": task
          };
        }
        this._q.push(queued);
        if (this.paused == false && !this.running) {
          this.run();
        }
        return queued.promise;
      }
      /**
       * Run one item
       * @return {Promise}
       */
      dequeue() {
        var inwait, task, result;
        if (this._q.length && !this.paused) {
          inwait = this._q.shift();
          task = inwait.task;
          if (task) {
            result = task.apply(this.context, inwait.args);
            if (result && typeof result["then"] === "function") {
              return result.then((function() {
                inwait.deferred.resolve.apply(this.context, arguments);
              }).bind(this), (function() {
                inwait.deferred.reject.apply(this.context, arguments);
              }).bind(this));
            } else {
              inwait.deferred.resolve.apply(this.context, result);
              return inwait.promise;
            }
          } else if (inwait.promise) {
            return inwait.promise;
          }
        } else {
          inwait = new _core.defer();
          inwait.deferred.resolve();
          return inwait.promise;
        }
      }
      // Run All Immediately
      dump() {
        while (this._q.length) {
          this.dequeue();
        }
      }
      /**
       * Run all tasks sequentially, at convince
       * @return {Promise}
       */
      run() {
        if (!this.running) {
          this.running = true;
          this.defered = new _core.defer();
        }
        this.tick.call(window, () => {
          if (this._q.length) {
            this.dequeue().then((function() {
              this.run();
            }).bind(this));
          } else {
            this.defered.resolve();
            this.running = void 0;
          }
        });
        if (this.paused == true) {
          this.paused = false;
        }
        return this.defered.promise;
      }
      /**
       * Flush all, as quickly as possible
       * @return {Promise}
       */
      flush() {
        if (this.running) {
          return this.running;
        }
        if (this._q.length) {
          this.running = this.dequeue().then((function() {
            this.running = void 0;
            return this.flush();
          }).bind(this));
          return this.running;
        }
      }
      /**
       * Clear all items in wait
       */
      clear() {
        this._q = [];
      }
      /**
       * Get the number of tasks in the queue
       * @return {number} tasks
       */
      length() {
        return this._q.length;
      }
      /**
       * Pause a running queue
       */
      pause() {
        this.paused = true;
      }
      /**
       * End the queue
       */
      stop() {
        this._q = [];
        this.running = false;
        this.paused = true;
      }
    };
    var Task = class {
      constructor(task, args, context) {
        return function() {
          var toApply = arguments || [];
          return new Promise((resolve, reject) => {
            var callback = function(value, err) {
              if (!value && err) {
                reject(err);
              } else {
                resolve(value);
              }
            };
            toApply.push(callback);
            task.apply(context || this, toApply);
          });
        };
      }
    };
    exports.Task = Task;
    var _default = Queue;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/constants.js
var require_constants = __commonJS({
  "node_modules/epubjs/lib/utils/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EVENTS = exports.EPUBJS_VERSION = exports.DOM_EVENTS = void 0;
    var EPUBJS_VERSION = "0.3";
    exports.EPUBJS_VERSION = EPUBJS_VERSION;
    var DOM_EVENTS = ["keydown", "keyup", "keypressed", "mouseup", "mousedown", "mousemove", "click", "touchend", "touchstart", "touchmove"];
    exports.DOM_EVENTS = DOM_EVENTS;
    var EVENTS = {
      BOOK: {
        OPEN_FAILED: "openFailed"
      },
      CONTENTS: {
        EXPAND: "expand",
        RESIZE: "resize",
        SELECTED: "selected",
        SELECTED_RANGE: "selectedRange",
        LINK_CLICKED: "linkClicked"
      },
      LOCATIONS: {
        CHANGED: "changed"
      },
      MANAGERS: {
        RESIZE: "resize",
        RESIZED: "resized",
        ORIENTATION_CHANGE: "orientationchange",
        ADDED: "added",
        SCROLL: "scroll",
        SCROLLED: "scrolled",
        REMOVED: "removed"
      },
      VIEWS: {
        AXIS: "axis",
        WRITING_MODE: "writingMode",
        LOAD_ERROR: "loaderror",
        RENDERED: "rendered",
        RESIZED: "resized",
        DISPLAYED: "displayed",
        SHOWN: "shown",
        HIDDEN: "hidden",
        MARK_CLICKED: "markClicked"
      },
      RENDITION: {
        STARTED: "started",
        ATTACHED: "attached",
        DISPLAYED: "displayed",
        DISPLAY_ERROR: "displayerror",
        RENDERED: "rendered",
        REMOVED: "removed",
        RESIZED: "resized",
        ORIENTATION_CHANGE: "orientationchange",
        LOCATION_CHANGED: "locationChanged",
        RELOCATED: "relocated",
        MARK_CLICKED: "markClicked",
        SELECTED: "selected",
        LAYOUT: "layout"
      },
      LAYOUT: {
        UPDATED: "updated"
      },
      ANNOTATION: {
        ATTACH: "attach",
        DETACH: "detach"
      }
    };
    exports.EVENTS = EVENTS;
  }
});

// node_modules/epubjs/lib/locations.js
var require_locations = __commonJS({
  "node_modules/epubjs/lib/locations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _queue = _interopRequireDefault(require_queue());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _constants = require_constants();
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Locations = class {
      constructor(spine, request, pause) {
        this.spine = spine;
        this.request = request;
        this.pause = pause || 100;
        this.q = new _queue.default(this);
        this.epubcfi = new _epubcfi.default();
        this._locations = [];
        this._locationsWords = [];
        this.total = 0;
        this.break = 150;
        this._current = 0;
        this._wordCounter = 0;
        this.currentLocation = "";
        this._currentCfi = "";
        this.processingTimeout = void 0;
      }
      /**
       * Load all of sections in the book to generate locations
       * @param  {int} chars how many chars to split on
       * @return {Promise<Array<string>>} locations
       */
      generate(chars) {
        if (chars) {
          this.break = chars;
        }
        this.q.pause();
        this.spine.each((function(section) {
          if (section.linear) {
            this.q.enqueue(this.process.bind(this), section);
          }
        }).bind(this));
        return this.q.run().then((function() {
          this.total = this._locations.length - 1;
          if (this._currentCfi) {
            this.currentLocation = this._currentCfi;
          }
          return this._locations;
        }).bind(this));
      }
      createRange() {
        return {
          startContainer: void 0,
          startOffset: void 0,
          endContainer: void 0,
          endOffset: void 0
        };
      }
      process(section) {
        return section.load(this.request).then((function(contents) {
          var completed = new _core.defer();
          var locations = this.parse(contents, section.cfiBase);
          this._locations = this._locations.concat(locations);
          section.unload();
          this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);
          return completed.promise;
        }).bind(this));
      }
      parse(contents, cfiBase, chars) {
        var locations = [];
        var range;
        var doc = contents.ownerDocument;
        var body = (0, _core.qs)(doc, "body");
        var counter = 0;
        var prev;
        var _break = chars || this.break;
        var parser = function(node) {
          var len = node.length;
          var dist;
          var pos = 0;
          if (node.textContent.trim().length === 0) {
            return false;
          }
          if (counter == 0) {
            range = this.createRange();
            range.startContainer = node;
            range.startOffset = 0;
          }
          dist = _break - counter;
          if (dist > len) {
            counter += len;
            pos = len;
          }
          while (pos < len) {
            dist = _break - counter;
            if (counter === 0) {
              pos += 1;
              range = this.createRange();
              range.startContainer = node;
              range.startOffset = pos;
            }
            if (pos + dist >= len) {
              counter += len - pos;
              pos = len;
            } else {
              pos += dist;
              range.endContainer = node;
              range.endOffset = pos;
              let cfi = new _epubcfi.default(range, cfiBase).toString();
              locations.push(cfi);
              counter = 0;
            }
          }
          prev = node;
        };
        (0, _core.sprint)(body, parser.bind(this));
        if (range && range.startContainer && prev) {
          range.endContainer = prev;
          range.endOffset = prev.length;
          let cfi = new _epubcfi.default(range, cfiBase).toString();
          locations.push(cfi);
          counter = 0;
        }
        return locations;
      }
      /**
       * Load all of sections in the book to generate locations
       * @param  {string} startCfi start position
       * @param  {int} wordCount how many words to split on
       * @param  {int} count result count
       * @return {object} locations
       */
      generateFromWords(startCfi, wordCount, count) {
        var start = startCfi ? new _epubcfi.default(startCfi) : void 0;
        this.q.pause();
        this._locationsWords = [];
        this._wordCounter = 0;
        this.spine.each((function(section) {
          if (section.linear) {
            if (start) {
              if (section.index >= start.spinePos) {
                this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);
              }
            } else {
              this.q.enqueue(this.processWords.bind(this), section, wordCount, start, count);
            }
          }
        }).bind(this));
        return this.q.run().then((function() {
          if (this._currentCfi) {
            this.currentLocation = this._currentCfi;
          }
          return this._locationsWords;
        }).bind(this));
      }
      processWords(section, wordCount, startCfi, count) {
        if (count && this._locationsWords.length >= count) {
          return Promise.resolve();
        }
        return section.load(this.request).then((function(contents) {
          var completed = new _core.defer();
          var locations = this.parseWords(contents, section, wordCount, startCfi);
          var remainingCount = count - this._locationsWords.length;
          this._locationsWords = this._locationsWords.concat(locations.length >= count ? locations.slice(0, remainingCount) : locations);
          section.unload();
          this.processingTimeout = setTimeout(() => completed.resolve(locations), this.pause);
          return completed.promise;
        }).bind(this));
      }
      //http://stackoverflow.com/questions/18679576/counting-words-in-string
      countWords(s) {
        s = s.replace(/(^\s*)|(\s*$)/gi, "");
        s = s.replace(/[ ]{2,}/gi, " ");
        s = s.replace(/\n /, "\n");
        return s.split(" ").length;
      }
      parseWords(contents, section, wordCount, startCfi) {
        var cfiBase = section.cfiBase;
        var locations = [];
        var doc = contents.ownerDocument;
        var body = (0, _core.qs)(doc, "body");
        var prev;
        var _break = wordCount;
        var foundStartNode = startCfi ? startCfi.spinePos !== section.index : true;
        var startNode;
        if (startCfi && section.index === startCfi.spinePos) {
          startNode = startCfi.findNode(startCfi.range ? startCfi.path.steps.concat(startCfi.start.steps) : startCfi.path.steps, contents.ownerDocument);
        }
        var parser = function(node) {
          if (!foundStartNode) {
            if (node === startNode) {
              foundStartNode = true;
            } else {
              return false;
            }
          }
          if (node.textContent.length < 10) {
            if (node.textContent.trim().length === 0) {
              return false;
            }
          }
          var len = this.countWords(node.textContent);
          var dist;
          var pos = 0;
          if (len === 0) {
            return false;
          }
          dist = _break - this._wordCounter;
          if (dist > len) {
            this._wordCounter += len;
            pos = len;
          }
          while (pos < len) {
            dist = _break - this._wordCounter;
            if (pos + dist >= len) {
              this._wordCounter += len - pos;
              pos = len;
            } else {
              pos += dist;
              let cfi = new _epubcfi.default(node, cfiBase);
              locations.push({
                cfi: cfi.toString(),
                wordCount: this._wordCounter
              });
              this._wordCounter = 0;
            }
          }
          prev = node;
        };
        (0, _core.sprint)(body, parser.bind(this));
        return locations;
      }
      /**
       * Get a location from an EpubCFI
       * @param {EpubCFI} cfi
       * @return {number}
       */
      locationFromCfi(cfi) {
        let loc;
        if (_epubcfi.default.prototype.isCfiString(cfi)) {
          cfi = new _epubcfi.default(cfi);
        }
        if (this._locations.length === 0) {
          return -1;
        }
        loc = (0, _core.locationOf)(cfi, this._locations, this.epubcfi.compare);
        if (loc > this.total) {
          return this.total;
        }
        return loc;
      }
      /**
       * Get a percentage position in locations from an EpubCFI
       * @param {EpubCFI} cfi
       * @return {number}
       */
      percentageFromCfi(cfi) {
        if (this._locations.length === 0) {
          return null;
        }
        var loc = this.locationFromCfi(cfi);
        return this.percentageFromLocation(loc);
      }
      /**
       * Get a percentage position from a location index
       * @param {number} location
       * @return {number}
       */
      percentageFromLocation(loc) {
        if (!loc || !this.total) {
          return 0;
        }
        return loc / this.total;
      }
      /**
       * Get an EpubCFI from location index
       * @param {number} loc
       * @return {EpubCFI} cfi
       */
      cfiFromLocation(loc) {
        var cfi = -1;
        if (typeof loc != "number") {
          loc = parseInt(loc);
        }
        if (loc >= 0 && loc < this._locations.length) {
          cfi = this._locations[loc];
        }
        return cfi;
      }
      /**
       * Get an EpubCFI from location percentage
       * @param {number} percentage
       * @return {EpubCFI} cfi
       */
      cfiFromPercentage(percentage) {
        let loc;
        if (percentage > 1) {
          console.warn("Normalize cfiFromPercentage value to between 0 - 1");
        }
        if (percentage >= 1) {
          let cfi = new _epubcfi.default(this._locations[this.total]);
          cfi.collapse();
          return cfi.toString();
        }
        loc = Math.ceil(this.total * percentage);
        return this.cfiFromLocation(loc);
      }
      /**
       * Load locations from JSON
       * @param {json} locations
       */
      load(locations) {
        if (typeof locations === "string") {
          this._locations = JSON.parse(locations);
        } else {
          this._locations = locations;
        }
        this.total = this._locations.length - 1;
        return this._locations;
      }
      /**
       * Save locations to JSON
       * @return {json}
       */
      save() {
        return JSON.stringify(this._locations);
      }
      getCurrent() {
        return this._current;
      }
      setCurrent(curr) {
        var loc;
        if (typeof curr == "string") {
          this._currentCfi = curr;
        } else if (typeof curr == "number") {
          this._current = curr;
        } else {
          return;
        }
        if (this._locations.length === 0) {
          return;
        }
        if (typeof curr == "string") {
          loc = this.locationFromCfi(curr);
          this._current = loc;
        } else {
          loc = curr;
        }
        this.emit(_constants.EVENTS.LOCATIONS.CHANGED, {
          percentage: this.percentageFromLocation(loc)
        });
      }
      /**
       * Get the current location
       */
      get currentLocation() {
        return this._current;
      }
      /**
       * Set the current location
       */
      set currentLocation(curr) {
        this.setCurrent(curr);
      }
      /**
       * Locations length
       */
      length() {
        return this._locations.length;
      }
      destroy() {
        this.spine = void 0;
        this.request = void 0;
        this.pause = void 0;
        this.q.stop();
        this.q = void 0;
        this.epubcfi = void 0;
        this._locations = void 0;
        this.total = void 0;
        this.break = void 0;
        this._current = void 0;
        this.currentLocation = void 0;
        this._currentCfi = void 0;
        clearTimeout(this.processingTimeout);
      }
    };
    (0, _eventEmitter.default)(Locations.prototype);
    var _default = Locations;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/container.js
var require_container = __commonJS({
  "node_modules/epubjs/lib/container.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _pathWebpack = _interopRequireDefault(require_path());
    var _core = require_core();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Container = class {
      constructor(containerDocument) {
        this.packagePath = "";
        this.directory = "";
        this.encoding = "";
        if (containerDocument) {
          this.parse(containerDocument);
        }
      }
      /**
       * Parse the Container XML
       * @param  {document} containerDocument
       */
      parse(containerDocument) {
        var rootfile;
        if (!containerDocument) {
          throw new Error("Container File Not Found");
        }
        rootfile = (0, _core.qs)(containerDocument, "rootfile");
        if (!rootfile) {
          throw new Error("No RootFile Found");
        }
        this.packagePath = rootfile.getAttribute("full-path");
        this.directory = _pathWebpack.default.dirname(this.packagePath);
        this.encoding = containerDocument.xmlEncoding;
      }
      destroy() {
        this.packagePath = void 0;
        this.directory = void 0;
        this.encoding = void 0;
      }
    };
    var _default = Container;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/packaging.js
var require_packaging = __commonJS({
  "node_modules/epubjs/lib/packaging.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var Packaging = class {
      constructor(packageDocument) {
        this.manifest = {};
        this.navPath = "";
        this.ncxPath = "";
        this.coverPath = "";
        this.spineNodeIndex = 0;
        this.spine = [];
        this.metadata = {};
        if (packageDocument) {
          this.parse(packageDocument);
        }
      }
      /**
       * Parse OPF XML
       * @param  {document} packageDocument OPF XML
       * @return {object} parsed package parts
       */
      parse(packageDocument) {
        var metadataNode, manifestNode, spineNode;
        if (!packageDocument) {
          throw new Error("Package File Not Found");
        }
        metadataNode = (0, _core.qs)(packageDocument, "metadata");
        if (!metadataNode) {
          throw new Error("No Metadata Found");
        }
        manifestNode = (0, _core.qs)(packageDocument, "manifest");
        if (!manifestNode) {
          throw new Error("No Manifest Found");
        }
        spineNode = (0, _core.qs)(packageDocument, "spine");
        if (!spineNode) {
          throw new Error("No Spine Found");
        }
        this.manifest = this.parseManifest(manifestNode);
        this.navPath = this.findNavPath(manifestNode);
        this.ncxPath = this.findNcxPath(manifestNode, spineNode);
        this.coverPath = this.findCoverPath(packageDocument);
        this.spineNodeIndex = (0, _core.indexOfElementNode)(spineNode);
        this.spine = this.parseSpine(spineNode, this.manifest);
        this.uniqueIdentifier = this.findUniqueIdentifier(packageDocument);
        this.metadata = this.parseMetadata(metadataNode);
        this.metadata.direction = spineNode.getAttribute("page-progression-direction");
        return {
          "metadata": this.metadata,
          "spine": this.spine,
          "manifest": this.manifest,
          "navPath": this.navPath,
          "ncxPath": this.ncxPath,
          "coverPath": this.coverPath,
          "spineNodeIndex": this.spineNodeIndex
        };
      }
      /**
       * Parse Metadata
       * @private
       * @param  {node} xml
       * @return {object} metadata
       */
      parseMetadata(xml) {
        var metadata = {};
        metadata.title = this.getElementText(xml, "title");
        metadata.creator = this.getElementText(xml, "creator");
        metadata.description = this.getElementText(xml, "description");
        metadata.pubdate = this.getElementText(xml, "date");
        metadata.publisher = this.getElementText(xml, "publisher");
        metadata.identifier = this.getElementText(xml, "identifier");
        metadata.language = this.getElementText(xml, "language");
        metadata.rights = this.getElementText(xml, "rights");
        metadata.modified_date = this.getPropertyText(xml, "dcterms:modified");
        metadata.layout = this.getPropertyText(xml, "rendition:layout");
        metadata.orientation = this.getPropertyText(xml, "rendition:orientation");
        metadata.flow = this.getPropertyText(xml, "rendition:flow");
        metadata.viewport = this.getPropertyText(xml, "rendition:viewport");
        metadata.media_active_class = this.getPropertyText(xml, "media:active-class");
        metadata.spread = this.getPropertyText(xml, "rendition:spread");
        return metadata;
      }
      /**
       * Parse Manifest
       * @private
       * @param  {node} manifestXml
       * @return {object} manifest
       */
      parseManifest(manifestXml) {
        var manifest = {};
        var selected = (0, _core.qsa)(manifestXml, "item");
        var items = Array.prototype.slice.call(selected);
        items.forEach(function(item) {
          var id = item.getAttribute("id"), href = item.getAttribute("href") || "", type = item.getAttribute("media-type") || "", overlay = item.getAttribute("media-overlay") || "", properties = item.getAttribute("properties") || "";
          manifest[id] = {
            "href": href,
            // "url" : href,
            "type": type,
            "overlay": overlay,
            "properties": properties.length ? properties.split(" ") : []
          };
        });
        return manifest;
      }
      /**
       * Parse Spine
       * @private
       * @param  {node} spineXml
       * @param  {Packaging.manifest} manifest
       * @return {object} spine
       */
      parseSpine(spineXml, manifest) {
        var spine = [];
        var selected = (0, _core.qsa)(spineXml, "itemref");
        var items = Array.prototype.slice.call(selected);
        items.forEach(function(item, index) {
          var idref = item.getAttribute("idref");
          var props = item.getAttribute("properties") || "";
          var propArray = props.length ? props.split(" ") : [];
          var itemref = {
            "id": item.getAttribute("id"),
            "idref": idref,
            "linear": item.getAttribute("linear") || "yes",
            "properties": propArray,
            // "href" : manifest[Id].href,
            // "url" :  manifest[Id].url,
            "index": index
            // "cfiBase" : cfiBase
          };
          spine.push(itemref);
        });
        return spine;
      }
      /**
       * Find Unique Identifier
       * @private
       * @param  {node} packageXml
       * @return {string} Unique Identifier text
       */
      findUniqueIdentifier(packageXml) {
        var uniqueIdentifierId = packageXml.documentElement.getAttribute("unique-identifier");
        if (!uniqueIdentifierId) {
          return "";
        }
        var identifier = packageXml.getElementById(uniqueIdentifierId);
        if (!identifier) {
          return "";
        }
        if (identifier.localName === "identifier" && identifier.namespaceURI === "http://purl.org/dc/elements/1.1/") {
          return identifier.childNodes.length > 0 ? identifier.childNodes[0].nodeValue.trim() : "";
        }
        return "";
      }
      /**
       * Find TOC NAV
       * @private
       * @param {element} manifestNode
       * @return {string}
       */
      findNavPath(manifestNode) {
        var node = (0, _core.qsp)(manifestNode, "item", {
          "properties": "nav"
        });
        return node ? node.getAttribute("href") : false;
      }
      /**
       * Find TOC NCX
       * media-type="application/x-dtbncx+xml" href="toc.ncx"
       * @private
       * @param {element} manifestNode
       * @param {element} spineNode
       * @return {string}
       */
      findNcxPath(manifestNode, spineNode) {
        var node = (0, _core.qsp)(manifestNode, "item", {
          "media-type": "application/x-dtbncx+xml"
        });
        var tocId;
        if (!node) {
          tocId = spineNode.getAttribute("toc");
          if (tocId) {
            node = manifestNode.querySelector(`#${tocId}`);
          }
        }
        return node ? node.getAttribute("href") : false;
      }
      /**
       * Find the Cover Path
       * <item properties="cover-image" id="ci" href="cover.svg" media-type="image/svg+xml" />
       * Fallback for Epub 2.0
       * @private
       * @param  {node} packageXml
       * @return {string} href
       */
      findCoverPath(packageXml) {
        var pkg = (0, _core.qs)(packageXml, "package");
        var epubVersion = pkg.getAttribute("version");
        var node = (0, _core.qsp)(packageXml, "item", {
          "properties": "cover-image"
        });
        if (node) return node.getAttribute("href");
        var metaCover = (0, _core.qsp)(packageXml, "meta", {
          "name": "cover"
        });
        if (metaCover) {
          var coverId = metaCover.getAttribute("content");
          var cover = packageXml.getElementById(coverId);
          return cover ? cover.getAttribute("href") : "";
        } else {
          return false;
        }
      }
      /**
       * Get text of a namespaced element
       * @private
       * @param  {node} xml
       * @param  {string} tag
       * @return {string} text
       */
      getElementText(xml, tag) {
        var found = xml.getElementsByTagNameNS("http://purl.org/dc/elements/1.1/", tag);
        var el;
        if (!found || found.length === 0) return "";
        el = found[0];
        if (el.childNodes.length) {
          return el.childNodes[0].nodeValue;
        }
        return "";
      }
      /**
       * Get text by property
       * @private
       * @param  {node} xml
       * @param  {string} property
       * @return {string} text
       */
      getPropertyText(xml, property) {
        var el = (0, _core.qsp)(xml, "meta", {
          "property": property
        });
        if (el && el.childNodes.length) {
          return el.childNodes[0].nodeValue;
        }
        return "";
      }
      /**
       * Load JSON Manifest
       * @param  {document} packageDocument OPF XML
       * @return {object} parsed package parts
       */
      load(json) {
        this.metadata = json.metadata;
        let spine = json.readingOrder || json.spine;
        this.spine = spine.map((item, index) => {
          item.index = index;
          item.linear = item.linear || "yes";
          return item;
        });
        json.resources.forEach((item, index) => {
          this.manifest[index] = item;
          if (item.rel && item.rel[0] === "cover") {
            this.coverPath = item.href;
          }
        });
        this.spineNodeIndex = 0;
        this.toc = json.toc.map((item, index) => {
          item.label = item.title;
          return item;
        });
        return {
          "metadata": this.metadata,
          "spine": this.spine,
          "manifest": this.manifest,
          "navPath": this.navPath,
          "ncxPath": this.ncxPath,
          "coverPath": this.coverPath,
          "spineNodeIndex": this.spineNodeIndex,
          "toc": this.toc
        };
      }
      destroy() {
        this.manifest = void 0;
        this.navPath = void 0;
        this.ncxPath = void 0;
        this.coverPath = void 0;
        this.spineNodeIndex = void 0;
        this.spine = void 0;
        this.metadata = void 0;
      }
    };
    var _default = Packaging;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/navigation.js
var require_navigation = __commonJS({
  "node_modules/epubjs/lib/navigation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var Navigation = class {
      constructor(xml) {
        this.toc = [];
        this.tocByHref = {};
        this.tocById = {};
        this.landmarks = [];
        this.landmarksByType = {};
        this.length = 0;
        if (xml) {
          this.parse(xml);
        }
      }
      /**
       * Parse out the navigation items
       * @param {document} xml navigation html / xhtml / ncx
       */
      parse(xml) {
        let isXml = xml.nodeType;
        let html;
        let ncx;
        if (isXml) {
          html = (0, _core.qs)(xml, "html");
          ncx = (0, _core.qs)(xml, "ncx");
        }
        if (!isXml) {
          this.toc = this.load(xml);
        } else if (html) {
          this.toc = this.parseNav(xml);
          this.landmarks = this.parseLandmarks(xml);
        } else if (ncx) {
          this.toc = this.parseNcx(xml);
        }
        this.length = 0;
        this.unpack(this.toc);
      }
      /**
       * Unpack navigation items
       * @private
       * @param  {array} toc
       */
      unpack(toc) {
        var item;
        for (var i = 0; i < toc.length; i++) {
          item = toc[i];
          if (item.href) {
            this.tocByHref[item.href] = i;
          }
          if (item.id) {
            this.tocById[item.id] = i;
          }
          this.length++;
          if (item.subitems.length) {
            this.unpack(item.subitems);
          }
        }
      }
      /**
       * Get an item from the navigation
       * @param  {string} target
       * @return {object} navItem
       */
      get(target) {
        var index;
        if (!target) {
          return this.toc;
        }
        if (target.indexOf("#") === 0) {
          index = this.tocById[target.substring(1)];
        } else if (target in this.tocByHref) {
          index = this.tocByHref[target];
        }
        return this.getByIndex(target, index, this.toc);
      }
      /**
       * Get an item from navigation subitems recursively by index
       * @param  {string} target
       * @param  {number} index
       * @param  {array} navItems
       * @return {object} navItem
       */
      getByIndex(target, index, navItems) {
        if (navItems.length === 0) {
          return;
        }
        const item = navItems[index];
        if (item && (target === item.id || target === item.href)) {
          return item;
        } else {
          let result;
          for (let i = 0; i < navItems.length; ++i) {
            result = this.getByIndex(target, index, navItems[i].subitems);
            if (result) {
              break;
            }
          }
          return result;
        }
      }
      /**
       * Get a landmark by type
       * List of types: https://idpf.github.io/epub-vocabs/structure/
       * @param  {string} type
       * @return {object} landmarkItem
       */
      landmark(type) {
        var index;
        if (!type) {
          return this.landmarks;
        }
        index = this.landmarksByType[type];
        return this.landmarks[index];
      }
      /**
       * Parse toc from a Epub > 3.0 Nav
       * @private
       * @param  {document} navHtml
       * @return {array} navigation list
       */
      parseNav(navHtml) {
        var navElement = (0, _core.querySelectorByType)(navHtml, "nav", "toc");
        var list = [];
        if (!navElement) return list;
        let navList = (0, _core.filterChildren)(navElement, "ol", true);
        if (!navList) return list;
        list = this.parseNavList(navList);
        return list;
      }
      /**
       * Parses lists in the toc
       * @param  {document} navListHtml
       * @param  {string} parent id
       * @return {array} navigation list
       */
      parseNavList(navListHtml, parent2) {
        const result = [];
        if (!navListHtml) return result;
        if (!navListHtml.children) return result;
        for (let i = 0; i < navListHtml.children.length; i++) {
          const item = this.navItem(navListHtml.children[i], parent2);
          if (item) {
            result.push(item);
          }
        }
        return result;
      }
      /**
       * Create a navItem
       * @private
       * @param  {element} item
       * @return {object} navItem
       */
      navItem(item, parent2) {
        let id = item.getAttribute("id") || void 0;
        let content = (0, _core.filterChildren)(item, "a", true) || (0, _core.filterChildren)(item, "span", true);
        if (!content) {
          return;
        }
        let src = content.getAttribute("href") || "";
        if (!id) {
          id = src;
        }
        let text = content.textContent || "";
        let subitems = [];
        let nested = (0, _core.filterChildren)(item, "ol", true);
        if (nested) {
          subitems = this.parseNavList(nested, id);
        }
        return {
          "id": id,
          "href": src,
          "label": text,
          "subitems": subitems,
          "parent": parent2
        };
      }
      /**
       * Parse landmarks from a Epub > 3.0 Nav
       * @private
       * @param  {document} navHtml
       * @return {array} landmarks list
       */
      parseLandmarks(navHtml) {
        var navElement = (0, _core.querySelectorByType)(navHtml, "nav", "landmarks");
        var navItems = navElement ? (0, _core.qsa)(navElement, "li") : [];
        var length = navItems.length;
        var i;
        var list = [];
        var item;
        if (!navItems || length === 0) return list;
        for (i = 0; i < length; ++i) {
          item = this.landmarkItem(navItems[i]);
          if (item) {
            list.push(item);
            this.landmarksByType[item.type] = i;
          }
        }
        return list;
      }
      /**
       * Create a landmarkItem
       * @private
       * @param  {element} item
       * @return {object} landmarkItem
       */
      landmarkItem(item) {
        let content = (0, _core.filterChildren)(item, "a", true);
        if (!content) {
          return;
        }
        let type = content.getAttributeNS("http://www.idpf.org/2007/ops", "type") || void 0;
        let href = content.getAttribute("href") || "";
        let text = content.textContent || "";
        return {
          "href": href,
          "label": text,
          "type": type
        };
      }
      /**
       * Parse from a Epub > 3.0 NC
       * @private
       * @param  {document} navHtml
       * @return {array} navigation list
       */
      parseNcx(tocXml) {
        var navPoints = (0, _core.qsa)(tocXml, "navPoint");
        var length = navPoints.length;
        var i;
        var toc = {};
        var list = [];
        var item, parent2;
        if (!navPoints || length === 0) return list;
        for (i = 0; i < length; ++i) {
          item = this.ncxItem(navPoints[i]);
          toc[item.id] = item;
          if (!item.parent) {
            list.push(item);
          } else {
            parent2 = toc[item.parent];
            parent2.subitems.push(item);
          }
        }
        return list;
      }
      /**
       * Create a ncxItem
       * @private
       * @param  {element} item
       * @return {object} ncxItem
       */
      ncxItem(item) {
        var id = item.getAttribute("id") || false, content = (0, _core.qs)(item, "content"), src = content.getAttribute("src"), navLabel = (0, _core.qs)(item, "navLabel"), text = navLabel.textContent ? navLabel.textContent : "", subitems = [], parentNode = item.parentNode, parent2;
        if (parentNode && (parentNode.nodeName === "navPoint" || parentNode.nodeName.split(":").slice(-1)[0] === "navPoint")) {
          parent2 = parentNode.getAttribute("id");
        }
        return {
          "id": id,
          "href": src,
          "label": text,
          "subitems": subitems,
          "parent": parent2
        };
      }
      /**
       * Load Spine Items
       * @param  {object} json the items to be loaded
       * @return {Array} navItems
       */
      load(json) {
        return json.map((item) => {
          item.label = item.title;
          item.subitems = item.children ? this.load(item.children) : [];
          return item;
        });
      }
      /**
       * forEach pass through
       * @param  {Function} fn function to run on each item
       * @return {method} forEach loop
       */
      forEach(fn) {
        return this.toc.forEach(fn);
      }
    };
    var _default = Navigation;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/mime.js
var require_mime = __commonJS({
  "node_modules/epubjs/lib/utils/mime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var table = {
      "application": {
        "ecmascript": ["es", "ecma"],
        "javascript": "js",
        "ogg": "ogx",
        "pdf": "pdf",
        "postscript": ["ps", "ai", "eps", "epsi", "epsf", "eps2", "eps3"],
        "rdf+xml": "rdf",
        "smil": ["smi", "smil"],
        "xhtml+xml": ["xhtml", "xht"],
        "xml": ["xml", "xsl", "xsd", "opf", "ncx"],
        "zip": "zip",
        "x-httpd-eruby": "rhtml",
        "x-latex": "latex",
        "x-maker": ["frm", "maker", "frame", "fm", "fb", "book", "fbdoc"],
        "x-object": "o",
        "x-shockwave-flash": ["swf", "swfl"],
        "x-silverlight": "scr",
        "epub+zip": "epub",
        "font-tdpfr": "pfr",
        "inkml+xml": ["ink", "inkml"],
        "json": "json",
        "jsonml+json": "jsonml",
        "mathml+xml": "mathml",
        "metalink+xml": "metalink",
        "mp4": "mp4s",
        // "oebps-package+xml" : "opf",
        "omdoc+xml": "omdoc",
        "oxps": "oxps",
        "vnd.amazon.ebook": "azw",
        "widget": "wgt",
        // "x-dtbncx+xml" : "ncx",
        "x-dtbook+xml": "dtb",
        "x-dtbresource+xml": "res",
        "x-font-bdf": "bdf",
        "x-font-ghostscript": "gsf",
        "x-font-linux-psf": "psf",
        "x-font-otf": "otf",
        "x-font-pcf": "pcf",
        "x-font-snf": "snf",
        "x-font-ttf": ["ttf", "ttc"],
        "x-font-type1": ["pfa", "pfb", "pfm", "afm"],
        "x-font-woff": "woff",
        "x-mobipocket-ebook": ["prc", "mobi"],
        "x-mspublisher": "pub",
        "x-nzb": "nzb",
        "x-tgif": "obj",
        "xaml+xml": "xaml",
        "xml-dtd": "dtd",
        "xproc+xml": "xpl",
        "xslt+xml": "xslt",
        "internet-property-stream": "acx",
        "x-compress": "z",
        "x-compressed": "tgz",
        "x-gzip": "gz"
      },
      "audio": {
        "flac": "flac",
        "midi": ["mid", "midi", "kar", "rmi"],
        "mpeg": ["mpga", "mpega", "mp2", "mp3", "m4a", "mp2a", "m2a", "m3a"],
        "mpegurl": "m3u",
        "ogg": ["oga", "ogg", "spx"],
        "x-aiff": ["aif", "aiff", "aifc"],
        "x-ms-wma": "wma",
        "x-wav": "wav",
        "adpcm": "adp",
        "mp4": "mp4a",
        "webm": "weba",
        "x-aac": "aac",
        "x-caf": "caf",
        "x-matroska": "mka",
        "x-pn-realaudio-plugin": "rmp",
        "xm": "xm",
        "mid": ["mid", "rmi"]
      },
      "image": {
        "gif": "gif",
        "ief": "ief",
        "jpeg": ["jpeg", "jpg", "jpe"],
        "pcx": "pcx",
        "png": "png",
        "svg+xml": ["svg", "svgz"],
        "tiff": ["tiff", "tif"],
        "x-icon": "ico",
        "bmp": "bmp",
        "webp": "webp",
        "x-pict": ["pic", "pct"],
        "x-tga": "tga",
        "cis-cod": "cod"
      },
      "text": {
        "cache-manifest": ["manifest", "appcache"],
        "css": "css",
        "csv": "csv",
        "html": ["html", "htm", "shtml", "stm"],
        "mathml": "mml",
        "plain": ["txt", "text", "brf", "conf", "def", "list", "log", "in", "bas"],
        "richtext": "rtx",
        "tab-separated-values": "tsv",
        "x-bibtex": "bib"
      },
      "video": {
        "mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v", "mp2", "mpa", "mpv2"],
        "mp4": ["mp4", "mp4v", "mpg4"],
        "quicktime": ["qt", "mov"],
        "ogg": "ogv",
        "vnd.mpegurl": ["mxu", "m4u"],
        "x-flv": "flv",
        "x-la-asf": ["lsf", "lsx"],
        "x-mng": "mng",
        "x-ms-asf": ["asf", "asx", "asr"],
        "x-ms-wm": "wm",
        "x-ms-wmv": "wmv",
        "x-ms-wmx": "wmx",
        "x-ms-wvx": "wvx",
        "x-msvideo": "avi",
        "x-sgi-movie": "movie",
        "x-matroska": ["mpv", "mkv", "mk3d", "mks"],
        "3gpp2": "3g2",
        "h261": "h261",
        "h263": "h263",
        "h264": "h264",
        "jpeg": "jpgv",
        "jpm": ["jpm", "jpgm"],
        "mj2": ["mj2", "mjp2"],
        "vnd.ms-playready.media.pyv": "pyv",
        "vnd.uvvu.mp4": ["uvu", "uvvu"],
        "vnd.vivo": "viv",
        "webm": "webm",
        "x-f4v": "f4v",
        "x-m4v": "m4v",
        "x-ms-vob": "vob",
        "x-smv": "smv"
      }
    };
    var mimeTypes = function() {
      var type, subtype, val, index, mimeTypes2 = {};
      for (type in table) {
        if (table.hasOwnProperty(type)) {
          for (subtype in table[type]) {
            if (table[type].hasOwnProperty(subtype)) {
              val = table[type][subtype];
              if (typeof val == "string") {
                mimeTypes2[val] = type + "/" + subtype;
              } else {
                for (index = 0; index < val.length; index++) {
                  mimeTypes2[val[index]] = type + "/" + subtype;
                }
              }
            }
          }
        }
      }
      return mimeTypes2;
    }();
    var defaultValue = "text/plain";
    function lookup(filename) {
      return filename && mimeTypes[filename.split(".").pop().toLowerCase()] || defaultValue;
    }
    var _default = {
      lookup
    };
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/resources.js
var require_resources = __commonJS({
  "node_modules/epubjs/lib/resources.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _replacements = require_replacements();
    var _core = require_core();
    var _url = _interopRequireDefault(require_url());
    var _mime = _interopRequireDefault(require_mime());
    var _path = _interopRequireDefault(require_path2());
    var _pathWebpack = _interopRequireDefault(require_path());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Resources = class {
      constructor(manifest, options) {
        this.settings = {
          replacements: options && options.replacements || "base64",
          archive: options && options.archive,
          resolver: options && options.resolver,
          request: options && options.request
        };
        this.process(manifest);
      }
      /**
       * Process resources
       * @param {Manifest} manifest
       */
      process(manifest) {
        this.manifest = manifest;
        this.resources = Object.keys(manifest).map(function(key) {
          return manifest[key];
        });
        this.replacementUrls = [];
        this.html = [];
        this.assets = [];
        this.css = [];
        this.urls = [];
        this.cssUrls = [];
        this.split();
        this.splitUrls();
      }
      /**
       * Split resources by type
       * @private
       */
      split() {
        this.html = this.resources.filter(function(item) {
          if (item.type === "application/xhtml+xml" || item.type === "text/html") {
            return true;
          }
        });
        this.assets = this.resources.filter(function(item) {
          if (item.type !== "application/xhtml+xml" && item.type !== "text/html") {
            return true;
          }
        });
        this.css = this.resources.filter(function(item) {
          if (item.type === "text/css") {
            return true;
          }
        });
      }
      /**
       * Convert split resources into Urls
       * @private
       */
      splitUrls() {
        this.urls = this.assets.map((function(item) {
          return item.href;
        }).bind(this));
        this.cssUrls = this.css.map(function(item) {
          return item.href;
        });
      }
      /**
       * Create a url to a resource
       * @param {string} url
       * @return {Promise<string>} Promise resolves with url string
       */
      createUrl(url) {
        var parsedUrl = new _url.default(url);
        var mimeType = _mime.default.lookup(parsedUrl.filename);
        if (this.settings.archive) {
          return this.settings.archive.createUrl(url, {
            "base64": this.settings.replacements === "base64"
          });
        } else {
          if (this.settings.replacements === "base64") {
            return this.settings.request(url, "blob").then((blob) => {
              return (0, _core.blob2base64)(blob);
            }).then((blob) => {
              return (0, _core.createBase64Url)(blob, mimeType);
            });
          } else {
            return this.settings.request(url, "blob").then((blob) => {
              return (0, _core.createBlobUrl)(blob, mimeType);
            });
          }
        }
      }
      /**
       * Create blob urls for all the assets
       * @return {Promise}         returns replacement urls
       */
      replacements() {
        if (this.settings.replacements === "none") {
          return new Promise((function(resolve) {
            resolve(this.urls);
          }).bind(this));
        }
        var replacements = this.urls.map((url) => {
          var absolute = this.settings.resolver(url);
          return this.createUrl(absolute).catch((err) => {
            console.error(err);
            return null;
          });
        });
        return Promise.all(replacements).then((replacementUrls) => {
          this.replacementUrls = replacementUrls.filter((url) => {
            return typeof url === "string";
          });
          return replacementUrls;
        });
      }
      /**
       * Replace URLs in CSS resources
       * @private
       * @param  {Archive} [archive]
       * @param  {method} [resolver]
       * @return {Promise}
       */
      replaceCss(archive, resolver) {
        var replaced = [];
        archive = archive || this.settings.archive;
        resolver = resolver || this.settings.resolver;
        this.cssUrls.forEach((function(href) {
          var replacement = this.createCssFile(href, archive, resolver).then((function(replacementUrl) {
            var indexInUrls = this.urls.indexOf(href);
            if (indexInUrls > -1) {
              this.replacementUrls[indexInUrls] = replacementUrl;
            }
          }).bind(this));
          replaced.push(replacement);
        }).bind(this));
        return Promise.all(replaced);
      }
      /**
       * Create a new CSS file with the replaced URLs
       * @private
       * @param  {string} href the original css file
       * @return {Promise}  returns a BlobUrl to the new CSS file or a data url
       */
      createCssFile(href) {
        var newUrl;
        if (_pathWebpack.default.isAbsolute(href)) {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        var absolute = this.settings.resolver(href);
        var textResponse;
        if (this.settings.archive) {
          textResponse = this.settings.archive.getText(absolute);
        } else {
          textResponse = this.settings.request(absolute, "text");
        }
        var relUrls = this.urls.map((assetHref) => {
          var resolved = this.settings.resolver(assetHref);
          var relative = new _path.default(absolute).relative(resolved);
          return relative;
        });
        if (!textResponse) {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        return textResponse.then((text) => {
          text = (0, _replacements.substitute)(text, relUrls, this.replacementUrls);
          if (this.settings.replacements === "base64") {
            newUrl = (0, _core.createBase64Url)(text, "text/css");
          } else {
            newUrl = (0, _core.createBlobUrl)(text, "text/css");
          }
          return newUrl;
        }, (err) => {
          return new Promise(function(resolve) {
            resolve();
          });
        });
      }
      /**
       * Resolve all resources URLs relative to an absolute URL
       * @param  {string} absolute to be resolved to
       * @param  {resolver} [resolver]
       * @return {string[]} array with relative Urls
       */
      relativeTo(absolute, resolver) {
        resolver = resolver || this.settings.resolver;
        return this.urls.map((function(href) {
          var resolved = resolver(href);
          var relative = new _path.default(absolute).relative(resolved);
          return relative;
        }).bind(this));
      }
      /**
       * Get a URL for a resource
       * @param  {string} path
       * @return {string} url
       */
      get(path) {
        var indexInUrls = this.urls.indexOf(path);
        if (indexInUrls === -1) {
          return;
        }
        if (this.replacementUrls.length) {
          return new Promise((function(resolve, reject) {
            resolve(this.replacementUrls[indexInUrls]);
          }).bind(this));
        } else {
          return this.createUrl(path);
        }
      }
      /**
       * Substitute urls in content, with replacements,
       * relative to a url if provided
       * @param  {string} content
       * @param  {string} [url]   url to resolve to
       * @return {string}         content with urls substituted
       */
      substitute(content, url) {
        var relUrls;
        if (url) {
          relUrls = this.relativeTo(url);
        } else {
          relUrls = this.urls;
        }
        return (0, _replacements.substitute)(content, relUrls, this.replacementUrls);
      }
      destroy() {
        this.settings = void 0;
        this.manifest = void 0;
        this.resources = void 0;
        this.replacementUrls = void 0;
        this.html = void 0;
        this.assets = void 0;
        this.css = void 0;
        this.urls = void 0;
        this.cssUrls = void 0;
      }
    };
    var _default = Resources;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/pagelist.js
var require_pagelist = __commonJS({
  "node_modules/epubjs/lib/pagelist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _core = require_core();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PageList = class {
      constructor(xml) {
        this.pages = [];
        this.locations = [];
        this.epubcfi = new _epubcfi.default();
        this.firstPage = 0;
        this.lastPage = 0;
        this.totalPages = 0;
        this.toc = void 0;
        this.ncx = void 0;
        if (xml) {
          this.pageList = this.parse(xml);
        }
        if (this.pageList && this.pageList.length) {
          this.process(this.pageList);
        }
      }
      /**
       * Parse PageList Xml
       * @param  {document} xml
       */
      parse(xml) {
        var html = (0, _core.qs)(xml, "html");
        var ncx = (0, _core.qs)(xml, "ncx");
        if (html) {
          return this.parseNav(xml);
        } else if (ncx) {
          return this.parseNcx(xml);
        }
      }
      /**
       * Parse a Nav PageList
       * @private
       * @param  {node} navHtml
       * @return {PageList.item[]} list
       */
      parseNav(navHtml) {
        var navElement = (0, _core.querySelectorByType)(navHtml, "nav", "page-list");
        var navItems = navElement ? (0, _core.qsa)(navElement, "li") : [];
        var length = navItems.length;
        var i;
        var list = [];
        var item;
        if (!navItems || length === 0) return list;
        for (i = 0; i < length; ++i) {
          item = this.item(navItems[i]);
          list.push(item);
        }
        return list;
      }
      parseNcx(navXml) {
        var list = [];
        var i = 0;
        var item;
        var pageList;
        var pageTargets;
        var length = 0;
        pageList = (0, _core.qs)(navXml, "pageList");
        if (!pageList) return list;
        pageTargets = (0, _core.qsa)(pageList, "pageTarget");
        length = pageTargets.length;
        if (!pageTargets || pageTargets.length === 0) {
          return list;
        }
        for (i = 0; i < length; ++i) {
          item = this.ncxItem(pageTargets[i]);
          list.push(item);
        }
        return list;
      }
      ncxItem(item) {
        var navLabel = (0, _core.qs)(item, "navLabel");
        var navLabelText = (0, _core.qs)(navLabel, "text");
        var pageText = navLabelText.textContent;
        var content = (0, _core.qs)(item, "content");
        var href = content.getAttribute("src");
        var page = parseInt(pageText, 10);
        return {
          "href": href,
          "page": page
        };
      }
      /**
       * Page List Item
       * @private
       * @param  {node} item
       * @return {object} pageListItem
       */
      item(item) {
        var content = (0, _core.qs)(item, "a"), href = content.getAttribute("href") || "", text = content.textContent || "", page = parseInt(text), isCfi = href.indexOf("epubcfi"), split, packageUrl, cfi;
        if (isCfi != -1) {
          split = href.split("#");
          packageUrl = split[0];
          cfi = split.length > 1 ? split[1] : false;
          return {
            "cfi": cfi,
            "href": href,
            "packageUrl": packageUrl,
            "page": page
          };
        } else {
          return {
            "href": href,
            "page": page
          };
        }
      }
      /**
       * Process pageList items
       * @private
       * @param  {array} pageList
       */
      process(pageList) {
        pageList.forEach(function(item) {
          this.pages.push(item.page);
          if (item.cfi) {
            this.locations.push(item.cfi);
          }
        }, this);
        this.firstPage = parseInt(this.pages[0]);
        this.lastPage = parseInt(this.pages[this.pages.length - 1]);
        this.totalPages = this.lastPage - this.firstPage;
      }
      /**
       * Get a PageList result from a EpubCFI
       * @param  {string} cfi EpubCFI String
       * @return {number} page
       */
      pageFromCfi(cfi) {
        var pg = -1;
        if (this.locations.length === 0) {
          return -1;
        }
        var index = (0, _core.indexOfSorted)(cfi, this.locations, this.epubcfi.compare);
        if (index != -1) {
          pg = this.pages[index];
        } else {
          index = (0, _core.locationOf)(cfi, this.locations, this.epubcfi.compare);
          pg = index - 1 >= 0 ? this.pages[index - 1] : this.pages[0];
          if (pg !== void 0) {
          } else {
            pg = -1;
          }
        }
        return pg;
      }
      /**
       * Get an EpubCFI from a Page List Item
       * @param  {string | number} pg
       * @return {string} cfi
       */
      cfiFromPage(pg) {
        var cfi = -1;
        if (typeof pg != "number") {
          pg = parseInt(pg);
        }
        var index = this.pages.indexOf(pg);
        if (index != -1) {
          cfi = this.locations[index];
        }
        return cfi;
      }
      /**
       * Get a Page from Book percentage
       * @param  {number} percent
       * @return {number} page
       */
      pageFromPercentage(percent) {
        var pg = Math.round(this.totalPages * percent);
        return pg;
      }
      /**
       * Returns a value between 0 - 1 corresponding to the location of a page
       * @param  {number} pg the page
       * @return {number} percentage
       */
      percentageFromPage(pg) {
        var percentage = (pg - this.firstPage) / this.totalPages;
        return Math.round(percentage * 1e3) / 1e3;
      }
      /**
       * Returns a value between 0 - 1 corresponding to the location of a cfi
       * @param  {string} cfi EpubCFI String
       * @return {number} percentage
       */
      percentageFromCfi(cfi) {
        var pg = this.pageFromCfi(cfi);
        var percentage = this.percentageFromPage(pg);
        return percentage;
      }
      /**
       * Destroy
       */
      destroy() {
        this.pages = void 0;
        this.locations = void 0;
        this.epubcfi = void 0;
        this.pageList = void 0;
        this.toc = void 0;
        this.ncx = void 0;
      }
    };
    var _default = PageList;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/layout.js
var require_layout = __commonJS({
  "node_modules/epubjs/lib/layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _constants = require_constants();
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Layout = class {
      constructor(settings) {
        this.settings = settings;
        this.name = settings.layout || "reflowable";
        this._spread = settings.spread === "none" ? false : true;
        this._minSpreadWidth = settings.minSpreadWidth || 800;
        this._evenSpreads = settings.evenSpreads || false;
        if (settings.flow === "scrolled" || settings.flow === "scrolled-continuous" || settings.flow === "scrolled-doc") {
          this._flow = "scrolled";
        } else {
          this._flow = "paginated";
        }
        this.width = 0;
        this.height = 0;
        this.spreadWidth = 0;
        this.delta = 0;
        this.columnWidth = 0;
        this.gap = 0;
        this.divisor = 1;
        this.props = {
          name: this.name,
          spread: this._spread,
          flow: this._flow,
          width: 0,
          height: 0,
          spreadWidth: 0,
          delta: 0,
          columnWidth: 0,
          gap: 0,
          divisor: 1
        };
      }
      /**
       * Switch the flow between paginated and scrolled
       * @param  {string} flow paginated | scrolled
       * @return {string} simplified flow
       */
      flow(flow) {
        if (typeof flow != "undefined") {
          if (flow === "scrolled" || flow === "scrolled-continuous" || flow === "scrolled-doc") {
            this._flow = "scrolled";
          } else {
            this._flow = "paginated";
          }
          this.update({
            flow: this._flow
          });
        }
        return this._flow;
      }
      /**
       * Switch between using spreads or not, and set the
       * width at which they switch to single.
       * @param  {string} spread "none" | "always" | "auto"
       * @param  {number} min integer in pixels
       * @return {boolean} spread true | false
       */
      spread(spread, min) {
        if (spread) {
          this._spread = spread === "none" ? false : true;
          this.update({
            spread: this._spread
          });
        }
        if (min >= 0) {
          this._minSpreadWidth = min;
        }
        return this._spread;
      }
      /**
       * Calculate the dimensions of the pagination
       * @param  {number} _width  width of the rendering
       * @param  {number} _height height of the rendering
       * @param  {number} _gap    width of the gap between columns
       */
      calculate(_width, _height, _gap) {
        var divisor = 1;
        var gap = _gap || 0;
        var width = _width;
        var height = _height;
        var section = Math.floor(width / 12);
        var columnWidth;
        var spreadWidth;
        var pageWidth;
        var delta;
        if (this._spread && width >= this._minSpreadWidth) {
          divisor = 2;
        } else {
          divisor = 1;
        }
        if (this.name === "reflowable" && this._flow === "paginated" && !(_gap >= 0)) {
          gap = section % 2 === 0 ? section : section - 1;
        }
        if (this.name === "pre-paginated") {
          gap = 0;
        }
        if (divisor > 1) {
          columnWidth = width / divisor - gap;
          pageWidth = columnWidth + gap;
        } else {
          columnWidth = width;
          pageWidth = width;
        }
        if (this.name === "pre-paginated" && divisor > 1) {
          width = columnWidth;
        }
        spreadWidth = columnWidth * divisor + gap;
        delta = width;
        this.width = width;
        this.height = height;
        this.spreadWidth = spreadWidth;
        this.pageWidth = pageWidth;
        this.delta = delta;
        this.columnWidth = columnWidth;
        this.gap = gap;
        this.divisor = divisor;
        this.update({
          width,
          height,
          spreadWidth,
          pageWidth,
          delta,
          columnWidth,
          gap,
          divisor
        });
      }
      /**
       * Apply Css to a Document
       * @param  {Contents} contents
       * @return {Promise}
       */
      format(contents, section, axis) {
        var formating;
        if (this.name === "pre-paginated") {
          formating = contents.fit(this.columnWidth, this.height, section);
        } else if (this._flow === "paginated") {
          formating = contents.columns(this.width, this.height, this.columnWidth, this.gap, this.settings.direction);
        } else if (axis && axis === "horizontal") {
          formating = contents.size(null, this.height);
        } else {
          formating = contents.size(this.width, null);
        }
        return formating;
      }
      /**
       * Count number of pages
       * @param  {number} totalLength
       * @param  {number} pageLength
       * @return {{spreads: Number, pages: Number}}
       */
      count(totalLength, pageLength) {
        let spreads, pages;
        if (this.name === "pre-paginated") {
          spreads = 1;
          pages = 1;
        } else if (this._flow === "paginated") {
          pageLength = pageLength || this.delta;
          spreads = Math.ceil(totalLength / pageLength);
          pages = spreads * this.divisor;
        } else {
          pageLength = pageLength || this.height;
          spreads = Math.ceil(totalLength / pageLength);
          pages = spreads;
        }
        return {
          spreads,
          pages
        };
      }
      /**
       * Update props that have changed
       * @private
       * @param  {object} props
       */
      update(props) {
        Object.keys(props).forEach((propName) => {
          if (this.props[propName] === props[propName]) {
            delete props[propName];
          }
        });
        if (Object.keys(props).length > 0) {
          let newProps = (0, _core.extend)(this.props, props);
          this.emit(_constants.EVENTS.LAYOUT.UPDATED, newProps, props);
        }
      }
    };
    (0, _eventEmitter.default)(Layout.prototype);
    var _default = Layout;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/themes.js
var require_themes = __commonJS({
  "node_modules/epubjs/lib/themes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _url = _interopRequireDefault(require_url());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Themes = class {
      constructor(rendition) {
        this.rendition = rendition;
        this._themes = {
          "default": {
            "rules": {},
            "url": "",
            "serialized": ""
          }
        };
        this._overrides = {};
        this._current = "default";
        this._injected = [];
        this.rendition.hooks.content.register(this.inject.bind(this));
        this.rendition.hooks.content.register(this.overrides.bind(this));
      }
      /**
       * Add themes to be used by a rendition
       * @param {object | Array<object> | string}
       * @example themes.register("light", "http://example.com/light.css")
       * @example themes.register("light", { "body": { "color": "purple"}})
       * @example themes.register({ "light" : {...}, "dark" : {...}})
       */
      register() {
        if (arguments.length === 0) {
          return;
        }
        if (arguments.length === 1 && typeof arguments[0] === "object") {
          return this.registerThemes(arguments[0]);
        }
        if (arguments.length === 1 && typeof arguments[0] === "string") {
          return this.default(arguments[0]);
        }
        if (arguments.length === 2 && typeof arguments[1] === "string") {
          return this.registerUrl(arguments[0], arguments[1]);
        }
        if (arguments.length === 2 && typeof arguments[1] === "object") {
          return this.registerRules(arguments[0], arguments[1]);
        }
      }
      /**
       * Add a default theme to be used by a rendition
       * @param {object | string} theme
       * @example themes.register("http://example.com/default.css")
       * @example themes.register({ "body": { "color": "purple"}})
       */
      default(theme) {
        if (!theme) {
          return;
        }
        if (typeof theme === "string") {
          return this.registerUrl("default", theme);
        }
        if (typeof theme === "object") {
          return this.registerRules("default", theme);
        }
      }
      /**
       * Register themes object
       * @param {object} themes
       */
      registerThemes(themes) {
        for (var theme in themes) {
          if (themes.hasOwnProperty(theme)) {
            if (typeof themes[theme] === "string") {
              this.registerUrl(theme, themes[theme]);
            } else {
              this.registerRules(theme, themes[theme]);
            }
          }
        }
      }
      /**
       * Register a theme by passing its css as string
       * @param {string} name 
       * @param {string} css 
       */
      registerCss(name, css) {
        this._themes[name] = {
          "serialized": css
        };
        if (this._injected[name] || name == "default") {
          this.update(name);
        }
      }
      /**
       * Register a url
       * @param {string} name
       * @param {string} input
       */
      registerUrl(name, input) {
        var url = new _url.default(input);
        this._themes[name] = {
          "url": url.toString()
        };
        if (this._injected[name] || name == "default") {
          this.update(name);
        }
      }
      /**
       * Register rule
       * @param {string} name
       * @param {object} rules
       */
      registerRules(name, rules) {
        this._themes[name] = {
          "rules": rules
        };
        if (this._injected[name] || name == "default") {
          this.update(name);
        }
      }
      /**
       * Select a theme
       * @param {string} name
       */
      select(name) {
        var prev = this._current;
        var contents;
        this._current = name;
        this.update(name);
        contents = this.rendition.getContents();
        contents.forEach((content) => {
          content.removeClass(prev);
          content.addClass(name);
        });
      }
      /**
       * Update a theme
       * @param {string} name
       */
      update(name) {
        var contents = this.rendition.getContents();
        contents.forEach((content) => {
          this.add(name, content);
        });
      }
      /**
       * Inject all themes into contents
       * @param {Contents} contents
       */
      inject(contents) {
        var links = [];
        var themes = this._themes;
        var theme;
        for (var name in themes) {
          if (themes.hasOwnProperty(name) && (name === this._current || name === "default")) {
            theme = themes[name];
            if (theme.rules && Object.keys(theme.rules).length > 0 || theme.url && links.indexOf(theme.url) === -1) {
              this.add(name, contents);
            }
            this._injected.push(name);
          }
        }
        if (this._current != "default") {
          contents.addClass(this._current);
        }
      }
      /**
       * Add Theme to contents
       * @param {string} name
       * @param {Contents} contents
       */
      add(name, contents) {
        var theme = this._themes[name];
        if (!theme || !contents) {
          return;
        }
        if (theme.url) {
          contents.addStylesheet(theme.url);
        } else if (theme.serialized) {
          contents.addStylesheetCss(theme.serialized, name);
          theme.injected = true;
        } else if (theme.rules) {
          contents.addStylesheetRules(theme.rules, name);
          theme.injected = true;
        }
      }
      /**
       * Add override
       * @param {string} name
       * @param {string} value
       * @param {boolean} priority
       */
      override(name, value, priority) {
        var contents = this.rendition.getContents();
        this._overrides[name] = {
          value,
          priority: priority === true
        };
        contents.forEach((content) => {
          content.css(name, this._overrides[name].value, this._overrides[name].priority);
        });
      }
      removeOverride(name) {
        var contents = this.rendition.getContents();
        delete this._overrides[name];
        contents.forEach((content) => {
          content.css(name);
        });
      }
      /**
       * Add all overrides
       * @param {Content} content
       */
      overrides(contents) {
        var overrides = this._overrides;
        for (var rule in overrides) {
          if (overrides.hasOwnProperty(rule)) {
            contents.css(rule, overrides[rule].value, overrides[rule].priority);
          }
        }
      }
      /**
       * Adjust the font size of a rendition
       * @param {number} size
       */
      fontSize(size) {
        this.override("font-size", size);
      }
      /**
       * Adjust the font-family of a rendition
       * @param {string} f
       */
      font(f) {
        this.override("font-family", f, true);
      }
      destroy() {
        this.rendition = void 0;
        this._themes = void 0;
        this._overrides = void 0;
        this._current = void 0;
        this._injected = void 0;
      }
    };
    var _default = Themes;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/mapping.js
var require_mapping = __commonJS({
  "node_modules/epubjs/lib/mapping.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _core = require_core();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Mapping = class {
      constructor(layout, direction, axis, dev = false) {
        this.layout = layout;
        this.horizontal = axis === "horizontal" ? true : false;
        this.direction = direction || "ltr";
        this._dev = dev;
      }
      /**
       * Find CFI pairs for entire section at once
       */
      section(view) {
        var ranges = this.findRanges(view);
        var map = this.rangeListToCfiList(view.section.cfiBase, ranges);
        return map;
      }
      /**
       * Find CFI pairs for a page
       * @param {Contents} contents Contents from view
       * @param {string} cfiBase string of the base for a cfi
       * @param {number} start position to start at
       * @param {number} end position to end at
       */
      page(contents, cfiBase, start, end) {
        var root = contents && contents.document ? contents.document.body : false;
        var result;
        if (!root) {
          return;
        }
        result = this.rangePairToCfiPair(cfiBase, {
          start: this.findStart(root, start, end),
          end: this.findEnd(root, start, end)
        });
        if (this._dev === true) {
          let doc = contents.document;
          let startRange = new _epubcfi.default(result.start).toRange(doc);
          let endRange = new _epubcfi.default(result.end).toRange(doc);
          let selection = doc.defaultView.getSelection();
          let r = doc.createRange();
          selection.removeAllRanges();
          r.setStart(startRange.startContainer, startRange.startOffset);
          r.setEnd(endRange.endContainer, endRange.endOffset);
          selection.addRange(r);
        }
        return result;
      }
      /**
       * Walk a node, preforming a function on each node it finds
       * @private
       * @param {Node} root Node to walkToNode
       * @param {function} func walk function
       * @return {*} returns the result of the walk function
       */
      walk(root, func) {
        if (root && root.nodeType === Node.TEXT_NODE) {
          return;
        }
        var filter = {
          acceptNode: function(node2) {
            if (node2.data.trim().length > 0) {
              return NodeFilter.FILTER_ACCEPT;
            } else {
              return NodeFilter.FILTER_REJECT;
            }
          }
        };
        var safeFilter = filter.acceptNode;
        safeFilter.acceptNode = filter.acceptNode;
        var treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, safeFilter, false);
        var node;
        var result;
        while (node = treeWalker.nextNode()) {
          result = func(node);
          if (result) break;
        }
        return result;
      }
      findRanges(view) {
        var columns = [];
        var scrollWidth = view.contents.scrollWidth();
        var spreads = Math.ceil(scrollWidth / this.layout.spreadWidth);
        var count = spreads * this.layout.divisor;
        var columnWidth = this.layout.columnWidth;
        var gap = this.layout.gap;
        var start, end;
        for (var i = 0; i < count.pages; i++) {
          start = (columnWidth + gap) * i;
          end = columnWidth * (i + 1) + gap * i;
          columns.push({
            start: this.findStart(view.document.body, start, end),
            end: this.findEnd(view.document.body, start, end)
          });
        }
        return columns;
      }
      /**
       * Find Start Range
       * @private
       * @param {Node} root root node
       * @param {number} start position to start at
       * @param {number} end position to end at
       * @return {Range}
       */
      findStart(root, start, end) {
        var stack = [root];
        var $el;
        var found;
        var $prev = root;
        while (stack.length) {
          $el = stack.shift();
          found = this.walk($el, (node) => {
            var left, right, top, bottom;
            var elPos;
            var elRange;
            elPos = (0, _core.nodeBounds)(node);
            if (this.horizontal && this.direction === "ltr") {
              left = this.horizontal ? elPos.left : elPos.top;
              right = this.horizontal ? elPos.right : elPos.bottom;
              if (left >= start && left <= end) {
                return node;
              } else if (right > start) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            } else if (this.horizontal && this.direction === "rtl") {
              left = elPos.left;
              right = elPos.right;
              if (right <= end && right >= start) {
                return node;
              } else if (left < end) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            } else {
              top = elPos.top;
              bottom = elPos.bottom;
              if (top >= start && top <= end) {
                return node;
              } else if (bottom > start) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            }
          });
          if (found) {
            return this.findTextStartRange(found, start, end);
          }
        }
        return this.findTextStartRange($prev, start, end);
      }
      /**
       * Find End Range
       * @private
       * @param {Node} root root node
       * @param {number} start position to start at
       * @param {number} end position to end at
       * @return {Range}
       */
      findEnd(root, start, end) {
        var stack = [root];
        var $el;
        var $prev = root;
        var found;
        while (stack.length) {
          $el = stack.shift();
          found = this.walk($el, (node) => {
            var left, right, top, bottom;
            var elPos;
            var elRange;
            elPos = (0, _core.nodeBounds)(node);
            if (this.horizontal && this.direction === "ltr") {
              left = Math.round(elPos.left);
              right = Math.round(elPos.right);
              if (left > end && $prev) {
                return $prev;
              } else if (right > end) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            } else if (this.horizontal && this.direction === "rtl") {
              left = Math.round(this.horizontal ? elPos.left : elPos.top);
              right = Math.round(this.horizontal ? elPos.right : elPos.bottom);
              if (right < start && $prev) {
                return $prev;
              } else if (left < start) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            } else {
              top = Math.round(elPos.top);
              bottom = Math.round(elPos.bottom);
              if (top > end && $prev) {
                return $prev;
              } else if (bottom > end) {
                return node;
              } else {
                $prev = node;
                stack.push(node);
              }
            }
          });
          if (found) {
            return this.findTextEndRange(found, start, end);
          }
        }
        return this.findTextEndRange($prev, start, end);
      }
      /**
       * Find Text Start Range
       * @private
       * @param {Node} root root node
       * @param {number} start position to start at
       * @param {number} end position to end at
       * @return {Range}
       */
      findTextStartRange(node, start, end) {
        var ranges = this.splitTextNodeIntoRanges(node);
        var range;
        var pos;
        var left, top, right;
        for (var i = 0; i < ranges.length; i++) {
          range = ranges[i];
          pos = range.getBoundingClientRect();
          if (this.horizontal && this.direction === "ltr") {
            left = pos.left;
            if (left >= start) {
              return range;
            }
          } else if (this.horizontal && this.direction === "rtl") {
            right = pos.right;
            if (right <= end) {
              return range;
            }
          } else {
            top = pos.top;
            if (top >= start) {
              return range;
            }
          }
        }
        return ranges[0];
      }
      /**
       * Find Text End Range
       * @private
       * @param {Node} root root node
       * @param {number} start position to start at
       * @param {number} end position to end at
       * @return {Range}
       */
      findTextEndRange(node, start, end) {
        var ranges = this.splitTextNodeIntoRanges(node);
        var prev;
        var range;
        var pos;
        var left, right, top, bottom;
        for (var i = 0; i < ranges.length; i++) {
          range = ranges[i];
          pos = range.getBoundingClientRect();
          if (this.horizontal && this.direction === "ltr") {
            left = pos.left;
            right = pos.right;
            if (left > end && prev) {
              return prev;
            } else if (right > end) {
              return range;
            }
          } else if (this.horizontal && this.direction === "rtl") {
            left = pos.left;
            right = pos.right;
            if (right < start && prev) {
              return prev;
            } else if (left < start) {
              return range;
            }
          } else {
            top = pos.top;
            bottom = pos.bottom;
            if (top > end && prev) {
              return prev;
            } else if (bottom > end) {
              return range;
            }
          }
          prev = range;
        }
        return ranges[ranges.length - 1];
      }
      /**
       * Split up a text node into ranges for each word
       * @private
       * @param {Node} root root node
       * @param {string} [_splitter] what to split on
       * @return {Range[]}
       */
      splitTextNodeIntoRanges(node, _splitter) {
        var ranges = [];
        var textContent = node.textContent || "";
        var text = textContent.trim();
        var range;
        var doc = node.ownerDocument;
        var splitter = _splitter || " ";
        var pos = text.indexOf(splitter);
        if (pos === -1 || node.nodeType != Node.TEXT_NODE) {
          range = doc.createRange();
          range.selectNodeContents(node);
          return [range];
        }
        range = doc.createRange();
        range.setStart(node, 0);
        range.setEnd(node, pos);
        ranges.push(range);
        range = false;
        while (pos != -1) {
          pos = text.indexOf(splitter, pos + 1);
          if (pos > 0) {
            if (range) {
              range.setEnd(node, pos);
              ranges.push(range);
            }
            range = doc.createRange();
            range.setStart(node, pos + 1);
          }
        }
        if (range) {
          range.setEnd(node, text.length);
          ranges.push(range);
        }
        return ranges;
      }
      /**
       * Turn a pair of ranges into a pair of CFIs
       * @private
       * @param {string} cfiBase base string for an EpubCFI
       * @param {object} rangePair { start: Range, end: Range }
       * @return {object} { start: "epubcfi(...)", end: "epubcfi(...)" }
       */
      rangePairToCfiPair(cfiBase, rangePair) {
        var startRange = rangePair.start;
        var endRange = rangePair.end;
        startRange.collapse(true);
        endRange.collapse(false);
        let startCfi = new _epubcfi.default(startRange, cfiBase).toString();
        let endCfi = new _epubcfi.default(endRange, cfiBase).toString();
        return {
          start: startCfi,
          end: endCfi
        };
      }
      rangeListToCfiList(cfiBase, columns) {
        var map = [];
        var cifPair;
        for (var i = 0; i < columns.length; i++) {
          cifPair = this.rangePairToCfiPair(cfiBase, columns[i]);
          map.push(cifPair);
        }
        return map;
      }
      /**
       * Set the axis for mapping
       * @param {string} axis horizontal | vertical
       * @return {boolean} is it horizontal?
       */
      axis(axis) {
        if (axis) {
          this.horizontal = axis === "horizontal" ? true : false;
        }
        return this.horizontal;
      }
    };
    var _default = Mapping;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/contents.js
var require_contents = __commonJS({
  "node_modules/epubjs/lib/contents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _mapping = _interopRequireDefault(require_mapping());
    var _replacements = require_replacements();
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasNavigator = typeof navigator !== "undefined";
    var isChrome = hasNavigator && /Chrome/.test(navigator.userAgent);
    var isWebkit = hasNavigator && !isChrome && /AppleWebKit/.test(navigator.userAgent);
    var ELEMENT_NODE = 1;
    var Contents = class {
      constructor(doc, content, cfiBase, sectionIndex) {
        this.epubcfi = new _epubcfi.default();
        this.document = doc;
        this.documentElement = this.document.documentElement;
        this.content = content || this.document.body;
        this.window = this.document.defaultView;
        this._size = {
          width: 0,
          height: 0
        };
        this.sectionIndex = sectionIndex || 0;
        this.cfiBase = cfiBase || "";
        this.epubReadingSystem("epub.js", _constants.EPUBJS_VERSION);
        this.called = 0;
        this.active = true;
        this.listeners();
      }
      /**
      	* Get DOM events that are listened for and passed along
      	*/
      static get listenedEvents() {
        return _constants.DOM_EVENTS;
      }
      /**
      	* Get or Set width
      	* @param {number} [w]
      	* @returns {number} width
      	*/
      width(w) {
        var frame = this.content;
        if (w && (0, _core.isNumber)(w)) {
          w = w + "px";
        }
        if (w) {
          frame.style.width = w;
        }
        return parseInt(this.window.getComputedStyle(frame)["width"]);
      }
      /**
      	* Get or Set height
      	* @param {number} [h]
      	* @returns {number} height
      	*/
      height(h) {
        var frame = this.content;
        if (h && (0, _core.isNumber)(h)) {
          h = h + "px";
        }
        if (h) {
          frame.style.height = h;
        }
        return parseInt(this.window.getComputedStyle(frame)["height"]);
      }
      /**
      	* Get or Set width of the contents
      	* @param {number} [w]
      	* @returns {number} width
      	*/
      contentWidth(w) {
        var content = this.content || this.document.body;
        if (w && (0, _core.isNumber)(w)) {
          w = w + "px";
        }
        if (w) {
          content.style.width = w;
        }
        return parseInt(this.window.getComputedStyle(content)["width"]);
      }
      /**
      	* Get or Set height of the contents
      	* @param {number} [h]
      	* @returns {number} height
      	*/
      contentHeight(h) {
        var content = this.content || this.document.body;
        if (h && (0, _core.isNumber)(h)) {
          h = h + "px";
        }
        if (h) {
          content.style.height = h;
        }
        return parseInt(this.window.getComputedStyle(content)["height"]);
      }
      /**
      	* Get the width of the text using Range
      	* @returns {number} width
      	*/
      textWidth() {
        let rect;
        let width;
        let range = this.document.createRange();
        let content = this.content || this.document.body;
        let border = (0, _core.borders)(content);
        range.selectNodeContents(content);
        rect = range.getBoundingClientRect();
        width = rect.width;
        if (border && border.width) {
          width += border.width;
        }
        return Math.round(width);
      }
      /**
      	* Get the height of the text using Range
      	* @returns {number} height
      	*/
      textHeight() {
        let rect;
        let height;
        let range = this.document.createRange();
        let content = this.content || this.document.body;
        range.selectNodeContents(content);
        rect = range.getBoundingClientRect();
        height = rect.bottom;
        return Math.round(height);
      }
      /**
      	* Get documentElement scrollWidth
      	* @returns {number} width
      	*/
      scrollWidth() {
        var width = this.documentElement.scrollWidth;
        return width;
      }
      /**
      	* Get documentElement scrollHeight
      	* @returns {number} height
      	*/
      scrollHeight() {
        var height = this.documentElement.scrollHeight;
        return height;
      }
      /**
      	* Set overflow css style of the contents
      	* @param {string} [overflow]
      	*/
      overflow(overflow) {
        if (overflow) {
          this.documentElement.style.overflow = overflow;
        }
        return this.window.getComputedStyle(this.documentElement)["overflow"];
      }
      /**
      	* Set overflowX css style of the documentElement
      	* @param {string} [overflow]
      	*/
      overflowX(overflow) {
        if (overflow) {
          this.documentElement.style.overflowX = overflow;
        }
        return this.window.getComputedStyle(this.documentElement)["overflowX"];
      }
      /**
      	* Set overflowY css style of the documentElement
      	* @param {string} [overflow]
      	*/
      overflowY(overflow) {
        if (overflow) {
          this.documentElement.style.overflowY = overflow;
        }
        return this.window.getComputedStyle(this.documentElement)["overflowY"];
      }
      /**
      	* Set Css styles on the contents element (typically Body)
      	* @param {string} property
      	* @param {string} value
      	* @param {boolean} [priority] set as "important"
      	*/
      css(property, value, priority) {
        var content = this.content || this.document.body;
        if (value) {
          content.style.setProperty(property, value, priority ? "important" : "");
        } else {
          content.style.removeProperty(property);
        }
        return this.window.getComputedStyle(content)[property];
      }
      /**
      	* Get or Set the viewport element
      	* @param {object} [options]
      	* @param {string} [options.width]
      	* @param {string} [options.height]
      	* @param {string} [options.scale]
      	* @param {string} [options.minimum]
      	* @param {string} [options.maximum]
      	* @param {string} [options.scalable]
      	*/
      viewport(options) {
        var _width, _height, _scale, _minimum, _maximum, _scalable;
        var $viewport = this.document.querySelector("meta[name='viewport']");
        var parsed = {
          "width": void 0,
          "height": void 0,
          "scale": void 0,
          "minimum": void 0,
          "maximum": void 0,
          "scalable": void 0
        };
        var newContent = [];
        var settings = {};
        if ($viewport && $viewport.hasAttribute("content")) {
          let content = $viewport.getAttribute("content");
          let _width2 = content.match(/width\s*=\s*([^,]*)/);
          let _height2 = content.match(/height\s*=\s*([^,]*)/);
          let _scale2 = content.match(/initial-scale\s*=\s*([^,]*)/);
          let _minimum2 = content.match(/minimum-scale\s*=\s*([^,]*)/);
          let _maximum2 = content.match(/maximum-scale\s*=\s*([^,]*)/);
          let _scalable2 = content.match(/user-scalable\s*=\s*([^,]*)/);
          if (_width2 && _width2.length && typeof _width2[1] !== "undefined") {
            parsed.width = _width2[1];
          }
          if (_height2 && _height2.length && typeof _height2[1] !== "undefined") {
            parsed.height = _height2[1];
          }
          if (_scale2 && _scale2.length && typeof _scale2[1] !== "undefined") {
            parsed.scale = _scale2[1];
          }
          if (_minimum2 && _minimum2.length && typeof _minimum2[1] !== "undefined") {
            parsed.minimum = _minimum2[1];
          }
          if (_maximum2 && _maximum2.length && typeof _maximum2[1] !== "undefined") {
            parsed.maximum = _maximum2[1];
          }
          if (_scalable2 && _scalable2.length && typeof _scalable2[1] !== "undefined") {
            parsed.scalable = _scalable2[1];
          }
        }
        settings = (0, _core.defaults)(options || {}, parsed);
        if (options) {
          if (settings.width) {
            newContent.push("width=" + settings.width);
          }
          if (settings.height) {
            newContent.push("height=" + settings.height);
          }
          if (settings.scale) {
            newContent.push("initial-scale=" + settings.scale);
          }
          if (settings.scalable === "no") {
            newContent.push("minimum-scale=" + settings.scale);
            newContent.push("maximum-scale=" + settings.scale);
            newContent.push("user-scalable=" + settings.scalable);
          } else {
            if (settings.scalable) {
              newContent.push("user-scalable=" + settings.scalable);
            }
            if (settings.minimum) {
              newContent.push("minimum-scale=" + settings.minimum);
            }
            if (settings.maximum) {
              newContent.push("minimum-scale=" + settings.maximum);
            }
          }
          if (!$viewport) {
            $viewport = this.document.createElement("meta");
            $viewport.setAttribute("name", "viewport");
            this.document.querySelector("head").appendChild($viewport);
          }
          $viewport.setAttribute("content", newContent.join(", "));
          this.window.scrollTo(0, 0);
        }
        return settings;
      }
      /**
       * Event emitter for when the contents has expanded
       * @private
       */
      expand() {
        this.emit(_constants.EVENTS.CONTENTS.EXPAND);
      }
      /**
       * Add DOM listeners
       * @private
       */
      listeners() {
        this.imageLoadListeners();
        this.mediaQueryListeners();
        this.addEventListeners();
        this.addSelectionListeners();
        if (typeof ResizeObserver === "undefined") {
          this.resizeListeners();
          this.visibilityListeners();
        } else {
          this.resizeObservers();
        }
        this.linksHandler();
      }
      /**
       * Remove DOM listeners
       * @private
       */
      removeListeners() {
        this.removeEventListeners();
        this.removeSelectionListeners();
        if (this.observer) {
          this.observer.disconnect();
        }
        clearTimeout(this.expanding);
      }
      /**
       * Check if size of contents has changed and
       * emit 'resize' event if it has.
       * @private
       */
      resizeCheck() {
        let width = this.textWidth();
        let height = this.textHeight();
        if (width != this._size.width || height != this._size.height) {
          this._size = {
            width,
            height
          };
          this.onResize && this.onResize(this._size);
          this.emit(_constants.EVENTS.CONTENTS.RESIZE, this._size);
        }
      }
      /**
       * Poll for resize detection
       * @private
       */
      resizeListeners() {
        var width, height;
        clearTimeout(this.expanding);
        requestAnimationFrame(this.resizeCheck.bind(this));
        this.expanding = setTimeout(this.resizeListeners.bind(this), 350);
      }
      /**
       * Listen for visibility of tab to change
       * @private
       */
      visibilityListeners() {
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "visible" && this.active === false) {
            this.active = true;
            this.resizeListeners();
          } else {
            this.active = false;
            clearTimeout(this.expanding);
          }
        });
      }
      /**
       * Use css transitions to detect resize
       * @private
       */
      transitionListeners() {
        let body = this.content;
        body.style["transitionProperty"] = "font, font-size, font-size-adjust, font-stretch, font-variation-settings, font-weight, width, height";
        body.style["transitionDuration"] = "0.001ms";
        body.style["transitionTimingFunction"] = "linear";
        body.style["transitionDelay"] = "0";
        this._resizeCheck = this.resizeCheck.bind(this);
        this.document.addEventListener("transitionend", this._resizeCheck);
      }
      /**
       * Listen for media query changes and emit 'expand' event
       * Adapted from: https://github.com/tylergaw/media-query-events/blob/master/js/mq-events.js
       * @private
       */
      mediaQueryListeners() {
        var sheets = this.document.styleSheets;
        var mediaChangeHandler = (function(m) {
          if (m.matches && !this._expanding) {
            setTimeout(this.expand.bind(this), 1);
          }
        }).bind(this);
        for (var i = 0; i < sheets.length; i += 1) {
          var rules;
          try {
            rules = sheets[i].cssRules;
          } catch (e) {
            return;
          }
          if (!rules) return;
          for (var j = 0; j < rules.length; j += 1) {
            if (rules[j].media) {
              var mql = this.window.matchMedia(rules[j].media.mediaText);
              mql.addListener(mediaChangeHandler);
            }
          }
        }
      }
      /**
       * Use ResizeObserver to listen for changes in the DOM and check for resize
       * @private
       */
      resizeObservers() {
        this.observer = new ResizeObserver((e) => {
          requestAnimationFrame(this.resizeCheck.bind(this));
        });
        this.observer.observe(this.document.documentElement);
      }
      /**
       * Use MutationObserver to listen for changes in the DOM and check for resize
       * @private
       */
      mutationObservers() {
        this.observer = new MutationObserver((mutations) => {
          this.resizeCheck();
        });
        let config = {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        };
        this.observer.observe(this.document, config);
      }
      /**
       * Test if images are loaded or add listener for when they load
       * @private
       */
      imageLoadListeners() {
        var images = this.document.querySelectorAll("img");
        var img;
        for (var i = 0; i < images.length; i++) {
          img = images[i];
          if (typeof img.naturalWidth !== "undefined" && img.naturalWidth === 0) {
            img.onload = this.expand.bind(this);
          }
        }
      }
      /**
       * Listen for font load and check for resize when loaded
       * @private
       */
      fontLoadListeners() {
        if (!this.document || !this.document.fonts) {
          return;
        }
        this.document.fonts.ready.then((function() {
          this.resizeCheck();
        }).bind(this));
      }
      /**
       * Get the documentElement
       * @returns {element} documentElement
       */
      root() {
        if (!this.document) return null;
        return this.document.documentElement;
      }
      /**
       * Get the location offset of a EpubCFI or an #id
       * @param {string | EpubCFI} target
       * @param {string} [ignoreClass] for the cfi
       * @returns { {left: Number, top: Number }
       */
      locationOf(target, ignoreClass) {
        var position;
        var targetPos = {
          "left": 0,
          "top": 0
        };
        if (!this.document) return targetPos;
        if (this.epubcfi.isCfiString(target)) {
          let range = new _epubcfi.default(target).toRange(this.document, ignoreClass);
          if (range) {
            try {
              if (!range.endContainer || range.startContainer == range.endContainer && range.startOffset == range.endOffset) {
                let pos = range.startContainer.textContent.indexOf(" ", range.startOffset);
                if (pos == -1) {
                  pos = range.startContainer.textContent.length;
                }
                range.setEnd(range.startContainer, pos);
              }
            } catch (e) {
              console.error("setting end offset to start container length failed", e);
            }
            if (range.startContainer.nodeType === Node.ELEMENT_NODE) {
              position = range.startContainer.getBoundingClientRect();
              targetPos.left = position.left;
              targetPos.top = position.top;
            } else {
              if (isWebkit) {
                let container = range.startContainer;
                let newRange = new Range();
                try {
                  if (container.nodeType === ELEMENT_NODE) {
                    position = container.getBoundingClientRect();
                  } else if (range.startOffset + 2 < container.length) {
                    newRange.setStart(container, range.startOffset);
                    newRange.setEnd(container, range.startOffset + 2);
                    position = newRange.getBoundingClientRect();
                  } else if (range.startOffset - 2 > 0) {
                    newRange.setStart(container, range.startOffset - 2);
                    newRange.setEnd(container, range.startOffset);
                    position = newRange.getBoundingClientRect();
                  } else {
                    position = container.parentNode.getBoundingClientRect();
                  }
                } catch (e) {
                  console.error(e, e.stack);
                }
              } else {
                position = range.getBoundingClientRect();
              }
            }
          }
        } else if (typeof target === "string" && target.indexOf("#") > -1) {
          let id = target.substring(target.indexOf("#") + 1);
          let el = this.document.getElementById(id);
          if (el) {
            if (isWebkit) {
              let newRange = new Range();
              newRange.selectNode(el);
              position = newRange.getBoundingClientRect();
            } else {
              position = el.getBoundingClientRect();
            }
          }
        }
        if (position) {
          targetPos.left = position.left;
          targetPos.top = position.top;
        }
        return targetPos;
      }
      /**
       * Append a stylesheet link to the document head
       * @param {string} src url
       */
      addStylesheet(src) {
        return new Promise((function(resolve, reject) {
          var $stylesheet;
          var ready = false;
          if (!this.document) {
            resolve(false);
            return;
          }
          $stylesheet = this.document.querySelector("link[href='" + src + "']");
          if ($stylesheet) {
            resolve(true);
            return;
          }
          $stylesheet = this.document.createElement("link");
          $stylesheet.type = "text/css";
          $stylesheet.rel = "stylesheet";
          $stylesheet.href = src;
          $stylesheet.onload = $stylesheet.onreadystatechange = function() {
            if (!ready && (!this.readyState || this.readyState == "complete")) {
              ready = true;
              setTimeout(() => {
                resolve(true);
              }, 1);
            }
          };
          this.document.head.appendChild($stylesheet);
        }).bind(this));
      }
      _getStylesheetNode(key) {
        var styleEl;
        key = "epubjs-inserted-css-" + (key || "");
        if (!this.document) return false;
        styleEl = this.document.getElementById(key);
        if (!styleEl) {
          styleEl = this.document.createElement("style");
          styleEl.id = key;
          this.document.head.appendChild(styleEl);
        }
        return styleEl;
      }
      /**
       * Append stylesheet css
       * @param {string} serializedCss
       * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
       */
      addStylesheetCss(serializedCss, key) {
        if (!this.document || !serializedCss) return false;
        var styleEl;
        styleEl = this._getStylesheetNode(key);
        styleEl.innerHTML = serializedCss;
        return true;
      }
      /**
       * Append stylesheet rules to a generate stylesheet
       * Array: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/insertRule
       * Object: https://github.com/desirable-objects/json-to-css
       * @param {array | object} rules
       * @param {string} key If the key is the same, the CSS will be replaced instead of inserted
       */
      addStylesheetRules(rules, key) {
        var styleSheet;
        if (!this.document || !rules || rules.length === 0) return;
        styleSheet = this._getStylesheetNode(key).sheet;
        if (Object.prototype.toString.call(rules) === "[object Array]") {
          for (var i = 0, rl = rules.length; i < rl; i++) {
            var j = 1, rule = rules[i], selector = rules[i][0], propStr = "";
            if (Object.prototype.toString.call(rule[1][0]) === "[object Array]") {
              rule = rule[1];
              j = 0;
            }
            for (var pl = rule.length; j < pl; j++) {
              var prop = rule[j];
              propStr += prop[0] + ":" + prop[1] + (prop[2] ? " !important" : "") + ";\n";
            }
            styleSheet.insertRule(selector + "{" + propStr + "}", styleSheet.cssRules.length);
          }
        } else {
          const selectors = Object.keys(rules);
          selectors.forEach((selector2) => {
            const definition = rules[selector2];
            if (Array.isArray(definition)) {
              definition.forEach((item) => {
                const _rules = Object.keys(item);
                const result = _rules.map((rule2) => {
                  return `${rule2}:${item[rule2]}`;
                }).join(";");
                styleSheet.insertRule(`${selector2}{${result}}`, styleSheet.cssRules.length);
              });
            } else {
              const _rules = Object.keys(definition);
              const result = _rules.map((rule2) => {
                return `${rule2}:${definition[rule2]}`;
              }).join(";");
              styleSheet.insertRule(`${selector2}{${result}}`, styleSheet.cssRules.length);
            }
          });
        }
      }
      /**
       * Append a script tag to the document head
       * @param {string} src url
       * @returns {Promise} loaded
       */
      addScript(src) {
        return new Promise((function(resolve, reject) {
          var $script;
          var ready = false;
          if (!this.document) {
            resolve(false);
            return;
          }
          $script = this.document.createElement("script");
          $script.type = "text/javascript";
          $script.async = true;
          $script.src = src;
          $script.onload = $script.onreadystatechange = function() {
            if (!ready && (!this.readyState || this.readyState == "complete")) {
              ready = true;
              setTimeout(function() {
                resolve(true);
              }, 1);
            }
          };
          this.document.head.appendChild($script);
        }).bind(this));
      }
      /**
       * Add a class to the contents container
       * @param {string} className
       */
      addClass(className) {
        var content;
        if (!this.document) return;
        content = this.content || this.document.body;
        if (content) {
          content.classList.add(className);
        }
      }
      /**
       * Remove a class from the contents container
       * @param {string} removeClass
       */
      removeClass(className) {
        var content;
        if (!this.document) return;
        content = this.content || this.document.body;
        if (content) {
          content.classList.remove(className);
        }
      }
      /**
       * Add DOM event listeners
       * @private
       */
      addEventListeners() {
        if (!this.document) {
          return;
        }
        this._triggerEvent = this.triggerEvent.bind(this);
        _constants.DOM_EVENTS.forEach(function(eventName) {
          this.document.addEventListener(eventName, this._triggerEvent, {
            passive: true
          });
        }, this);
      }
      /**
       * Remove DOM event listeners
       * @private
       */
      removeEventListeners() {
        if (!this.document) {
          return;
        }
        _constants.DOM_EVENTS.forEach(function(eventName) {
          this.document.removeEventListener(eventName, this._triggerEvent, {
            passive: true
          });
        }, this);
        this._triggerEvent = void 0;
      }
      /**
       * Emit passed browser events
       * @private
       */
      triggerEvent(e) {
        this.emit(e.type, e);
      }
      /**
       * Add listener for text selection
       * @private
       */
      addSelectionListeners() {
        if (!this.document) {
          return;
        }
        this._onSelectionChange = this.onSelectionChange.bind(this);
        this.document.addEventListener("selectionchange", this._onSelectionChange, {
          passive: true
        });
      }
      /**
       * Remove listener for text selection
       * @private
       */
      removeSelectionListeners() {
        if (!this.document) {
          return;
        }
        this.document.removeEventListener("selectionchange", this._onSelectionChange, {
          passive: true
        });
        this._onSelectionChange = void 0;
      }
      /**
       * Handle getting text on selection
       * @private
       */
      onSelectionChange(e) {
        if (this.selectionEndTimeout) {
          clearTimeout(this.selectionEndTimeout);
        }
        this.selectionEndTimeout = setTimeout((function() {
          var selection = this.window.getSelection();
          this.triggerSelectedEvent(selection);
        }).bind(this), 250);
      }
      /**
       * Emit event on text selection
       * @private
       */
      triggerSelectedEvent(selection) {
        var range, cfirange;
        if (selection && selection.rangeCount > 0) {
          range = selection.getRangeAt(0);
          if (!range.collapsed) {
            cfirange = new _epubcfi.default(range, this.cfiBase).toString();
            this.emit(_constants.EVENTS.CONTENTS.SELECTED, cfirange);
            this.emit(_constants.EVENTS.CONTENTS.SELECTED_RANGE, range);
          }
        }
      }
      /**
       * Get a Dom Range from EpubCFI
       * @param {EpubCFI} _cfi
       * @param {string} [ignoreClass]
       * @returns {Range} range
       */
      range(_cfi, ignoreClass) {
        var cfi = new _epubcfi.default(_cfi);
        return cfi.toRange(this.document, ignoreClass);
      }
      /**
       * Get an EpubCFI from a Dom Range
       * @param {Range} range
       * @param {string} [ignoreClass]
       * @returns {EpubCFI} cfi
       */
      cfiFromRange(range, ignoreClass) {
        return new _epubcfi.default(range, this.cfiBase, ignoreClass).toString();
      }
      /**
       * Get an EpubCFI from a Dom node
       * @param {node} node
       * @param {string} [ignoreClass]
       * @returns {EpubCFI} cfi
       */
      cfiFromNode(node, ignoreClass) {
        return new _epubcfi.default(node, this.cfiBase, ignoreClass).toString();
      }
      // TODO: find where this is used - remove?
      map(layout) {
        var map = new _mapping.default(layout);
        return map.section();
      }
      /**
       * Size the contents to a given width and height
       * @param {number} [width]
       * @param {number} [height]
       */
      size(width, height) {
        var viewport = {
          scale: 1,
          scalable: "no"
        };
        this.layoutStyle("scrolling");
        if (width >= 0) {
          this.width(width);
          viewport.width = width;
          this.css("padding", "0 " + width / 12 + "px");
        }
        if (height >= 0) {
          this.height(height);
          viewport.height = height;
        }
        this.css("margin", "0");
        this.css("box-sizing", "border-box");
        this.viewport(viewport);
      }
      /**
       * Apply columns to the contents for pagination
       * @param {number} width
       * @param {number} height
       * @param {number} columnWidth
       * @param {number} gap
       */
      columns(width, height, columnWidth, gap, dir) {
        let COLUMN_AXIS = (0, _core.prefixed)("column-axis");
        let COLUMN_GAP = (0, _core.prefixed)("column-gap");
        let COLUMN_WIDTH = (0, _core.prefixed)("column-width");
        let COLUMN_FILL = (0, _core.prefixed)("column-fill");
        let writingMode = this.writingMode();
        let axis = writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
        this.layoutStyle("paginated");
        if (dir === "rtl" && axis === "horizontal") {
          this.direction(dir);
        }
        this.width(width);
        this.height(height);
        this.viewport({
          width,
          height,
          scale: 1,
          scalable: "no"
        });
        this.css("overflow-y", "hidden");
        this.css("margin", "0", true);
        if (axis === "vertical") {
          this.css("padding-top", gap / 2 + "px", true);
          this.css("padding-bottom", gap / 2 + "px", true);
          this.css("padding-left", "20px");
          this.css("padding-right", "20px");
          this.css(COLUMN_AXIS, "vertical");
        } else {
          this.css("padding-top", "20px");
          this.css("padding-bottom", "20px");
          this.css("padding-left", gap / 2 + "px", true);
          this.css("padding-right", gap / 2 + "px", true);
          this.css(COLUMN_AXIS, "horizontal");
        }
        this.css("box-sizing", "border-box");
        this.css("max-width", "inherit");
        this.css(COLUMN_FILL, "auto");
        this.css(COLUMN_GAP, gap + "px");
        this.css(COLUMN_WIDTH, columnWidth + "px");
        this.css("-webkit-line-box-contain", "block glyphs replaced");
      }
      /**
       * Scale contents from center
       * @param {number} scale
       * @param {number} offsetX
       * @param {number} offsetY
       */
      scaler(scale, offsetX, offsetY) {
        var scaleStr = "scale(" + scale + ")";
        var translateStr = "";
        this.css("transform-origin", "top left");
        if (offsetX >= 0 || offsetY >= 0) {
          translateStr = " translate(" + (offsetX || 0) + "px, " + (offsetY || 0) + "px )";
        }
        this.css("transform", scaleStr + translateStr);
      }
      /**
       * Fit contents into a fixed width and height
       * @param {number} width
       * @param {number} height
       */
      fit(width, height, section) {
        var viewport = this.viewport();
        var viewportWidth = parseInt(viewport.width);
        var viewportHeight = parseInt(viewport.height);
        var widthScale = width / viewportWidth;
        var heightScale = height / viewportHeight;
        var scale = widthScale < heightScale ? widthScale : heightScale;
        this.layoutStyle("paginated");
        this.width(viewportWidth);
        this.height(viewportHeight);
        this.overflow("hidden");
        this.scaler(scale, 0, 0);
        this.css("background-size", viewportWidth * scale + "px " + viewportHeight * scale + "px");
        this.css("background-color", "transparent");
        if (section && section.properties.includes("page-spread-left")) {
          var marginLeft = width - viewportWidth * scale;
          this.css("margin-left", marginLeft + "px");
        }
      }
      /**
       * Set the direction of the text
       * @param {string} [dir="ltr"] "rtl" | "ltr"
       */
      direction(dir) {
        if (this.documentElement) {
          this.documentElement.style["direction"] = dir;
        }
      }
      mapPage(cfiBase, layout, start, end, dev) {
        var mapping = new _mapping.default(layout, dev);
        return mapping.page(this, cfiBase, start, end);
      }
      /**
       * Emit event when link in content is clicked
       * @private
       */
      linksHandler() {
        (0, _replacements.replaceLinks)(this.content, (href) => {
          this.emit(_constants.EVENTS.CONTENTS.LINK_CLICKED, href);
        });
      }
      /**
       * Set the writingMode of the text
       * @param {string} [mode="horizontal-tb"] "horizontal-tb" | "vertical-rl" | "vertical-lr"
       */
      writingMode(mode) {
        let WRITING_MODE = (0, _core.prefixed)("writing-mode");
        if (mode && this.documentElement) {
          this.documentElement.style[WRITING_MODE] = mode;
        }
        return this.window.getComputedStyle(this.documentElement)[WRITING_MODE] || "";
      }
      /**
       * Set the layoutStyle of the content
       * @param {string} [style="paginated"] "scrolling" | "paginated"
       * @private
       */
      layoutStyle(style) {
        if (style) {
          this._layoutStyle = style;
          navigator.epubReadingSystem.layoutStyle = this._layoutStyle;
        }
        return this._layoutStyle || "paginated";
      }
      /**
       * Add the epubReadingSystem object to the navigator
       * @param {string} name
       * @param {string} version
       * @private
       */
      epubReadingSystem(name, version) {
        navigator.epubReadingSystem = {
          name,
          version,
          layoutStyle: this.layoutStyle(),
          hasFeature: function(feature) {
            switch (feature) {
              case "dom-manipulation":
                return true;
              case "layout-changes":
                return true;
              case "touch-events":
                return true;
              case "mouse-events":
                return true;
              case "keyboard-events":
                return true;
              case "spine-scripting":
                return false;
              default:
                return false;
            }
          }
        };
        return navigator.epubReadingSystem;
      }
      destroy() {
        this.removeListeners();
      }
    };
    (0, _eventEmitter.default)(Contents.prototype);
    var _default = Contents;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/annotations.js
var require_annotations = __commonJS({
  "node_modules/epubjs/lib/annotations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Annotations = class {
      constructor(rendition) {
        this.rendition = rendition;
        this.highlights = [];
        this.underlines = [];
        this.marks = [];
        this._annotations = {};
        this._annotationsBySectionIndex = {};
        this.rendition.hooks.render.register(this.inject.bind(this));
        this.rendition.hooks.unloaded.register(this.clear.bind(this));
      }
      /**
       * Add an annotation to store
       * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
       * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
       * @param {object} data Data to assign to annotation
       * @param {function} [cb] Callback after annotation is added
       * @param {string} className CSS class to assign to annotation
       * @param {object} styles CSS styles to assign to annotation
       * @returns {Annotation} annotation
       */
      add(type, cfiRange, data, cb, className, styles) {
        let hash = encodeURI(cfiRange + type);
        let cfi = new _epubcfi.default(cfiRange);
        let sectionIndex = cfi.spinePos;
        let annotation = new Annotation({
          type,
          cfiRange,
          data,
          sectionIndex,
          cb,
          className,
          styles
        });
        this._annotations[hash] = annotation;
        if (sectionIndex in this._annotationsBySectionIndex) {
          this._annotationsBySectionIndex[sectionIndex].push(hash);
        } else {
          this._annotationsBySectionIndex[sectionIndex] = [hash];
        }
        let views = this.rendition.views();
        views.forEach((view) => {
          if (annotation.sectionIndex === view.index) {
            annotation.attach(view);
          }
        });
        return annotation;
      }
      /**
       * Remove an annotation from store
       * @param {EpubCFI} cfiRange EpubCFI range the annotation is attached to
       * @param {string} type Type of annotation to add: "highlight", "underline", "mark"
       */
      remove(cfiRange, type) {
        let hash = encodeURI(cfiRange + type);
        if (hash in this._annotations) {
          let annotation = this._annotations[hash];
          if (type && annotation.type !== type) {
            return;
          }
          let views = this.rendition.views();
          views.forEach((view) => {
            this._removeFromAnnotationBySectionIndex(annotation.sectionIndex, hash);
            if (annotation.sectionIndex === view.index) {
              annotation.detach(view);
            }
          });
          delete this._annotations[hash];
        }
      }
      /**
       * Remove an annotations by Section Index
       * @private
       */
      _removeFromAnnotationBySectionIndex(sectionIndex, hash) {
        this._annotationsBySectionIndex[sectionIndex] = this._annotationsAt(sectionIndex).filter((h) => h !== hash);
      }
      /**
       * Get annotations by Section Index
       * @private
       */
      _annotationsAt(index) {
        return this._annotationsBySectionIndex[index];
      }
      /**
       * Add a highlight to the store
       * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
       * @param {object} data Data to assign to annotation
       * @param {function} cb Callback after annotation is clicked
       * @param {string} className CSS class to assign to annotation
       * @param {object} styles CSS styles to assign to annotation
       */
      highlight(cfiRange, data, cb, className, styles) {
        return this.add("highlight", cfiRange, data, cb, className, styles);
      }
      /**
       * Add a underline to the store
       * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
       * @param {object} data Data to assign to annotation
       * @param {function} cb Callback after annotation is clicked
       * @param {string} className CSS class to assign to annotation
       * @param {object} styles CSS styles to assign to annotation
       */
      underline(cfiRange, data, cb, className, styles) {
        return this.add("underline", cfiRange, data, cb, className, styles);
      }
      /**
       * Add a mark to the store
       * @param {EpubCFI} cfiRange EpubCFI range to attach annotation to
       * @param {object} data Data to assign to annotation
       * @param {function} cb Callback after annotation is clicked
       */
      mark(cfiRange, data, cb) {
        return this.add("mark", cfiRange, data, cb);
      }
      /**
       * iterate over annotations in the store
       */
      each() {
        return this._annotations.forEach.apply(this._annotations, arguments);
      }
      /**
       * Hook for injecting annotation into a view
       * @param {View} view
       * @private
       */
      inject(view) {
        let sectionIndex = view.index;
        if (sectionIndex in this._annotationsBySectionIndex) {
          let annotations = this._annotationsBySectionIndex[sectionIndex];
          annotations.forEach((hash) => {
            let annotation = this._annotations[hash];
            annotation.attach(view);
          });
        }
      }
      /**
       * Hook for removing annotation from a view
       * @param {View} view
       * @private
       */
      clear(view) {
        let sectionIndex = view.index;
        if (sectionIndex in this._annotationsBySectionIndex) {
          let annotations = this._annotationsBySectionIndex[sectionIndex];
          annotations.forEach((hash) => {
            let annotation = this._annotations[hash];
            annotation.detach(view);
          });
        }
      }
      /**
       * [Not Implemented] Show annotations
       * @TODO: needs implementation in View
       */
      show() {
      }
      /**
       * [Not Implemented] Hide annotations
       * @TODO: needs implementation in View
       */
      hide() {
      }
    };
    var Annotation = class {
      constructor({
        type,
        cfiRange,
        data,
        sectionIndex,
        cb,
        className,
        styles
      }) {
        this.type = type;
        this.cfiRange = cfiRange;
        this.data = data;
        this.sectionIndex = sectionIndex;
        this.mark = void 0;
        this.cb = cb;
        this.className = className;
        this.styles = styles;
      }
      /**
       * Update stored data
       * @param {object} data
       */
      update(data) {
        this.data = data;
      }
      /**
       * Add to a view
       * @param {View} view
       */
      attach(view) {
        let {
          cfiRange,
          data,
          type,
          mark,
          cb,
          className,
          styles
        } = this;
        let result;
        if (type === "highlight") {
          result = view.highlight(cfiRange, data, cb, className, styles);
        } else if (type === "underline") {
          result = view.underline(cfiRange, data, cb, className, styles);
        } else if (type === "mark") {
          result = view.mark(cfiRange, data, cb);
        }
        this.mark = result;
        this.emit(_constants.EVENTS.ANNOTATION.ATTACH, result);
        return result;
      }
      /**
       * Remove from a view
       * @param {View} view
       */
      detach(view) {
        let {
          cfiRange,
          type
        } = this;
        let result;
        if (view) {
          if (type === "highlight") {
            result = view.unhighlight(cfiRange);
          } else if (type === "underline") {
            result = view.ununderline(cfiRange);
          } else if (type === "mark") {
            result = view.unmark(cfiRange);
          }
        }
        this.mark = void 0;
        this.emit(_constants.EVENTS.ANNOTATION.DETACH, result);
        return result;
      }
      /**
       * [Not Implemented] Get text of an annotation
       * @TODO: needs implementation in contents
       */
      text() {
      }
    };
    (0, _eventEmitter.default)(Annotation.prototype);
    var _default = Annotations;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/views/iframe.js
var require_iframe = __commonJS({
  "node_modules/epubjs/lib/managers/views/iframe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _contents = _interopRequireDefault(require_contents());
    var _constants = require_constants();
    var _marksPane = require_marks();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IframeView = class {
      constructor(section, options) {
        this.settings = (0, _core.extend)({
          ignoreClass: "",
          axis: void 0,
          //options.layout && options.layout.props.flow === "scrolled" ? "vertical" : "horizontal",
          direction: void 0,
          width: 0,
          height: 0,
          layout: void 0,
          globalLayoutProperties: {},
          method: void 0,
          forceRight: false,
          allowScriptedContent: false,
          allowPopups: false
        }, options || {});
        this.id = "epubjs-view-" + (0, _core.uuid)();
        this.section = section;
        this.index = section.index;
        this.element = this.container(this.settings.axis);
        this.added = false;
        this.displayed = false;
        this.rendered = false;
        this.fixedWidth = 0;
        this.fixedHeight = 0;
        this.epubcfi = new _epubcfi.default();
        this.layout = this.settings.layout;
        this.pane = void 0;
        this.highlights = {};
        this.underlines = {};
        this.marks = {};
      }
      container(axis) {
        var element = document.createElement("div");
        element.classList.add("epub-view");
        element.style.height = "0px";
        element.style.width = "0px";
        element.style.overflow = "hidden";
        element.style.position = "relative";
        element.style.display = "block";
        if (axis && axis == "horizontal") {
          element.style.flex = "none";
        } else {
          element.style.flex = "initial";
        }
        return element;
      }
      create() {
        if (this.iframe) {
          return this.iframe;
        }
        if (!this.element) {
          this.element = this.createContainer();
        }
        this.iframe = document.createElement("iframe");
        this.iframe.id = this.id;
        this.iframe.scrolling = "no";
        this.iframe.style.overflow = "hidden";
        this.iframe.seamless = "seamless";
        this.iframe.style.border = "none";
        this.iframe.sandbox = "allow-same-origin";
        if (this.settings.allowScriptedContent) {
          this.iframe.sandbox += " allow-scripts";
        }
        if (this.settings.allowPopups) {
          this.iframe.sandbox += " allow-popups";
        }
        this.iframe.setAttribute("enable-annotation", "true");
        this.resizing = true;
        this.element.style.visibility = "hidden";
        this.iframe.style.visibility = "hidden";
        this.iframe.style.width = "0";
        this.iframe.style.height = "0";
        this._width = 0;
        this._height = 0;
        this.element.setAttribute("ref", this.index);
        this.added = true;
        this.elementBounds = (0, _core.bounds)(this.element);
        if ("srcdoc" in this.iframe) {
          this.supportsSrcdoc = true;
        } else {
          this.supportsSrcdoc = false;
        }
        if (!this.settings.method) {
          this.settings.method = this.supportsSrcdoc ? "srcdoc" : "write";
        }
        return this.iframe;
      }
      render(request, show) {
        this.create();
        this.size();
        if (!this.sectionRender) {
          this.sectionRender = this.section.render(request);
        }
        return this.sectionRender.then((function(contents) {
          return this.load(contents);
        }).bind(this)).then((function() {
          let writingMode = this.contents.writingMode();
          let axis;
          if (this.settings.flow === "scrolled") {
            axis = writingMode.indexOf("vertical") === 0 ? "horizontal" : "vertical";
          } else {
            axis = writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
          }
          if (writingMode.indexOf("vertical") === 0 && this.settings.flow === "paginated") {
            this.layout.delta = this.layout.height;
          }
          this.setAxis(axis);
          this.emit(_constants.EVENTS.VIEWS.AXIS, axis);
          this.setWritingMode(writingMode);
          this.emit(_constants.EVENTS.VIEWS.WRITING_MODE, writingMode);
          this.layout.format(this.contents, this.section, this.axis);
          this.addListeners();
          return new Promise((resolve, reject) => {
            this.expand();
            if (this.settings.forceRight) {
              this.element.style.marginLeft = this.width() + "px";
            }
            resolve();
          });
        }).bind(this), (function(e) {
          this.emit(_constants.EVENTS.VIEWS.LOAD_ERROR, e);
          return new Promise((resolve, reject) => {
            reject(e);
          });
        }).bind(this)).then((function() {
          this.emit(_constants.EVENTS.VIEWS.RENDERED, this.section);
        }).bind(this));
      }
      reset() {
        if (this.iframe) {
          this.iframe.style.width = "0";
          this.iframe.style.height = "0";
          this._width = 0;
          this._height = 0;
          this._textWidth = void 0;
          this._contentWidth = void 0;
          this._textHeight = void 0;
          this._contentHeight = void 0;
        }
        this._needsReframe = true;
      }
      // Determine locks base on settings
      size(_width, _height) {
        var width = _width || this.settings.width;
        var height = _height || this.settings.height;
        if (this.layout.name === "pre-paginated") {
          this.lock("both", width, height);
        } else if (this.settings.axis === "horizontal") {
          this.lock("height", width, height);
        } else {
          this.lock("width", width, height);
        }
        this.settings.width = width;
        this.settings.height = height;
      }
      // Lock an axis to element dimensions, taking borders into account
      lock(what, width, height) {
        var elBorders = (0, _core.borders)(this.element);
        var iframeBorders;
        if (this.iframe) {
          iframeBorders = (0, _core.borders)(this.iframe);
        } else {
          iframeBorders = {
            width: 0,
            height: 0
          };
        }
        if (what == "width" && (0, _core.isNumber)(width)) {
          this.lockedWidth = width - elBorders.width - iframeBorders.width;
        }
        if (what == "height" && (0, _core.isNumber)(height)) {
          this.lockedHeight = height - elBorders.height - iframeBorders.height;
        }
        if (what === "both" && (0, _core.isNumber)(width) && (0, _core.isNumber)(height)) {
          this.lockedWidth = width - elBorders.width - iframeBorders.width;
          this.lockedHeight = height - elBorders.height - iframeBorders.height;
        }
        if (this.displayed && this.iframe) {
          this.expand();
        }
      }
      // Resize a single axis based on content dimensions
      expand(force) {
        var width = this.lockedWidth;
        var height = this.lockedHeight;
        var columns;
        var textWidth, textHeight;
        if (!this.iframe || this._expanding) return;
        this._expanding = true;
        if (this.layout.name === "pre-paginated") {
          width = this.layout.columnWidth;
          height = this.layout.height;
        } else if (this.settings.axis === "horizontal") {
          width = this.contents.textWidth();
          if (width % this.layout.pageWidth > 0) {
            width = Math.ceil(width / this.layout.pageWidth) * this.layout.pageWidth;
          }
          if (this.settings.forceEvenPages) {
            columns = width / this.layout.pageWidth;
            if (this.layout.divisor > 1 && this.layout.name === "reflowable" && columns % 2 > 0) {
              width += this.layout.pageWidth;
            }
          }
        } else if (this.settings.axis === "vertical") {
          height = this.contents.textHeight();
          if (this.settings.flow === "paginated" && height % this.layout.height > 0) {
            height = Math.ceil(height / this.layout.height) * this.layout.height;
          }
        }
        if (this._needsReframe || width != this._width || height != this._height) {
          this.reframe(width, height);
        }
        this._expanding = false;
      }
      reframe(width, height) {
        var size;
        if ((0, _core.isNumber)(width)) {
          this.element.style.width = width + "px";
          this.iframe.style.width = width + "px";
          this._width = width;
        }
        if ((0, _core.isNumber)(height)) {
          this.element.style.height = height + "px";
          this.iframe.style.height = height + "px";
          this._height = height;
        }
        let widthDelta = this.prevBounds ? width - this.prevBounds.width : width;
        let heightDelta = this.prevBounds ? height - this.prevBounds.height : height;
        size = {
          width,
          height,
          widthDelta,
          heightDelta
        };
        this.pane && this.pane.render();
        requestAnimationFrame(() => {
          let mark;
          for (let m in this.marks) {
            if (this.marks.hasOwnProperty(m)) {
              mark = this.marks[m];
              this.placeMark(mark.element, mark.range);
            }
          }
        });
        this.onResize(this, size);
        this.emit(_constants.EVENTS.VIEWS.RESIZED, size);
        this.prevBounds = size;
        this.elementBounds = (0, _core.bounds)(this.element);
      }
      load(contents) {
        var loading = new _core.defer();
        var loaded = loading.promise;
        if (!this.iframe) {
          loading.reject(new Error("No Iframe Available"));
          return loaded;
        }
        this.iframe.onload = (function(event) {
          this.onLoad(event, loading);
        }).bind(this);
        if (this.settings.method === "blobUrl") {
          this.blobUrl = (0, _core.createBlobUrl)(contents, "application/xhtml+xml");
          this.iframe.src = this.blobUrl;
          this.element.appendChild(this.iframe);
        } else if (this.settings.method === "srcdoc") {
          this.iframe.srcdoc = contents;
          this.element.appendChild(this.iframe);
        } else {
          this.element.appendChild(this.iframe);
          this.document = this.iframe.contentDocument;
          if (!this.document) {
            loading.reject(new Error("No Document Available"));
            return loaded;
          }
          this.iframe.contentDocument.open();
          if (window.MSApp && MSApp.execUnsafeLocalFunction) {
            var outerThis = this;
            MSApp.execUnsafeLocalFunction(function() {
              outerThis.iframe.contentDocument.write(contents);
            });
          } else {
            this.iframe.contentDocument.write(contents);
          }
          this.iframe.contentDocument.close();
        }
        return loaded;
      }
      onLoad(event, promise) {
        this.window = this.iframe.contentWindow;
        this.document = this.iframe.contentDocument;
        this.contents = new _contents.default(this.document, this.document.body, this.section.cfiBase, this.section.index);
        this.rendering = false;
        var link = this.document.querySelector("link[rel='canonical']");
        if (link) {
          link.setAttribute("href", this.section.canonical);
        } else {
          link = this.document.createElement("link");
          link.setAttribute("rel", "canonical");
          link.setAttribute("href", this.section.canonical);
          this.document.querySelector("head").appendChild(link);
        }
        this.contents.on(_constants.EVENTS.CONTENTS.EXPAND, () => {
          if (this.displayed && this.iframe) {
            this.expand();
            if (this.contents) {
              this.layout.format(this.contents);
            }
          }
        });
        this.contents.on(_constants.EVENTS.CONTENTS.RESIZE, (e) => {
          if (this.displayed && this.iframe) {
            this.expand();
            if (this.contents) {
              this.layout.format(this.contents);
            }
          }
        });
        promise.resolve(this.contents);
      }
      setLayout(layout) {
        this.layout = layout;
        if (this.contents) {
          this.layout.format(this.contents);
          this.expand();
        }
      }
      setAxis(axis) {
        this.settings.axis = axis;
        if (axis == "horizontal") {
          this.element.style.flex = "none";
        } else {
          this.element.style.flex = "initial";
        }
        this.size();
      }
      setWritingMode(mode) {
        this.writingMode = mode;
      }
      addListeners() {
      }
      removeListeners(layoutFunc) {
      }
      display(request) {
        var displayed = new _core.defer();
        if (!this.displayed) {
          this.render(request).then((function() {
            this.emit(_constants.EVENTS.VIEWS.DISPLAYED, this);
            this.onDisplayed(this);
            this.displayed = true;
            displayed.resolve(this);
          }).bind(this), function(err) {
            displayed.reject(err, this);
          });
        } else {
          displayed.resolve(this);
        }
        return displayed.promise;
      }
      show() {
        this.element.style.visibility = "visible";
        if (this.iframe) {
          this.iframe.style.visibility = "visible";
          this.iframe.style.transform = "translateZ(0)";
          this.iframe.offsetWidth;
          this.iframe.style.transform = null;
        }
        this.emit(_constants.EVENTS.VIEWS.SHOWN, this);
      }
      hide() {
        this.element.style.visibility = "hidden";
        this.iframe.style.visibility = "hidden";
        this.stopExpanding = true;
        this.emit(_constants.EVENTS.VIEWS.HIDDEN, this);
      }
      offset() {
        return {
          top: this.element.offsetTop,
          left: this.element.offsetLeft
        };
      }
      width() {
        return this._width;
      }
      height() {
        return this._height;
      }
      position() {
        return this.element.getBoundingClientRect();
      }
      locationOf(target) {
        var parentPos = this.iframe.getBoundingClientRect();
        var targetPos = this.contents.locationOf(target, this.settings.ignoreClass);
        return {
          "left": targetPos.left,
          "top": targetPos.top
        };
      }
      onDisplayed(view) {
      }
      onResize(view, e) {
      }
      bounds(force) {
        if (force || !this.elementBounds) {
          this.elementBounds = (0, _core.bounds)(this.element);
        }
        return this.elementBounds;
      }
      highlight(cfiRange, data = {}, cb, className = "epubjs-hl", styles = {}) {
        if (!this.contents) {
          return;
        }
        const attributes = Object.assign({
          "fill": "yellow",
          "fill-opacity": "0.3",
          "mix-blend-mode": "multiply"
        }, styles);
        let range = this.contents.range(cfiRange);
        let emitter = () => {
          this.emit(_constants.EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
        };
        data["epubcfi"] = cfiRange;
        if (!this.pane) {
          this.pane = new _marksPane.Pane(this.iframe, this.element);
        }
        let m = new _marksPane.Highlight(range, className, data, attributes);
        let h = this.pane.addMark(m);
        this.highlights[cfiRange] = {
          "mark": h,
          "element": h.element,
          "listeners": [emitter, cb]
        };
        h.element.setAttribute("ref", className);
        h.element.addEventListener("click", emitter);
        h.element.addEventListener("touchstart", emitter);
        if (cb) {
          h.element.addEventListener("click", cb);
          h.element.addEventListener("touchstart", cb);
        }
        return h;
      }
      underline(cfiRange, data = {}, cb, className = "epubjs-ul", styles = {}) {
        if (!this.contents) {
          return;
        }
        const attributes = Object.assign({
          "stroke": "black",
          "stroke-opacity": "0.3",
          "mix-blend-mode": "multiply"
        }, styles);
        let range = this.contents.range(cfiRange);
        let emitter = () => {
          this.emit(_constants.EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
        };
        data["epubcfi"] = cfiRange;
        if (!this.pane) {
          this.pane = new _marksPane.Pane(this.iframe, this.element);
        }
        let m = new _marksPane.Underline(range, className, data, attributes);
        let h = this.pane.addMark(m);
        this.underlines[cfiRange] = {
          "mark": h,
          "element": h.element,
          "listeners": [emitter, cb]
        };
        h.element.setAttribute("ref", className);
        h.element.addEventListener("click", emitter);
        h.element.addEventListener("touchstart", emitter);
        if (cb) {
          h.element.addEventListener("click", cb);
          h.element.addEventListener("touchstart", cb);
        }
        return h;
      }
      mark(cfiRange, data = {}, cb) {
        if (!this.contents) {
          return;
        }
        if (cfiRange in this.marks) {
          let item = this.marks[cfiRange];
          return item;
        }
        let range = this.contents.range(cfiRange);
        if (!range) {
          return;
        }
        let container = range.commonAncestorContainer;
        let parent2 = container.nodeType === 1 ? container : container.parentNode;
        let emitter = (e) => {
          this.emit(_constants.EVENTS.VIEWS.MARK_CLICKED, cfiRange, data);
        };
        if (range.collapsed && container.nodeType === 1) {
          range = new Range();
          range.selectNodeContents(container);
        } else if (range.collapsed) {
          range = new Range();
          range.selectNodeContents(parent2);
        }
        let mark = this.document.createElement("a");
        mark.setAttribute("ref", "epubjs-mk");
        mark.style.position = "absolute";
        mark.dataset["epubcfi"] = cfiRange;
        if (data) {
          Object.keys(data).forEach((key) => {
            mark.dataset[key] = data[key];
          });
        }
        if (cb) {
          mark.addEventListener("click", cb);
          mark.addEventListener("touchstart", cb);
        }
        mark.addEventListener("click", emitter);
        mark.addEventListener("touchstart", emitter);
        this.placeMark(mark, range);
        this.element.appendChild(mark);
        this.marks[cfiRange] = {
          "element": mark,
          "range": range,
          "listeners": [emitter, cb]
        };
        return parent2;
      }
      placeMark(element, range) {
        let top, right, left;
        if (this.layout.name === "pre-paginated" || this.settings.axis !== "horizontal") {
          let pos = range.getBoundingClientRect();
          top = pos.top;
          right = pos.right;
        } else {
          let rects = range.getClientRects();
          let rect;
          for (var i = 0; i != rects.length; i++) {
            rect = rects[i];
            if (!left || rect.left < left) {
              left = rect.left;
              right = Math.ceil(left / this.layout.props.pageWidth) * this.layout.props.pageWidth - this.layout.gap / 2;
              top = rect.top;
            }
          }
        }
        element.style.top = `${top}px`;
        element.style.left = `${right}px`;
      }
      unhighlight(cfiRange) {
        let item;
        if (cfiRange in this.highlights) {
          item = this.highlights[cfiRange];
          this.pane.removeMark(item.mark);
          item.listeners.forEach((l) => {
            if (l) {
              item.element.removeEventListener("click", l);
              item.element.removeEventListener("touchstart", l);
            }
            ;
          });
          delete this.highlights[cfiRange];
        }
      }
      ununderline(cfiRange) {
        let item;
        if (cfiRange in this.underlines) {
          item = this.underlines[cfiRange];
          this.pane.removeMark(item.mark);
          item.listeners.forEach((l) => {
            if (l) {
              item.element.removeEventListener("click", l);
              item.element.removeEventListener("touchstart", l);
            }
            ;
          });
          delete this.underlines[cfiRange];
        }
      }
      unmark(cfiRange) {
        let item;
        if (cfiRange in this.marks) {
          item = this.marks[cfiRange];
          this.element.removeChild(item.element);
          item.listeners.forEach((l) => {
            if (l) {
              item.element.removeEventListener("click", l);
              item.element.removeEventListener("touchstart", l);
            }
            ;
          });
          delete this.marks[cfiRange];
        }
      }
      destroy() {
        for (let cfiRange in this.highlights) {
          this.unhighlight(cfiRange);
        }
        for (let cfiRange in this.underlines) {
          this.ununderline(cfiRange);
        }
        for (let cfiRange in this.marks) {
          this.unmark(cfiRange);
        }
        if (this.blobUrl) {
          (0, _core.revokeBlobUrl)(this.blobUrl);
        }
        if (this.displayed) {
          this.displayed = false;
          this.removeListeners();
          this.contents.destroy();
          this.stopExpanding = true;
          this.element.removeChild(this.iframe);
          if (this.pane) {
            this.pane.element.remove();
            this.pane = void 0;
          }
          this.iframe = void 0;
          this.contents = void 0;
          this._textWidth = null;
          this._textHeight = null;
          this._width = null;
          this._height = null;
        }
      }
    };
    (0, _eventEmitter.default)(IframeView.prototype);
    var _default = IframeView;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/utils/scrolltype.js
var require_scrolltype = __commonJS({
  "node_modules/epubjs/lib/utils/scrolltype.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createDefiner = createDefiner;
    exports.default = scrollType;
    function scrollType() {
      var type = "reverse";
      var definer = createDefiner();
      document.body.appendChild(definer);
      if (definer.scrollLeft > 0) {
        type = "default";
      } else {
        if (typeof Element !== "undefined" && Element.prototype.scrollIntoView) {
          definer.children[0].children[1].scrollIntoView();
          if (definer.scrollLeft < 0) {
            type = "negative";
          }
        } else {
          definer.scrollLeft = 1;
          if (definer.scrollLeft === 0) {
            type = "negative";
          }
        }
      }
      document.body.removeChild(definer);
      return type;
    }
    function createDefiner() {
      var definer = document.createElement("div");
      definer.dir = "rtl";
      definer.style.position = "fixed";
      definer.style.width = "1px";
      definer.style.height = "1px";
      definer.style.top = "0px";
      definer.style.left = "0px";
      definer.style.overflow = "hidden";
      var innerDiv = document.createElement("div");
      innerDiv.style.width = "2px";
      var spanA = document.createElement("span");
      spanA.style.width = "1px";
      spanA.style.display = "inline-block";
      var spanB = document.createElement("span");
      spanB.style.width = "1px";
      spanB.style.display = "inline-block";
      innerDiv.appendChild(spanA);
      innerDiv.appendChild(spanB);
      definer.appendChild(innerDiv);
      return definer;
    }
  }
});

// node_modules/epubjs/lib/managers/helpers/stage.js
var require_stage = __commonJS({
  "node_modules/epubjs/lib/managers/helpers/stage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _throttle = _interopRequireDefault(require_throttle());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Stage = class {
      constructor(_options) {
        this.settings = _options || {};
        this.id = "epubjs-container-" + (0, _core.uuid)();
        this.container = this.create(this.settings);
        if (this.settings.hidden) {
          this.wrapper = this.wrap(this.container);
        }
      }
      /*
      * Creates an element to render to.
      * Resizes to passed width and height or to the elements size
      */
      create(options) {
        let height = options.height;
        let width = options.width;
        let overflow = options.overflow || false;
        let axis = options.axis || "vertical";
        let direction = options.direction;
        (0, _core.extend)(this.settings, options);
        if (options.height && (0, _core.isNumber)(options.height)) {
          height = options.height + "px";
        }
        if (options.width && (0, _core.isNumber)(options.width)) {
          width = options.width + "px";
        }
        let container = document.createElement("div");
        container.id = this.id;
        container.classList.add("epub-container");
        container.style.wordSpacing = "0";
        container.style.lineHeight = "0";
        container.style.verticalAlign = "top";
        container.style.position = "relative";
        if (axis === "horizontal") {
          container.style.display = "flex";
          container.style.flexDirection = "row";
          container.style.flexWrap = "nowrap";
        }
        if (width) {
          container.style.width = width;
        }
        if (height) {
          container.style.height = height;
        }
        if (overflow) {
          if (overflow === "scroll" && axis === "vertical") {
            container.style["overflow-y"] = overflow;
            container.style["overflow-x"] = "hidden";
          } else if (overflow === "scroll" && axis === "horizontal") {
            container.style["overflow-y"] = "hidden";
            container.style["overflow-x"] = overflow;
          } else {
            container.style["overflow"] = overflow;
          }
        }
        if (direction) {
          container.dir = direction;
          container.style["direction"] = direction;
        }
        if (direction && this.settings.fullsize) {
          document.body.style["direction"] = direction;
        }
        return container;
      }
      wrap(container) {
        var wrapper = document.createElement("div");
        wrapper.style.visibility = "hidden";
        wrapper.style.overflow = "hidden";
        wrapper.style.width = "0";
        wrapper.style.height = "0";
        wrapper.appendChild(container);
        return wrapper;
      }
      getElement(_element) {
        var element;
        if ((0, _core.isElement)(_element)) {
          element = _element;
        } else if (typeof _element === "string") {
          element = document.getElementById(_element);
        }
        if (!element) {
          throw new Error("Not an Element");
        }
        return element;
      }
      attachTo(what) {
        var element = this.getElement(what);
        var base;
        if (!element) {
          return;
        }
        if (this.settings.hidden) {
          base = this.wrapper;
        } else {
          base = this.container;
        }
        element.appendChild(base);
        this.element = element;
        return element;
      }
      getContainer() {
        return this.container;
      }
      onResize(func) {
        if (!(0, _core.isNumber)(this.settings.width) || !(0, _core.isNumber)(this.settings.height)) {
          this.resizeFunc = (0, _throttle.default)(func, 50);
          window.addEventListener("resize", this.resizeFunc, false);
        }
      }
      onOrientationChange(func) {
        this.orientationChangeFunc = func;
        window.addEventListener("orientationchange", this.orientationChangeFunc, false);
      }
      size(width, height) {
        var bounds;
        let _width = width || this.settings.width;
        let _height = height || this.settings.height;
        if (width === null) {
          bounds = this.element.getBoundingClientRect();
          if (bounds.width) {
            width = Math.floor(bounds.width);
            this.container.style.width = width + "px";
          }
        } else {
          if ((0, _core.isNumber)(width)) {
            this.container.style.width = width + "px";
          } else {
            this.container.style.width = width;
          }
        }
        if (height === null) {
          bounds = bounds || this.element.getBoundingClientRect();
          if (bounds.height) {
            height = bounds.height;
            this.container.style.height = height + "px";
          }
        } else {
          if ((0, _core.isNumber)(height)) {
            this.container.style.height = height + "px";
          } else {
            this.container.style.height = height;
          }
        }
        if (!(0, _core.isNumber)(width)) {
          width = this.container.clientWidth;
        }
        if (!(0, _core.isNumber)(height)) {
          height = this.container.clientHeight;
        }
        this.containerStyles = window.getComputedStyle(this.container);
        this.containerPadding = {
          left: parseFloat(this.containerStyles["padding-left"]) || 0,
          right: parseFloat(this.containerStyles["padding-right"]) || 0,
          top: parseFloat(this.containerStyles["padding-top"]) || 0,
          bottom: parseFloat(this.containerStyles["padding-bottom"]) || 0
        };
        let _windowBounds = (0, _core.windowBounds)();
        let bodyStyles = window.getComputedStyle(document.body);
        let bodyPadding = {
          left: parseFloat(bodyStyles["padding-left"]) || 0,
          right: parseFloat(bodyStyles["padding-right"]) || 0,
          top: parseFloat(bodyStyles["padding-top"]) || 0,
          bottom: parseFloat(bodyStyles["padding-bottom"]) || 0
        };
        if (!_width) {
          width = _windowBounds.width - bodyPadding.left - bodyPadding.right;
        }
        if (this.settings.fullsize && !_height || !_height) {
          height = _windowBounds.height - bodyPadding.top - bodyPadding.bottom;
        }
        return {
          width: width - this.containerPadding.left - this.containerPadding.right,
          height: height - this.containerPadding.top - this.containerPadding.bottom
        };
      }
      bounds() {
        let box;
        if (this.container.style.overflow !== "visible") {
          box = this.container && this.container.getBoundingClientRect();
        }
        if (!box || !box.width || !box.height) {
          return (0, _core.windowBounds)();
        } else {
          return box;
        }
      }
      getSheet() {
        var style = document.createElement("style");
        style.appendChild(document.createTextNode(""));
        document.head.appendChild(style);
        return style.sheet;
      }
      addStyleRules(selector, rulesArray) {
        var scope = "#" + this.id + " ";
        var rules = "";
        if (!this.sheet) {
          this.sheet = this.getSheet();
        }
        rulesArray.forEach(function(set) {
          for (var prop in set) {
            if (set.hasOwnProperty(prop)) {
              rules += prop + ":" + set[prop] + ";";
            }
          }
        });
        this.sheet.insertRule(scope + selector + " {" + rules + "}", 0);
      }
      axis(axis) {
        if (axis === "horizontal") {
          this.container.style.display = "flex";
          this.container.style.flexDirection = "row";
          this.container.style.flexWrap = "nowrap";
        } else {
          this.container.style.display = "block";
        }
        this.settings.axis = axis;
      }
      // orientation(orientation) {
      // 	if (orientation === "landscape") {
      //
      // 	} else {
      //
      // 	}
      //
      // 	this.orientation = orientation;
      // }
      direction(dir) {
        if (this.container) {
          this.container.dir = dir;
          this.container.style["direction"] = dir;
        }
        if (this.settings.fullsize) {
          document.body.style["direction"] = dir;
        }
        this.settings.dir = dir;
      }
      overflow(overflow) {
        if (this.container) {
          if (overflow === "scroll" && this.settings.axis === "vertical") {
            this.container.style["overflow-y"] = overflow;
            this.container.style["overflow-x"] = "hidden";
          } else if (overflow === "scroll" && this.settings.axis === "horizontal") {
            this.container.style["overflow-y"] = "hidden";
            this.container.style["overflow-x"] = overflow;
          } else {
            this.container.style["overflow"] = overflow;
          }
        }
        this.settings.overflow = overflow;
      }
      destroy() {
        var base;
        if (this.element) {
          if (this.settings.hidden) {
            base = this.wrapper;
          } else {
            base = this.container;
          }
          if (this.element.contains(this.container)) {
            this.element.removeChild(this.container);
          }
          window.removeEventListener("resize", this.resizeFunc);
          window.removeEventListener("orientationChange", this.orientationChangeFunc);
        }
      }
    };
    var _default = Stage;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/helpers/views.js
var require_views = __commonJS({
  "node_modules/epubjs/lib/managers/helpers/views.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Views = class {
      constructor(container) {
        this.container = container;
        this._views = [];
        this.length = 0;
        this.hidden = false;
      }
      all() {
        return this._views;
      }
      first() {
        return this._views[0];
      }
      last() {
        return this._views[this._views.length - 1];
      }
      indexOf(view) {
        return this._views.indexOf(view);
      }
      slice() {
        return this._views.slice.apply(this._views, arguments);
      }
      get(i) {
        return this._views[i];
      }
      append(view) {
        this._views.push(view);
        if (this.container) {
          this.container.appendChild(view.element);
        }
        this.length++;
        return view;
      }
      prepend(view) {
        this._views.unshift(view);
        if (this.container) {
          this.container.insertBefore(view.element, this.container.firstChild);
        }
        this.length++;
        return view;
      }
      insert(view, index) {
        this._views.splice(index, 0, view);
        if (this.container) {
          if (index < this.container.children.length) {
            this.container.insertBefore(view.element, this.container.children[index]);
          } else {
            this.container.appendChild(view.element);
          }
        }
        this.length++;
        return view;
      }
      remove(view) {
        var index = this._views.indexOf(view);
        if (index > -1) {
          this._views.splice(index, 1);
        }
        this.destroy(view);
        this.length--;
      }
      destroy(view) {
        if (view.displayed) {
          view.destroy();
        }
        if (this.container) {
          this.container.removeChild(view.element);
        }
        view = null;
      }
      // Iterators
      forEach() {
        return this._views.forEach.apply(this._views, arguments);
      }
      clear() {
        var view;
        var len = this.length;
        if (!this.length) return;
        for (var i = 0; i < len; i++) {
          view = this._views[i];
          this.destroy(view);
        }
        this._views = [];
        this.length = 0;
      }
      find(section) {
        var view;
        var len = this.length;
        for (var i = 0; i < len; i++) {
          view = this._views[i];
          if (view.displayed && view.section.index == section.index) {
            return view;
          }
        }
      }
      displayed() {
        var displayed = [];
        var view;
        var len = this.length;
        for (var i = 0; i < len; i++) {
          view = this._views[i];
          if (view.displayed) {
            displayed.push(view);
          }
        }
        return displayed;
      }
      show() {
        var view;
        var len = this.length;
        for (var i = 0; i < len; i++) {
          view = this._views[i];
          if (view.displayed) {
            view.show();
          }
        }
        this.hidden = false;
      }
      hide() {
        var view;
        var len = this.length;
        for (var i = 0; i < len; i++) {
          view = this._views[i];
          if (view.displayed) {
            view.hide();
          }
        }
        this.hidden = true;
      }
    };
    var _default = Views;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/default/index.js
var require_default = __commonJS({
  "node_modules/epubjs/lib/managers/default/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _scrolltype = _interopRequireDefault(require_scrolltype());
    var _mapping = _interopRequireDefault(require_mapping());
    var _queue = _interopRequireDefault(require_queue());
    var _stage = _interopRequireDefault(require_stage());
    var _views = _interopRequireDefault(require_views());
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DefaultViewManager = class {
      constructor(options) {
        this.name = "default";
        this.optsSettings = options.settings;
        this.View = options.view;
        this.request = options.request;
        this.renditionQueue = options.queue;
        this.q = new _queue.default(this);
        this.settings = (0, _core.extend)(this.settings || {}, {
          infinite: true,
          hidden: false,
          width: void 0,
          height: void 0,
          axis: void 0,
          writingMode: void 0,
          flow: "scrolled",
          ignoreClass: "",
          fullsize: void 0,
          allowScriptedContent: false,
          allowPopups: false
        });
        (0, _core.extend)(this.settings, options.settings || {});
        this.viewSettings = {
          ignoreClass: this.settings.ignoreClass,
          axis: this.settings.axis,
          flow: this.settings.flow,
          layout: this.layout,
          method: this.settings.method,
          // srcdoc, blobUrl, write
          width: 0,
          height: 0,
          forceEvenPages: true,
          allowScriptedContent: this.settings.allowScriptedContent,
          allowPopups: this.settings.allowPopups
        };
        this.rendered = false;
      }
      render(element, size) {
        let tag = element.tagName;
        if (typeof this.settings.fullsize === "undefined" && tag && (tag.toLowerCase() == "body" || tag.toLowerCase() == "html")) {
          this.settings.fullsize = true;
        }
        if (this.settings.fullsize) {
          this.settings.overflow = "visible";
          this.overflow = this.settings.overflow;
        }
        this.settings.size = size;
        this.settings.rtlScrollType = (0, _scrolltype.default)();
        this.stage = new _stage.default({
          width: size.width,
          height: size.height,
          overflow: this.overflow,
          hidden: this.settings.hidden,
          axis: this.settings.axis,
          fullsize: this.settings.fullsize,
          direction: this.settings.direction
        });
        this.stage.attachTo(element);
        this.container = this.stage.getContainer();
        this.views = new _views.default(this.container);
        this._bounds = this.bounds();
        this._stageSize = this.stage.size();
        this.viewSettings.width = this._stageSize.width;
        this.viewSettings.height = this._stageSize.height;
        this.stage.onResize(this.onResized.bind(this));
        this.stage.onOrientationChange(this.onOrientationChange.bind(this));
        this.addEventListeners();
        if (this.layout) {
          this.updateLayout();
        }
        this.rendered = true;
      }
      addEventListeners() {
        var scroller;
        window.addEventListener("unload", (function(e) {
          this.destroy();
        }).bind(this));
        if (!this.settings.fullsize) {
          scroller = this.container;
        } else {
          scroller = window;
        }
        this._onScroll = this.onScroll.bind(this);
        scroller.addEventListener("scroll", this._onScroll);
      }
      removeEventListeners() {
        var scroller;
        if (!this.settings.fullsize) {
          scroller = this.container;
        } else {
          scroller = window;
        }
        scroller.removeEventListener("scroll", this._onScroll);
        this._onScroll = void 0;
      }
      destroy() {
        clearTimeout(this.orientationTimeout);
        clearTimeout(this.resizeTimeout);
        clearTimeout(this.afterScrolled);
        this.clear();
        this.removeEventListeners();
        this.stage.destroy();
        this.rendered = false;
      }
      onOrientationChange(e) {
        let {
          orientation
        } = window;
        if (this.optsSettings.resizeOnOrientationChange) {
          this.resize();
        }
        clearTimeout(this.orientationTimeout);
        this.orientationTimeout = setTimeout((function() {
          this.orientationTimeout = void 0;
          if (this.optsSettings.resizeOnOrientationChange) {
            this.resize();
          }
          this.emit(_constants.EVENTS.MANAGERS.ORIENTATION_CHANGE, orientation);
        }).bind(this), 500);
      }
      onResized(e) {
        this.resize();
      }
      resize(width, height, epubcfi) {
        let stageSize = this.stage.size(width, height);
        this.winBounds = (0, _core.windowBounds)();
        if (this.orientationTimeout && this.winBounds.width === this.winBounds.height) {
          this._stageSize = void 0;
          return;
        }
        if (this._stageSize && this._stageSize.width === stageSize.width && this._stageSize.height === stageSize.height) {
          return;
        }
        this._stageSize = stageSize;
        this._bounds = this.bounds();
        this.clear();
        this.viewSettings.width = this._stageSize.width;
        this.viewSettings.height = this._stageSize.height;
        this.updateLayout();
        this.emit(_constants.EVENTS.MANAGERS.RESIZED, {
          width: this._stageSize.width,
          height: this._stageSize.height
        }, epubcfi);
      }
      createView(section, forceRight) {
        return new this.View(section, (0, _core.extend)(this.viewSettings, {
          forceRight
        }));
      }
      handleNextPrePaginated(forceRight, section, action) {
        let next;
        if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
          if (forceRight || section.index === 0) {
            return;
          }
          next = section.next();
          if (next && !next.properties.includes("page-spread-left")) {
            return action.call(this, next);
          }
        }
      }
      display(section, target) {
        var displaying = new _core.defer();
        var displayed = displaying.promise;
        if (target === section.href || (0, _core.isNumber)(target)) {
          target = void 0;
        }
        var visible = this.views.find(section);
        if (visible && section && this.layout.name !== "pre-paginated") {
          let offset = visible.offset();
          if (this.settings.direction === "ltr") {
            this.scrollTo(offset.left, offset.top, true);
          } else {
            let width = visible.width();
            this.scrollTo(offset.left + width, offset.top, true);
          }
          if (target) {
            let offset2 = visible.locationOf(target);
            let width = visible.width();
            this.moveTo(offset2, width);
          }
          displaying.resolve();
          return displayed;
        }
        this.clear();
        let forceRight = false;
        if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && section.properties.includes("page-spread-right")) {
          forceRight = true;
        }
        this.add(section, forceRight).then((function(view) {
          if (target) {
            let offset = view.locationOf(target);
            let width = view.width();
            this.moveTo(offset, width);
          }
        }).bind(this), (err) => {
          displaying.reject(err);
        }).then((function() {
          return this.handleNextPrePaginated(forceRight, section, this.add);
        }).bind(this)).then((function() {
          this.views.show();
          displaying.resolve();
        }).bind(this));
        return displayed;
      }
      afterDisplayed(view) {
        this.emit(_constants.EVENTS.MANAGERS.ADDED, view);
      }
      afterResized(view) {
        this.emit(_constants.EVENTS.MANAGERS.RESIZE, view.section);
      }
      moveTo(offset, width) {
        var distX = 0, distY = 0;
        if (!this.isPaginated) {
          distY = offset.top;
        } else {
          distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta;
          if (distX + this.layout.delta > this.container.scrollWidth) {
            distX = this.container.scrollWidth - this.layout.delta;
          }
          distY = Math.floor(offset.top / this.layout.delta) * this.layout.delta;
          if (distY + this.layout.delta > this.container.scrollHeight) {
            distY = this.container.scrollHeight - this.layout.delta;
          }
        }
        if (this.settings.direction === "rtl") {
          distX = distX + this.layout.delta;
          distX = distX - width;
        }
        this.scrollTo(distX, distY, true);
      }
      add(section, forceRight) {
        var view = this.createView(section, forceRight);
        this.views.append(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        view.onResize = this.afterResized.bind(this);
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        return view.display(this.request);
      }
      append(section, forceRight) {
        var view = this.createView(section, forceRight);
        this.views.append(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        view.onResize = this.afterResized.bind(this);
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        return view.display(this.request);
      }
      prepend(section, forceRight) {
        var view = this.createView(section, forceRight);
        view.on(_constants.EVENTS.VIEWS.RESIZED, (bounds) => {
          this.counter(bounds);
        });
        this.views.prepend(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        view.onResize = this.afterResized.bind(this);
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        return view.display(this.request);
      }
      counter(bounds) {
        if (this.settings.axis === "vertical") {
          this.scrollBy(0, bounds.heightDelta, true);
        } else {
          this.scrollBy(bounds.widthDelta, 0, true);
        }
      }
      // resizeView(view) {
      //
      // 	if(this.settings.globalLayoutProperties.layout === "pre-paginated") {
      // 		view.lock("both", this.bounds.width, this.bounds.height);
      // 	} else {
      // 		view.lock("width", this.bounds.width, this.bounds.height);
      // 	}
      //
      // };
      next() {
        var next;
        var left;
        let dir = this.settings.direction;
        if (!this.views.length) return;
        if (this.isPaginated && this.settings.axis === "horizontal" && (!dir || dir === "ltr")) {
          this.scrollLeft = this.container.scrollLeft;
          left = this.container.scrollLeft + this.container.offsetWidth + this.layout.delta;
          if (left <= this.container.scrollWidth) {
            this.scrollBy(this.layout.delta, 0, true);
          } else {
            next = this.views.last().section.next();
          }
        } else if (this.isPaginated && this.settings.axis === "horizontal" && dir === "rtl") {
          this.scrollLeft = this.container.scrollLeft;
          if (this.settings.rtlScrollType === "default") {
            left = this.container.scrollLeft;
            if (left > 0) {
              this.scrollBy(this.layout.delta, 0, true);
            } else {
              next = this.views.last().section.next();
            }
          } else {
            left = this.container.scrollLeft + this.layout.delta * -1;
            if (left > this.container.scrollWidth * -1) {
              this.scrollBy(this.layout.delta, 0, true);
            } else {
              next = this.views.last().section.next();
            }
          }
        } else if (this.isPaginated && this.settings.axis === "vertical") {
          this.scrollTop = this.container.scrollTop;
          let top = this.container.scrollTop + this.container.offsetHeight;
          if (top < this.container.scrollHeight) {
            this.scrollBy(0, this.layout.height, true);
          } else {
            next = this.views.last().section.next();
          }
        } else {
          next = this.views.last().section.next();
        }
        if (next) {
          this.clear();
          this.updateLayout();
          let forceRight = false;
          if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && next.properties.includes("page-spread-right")) {
            forceRight = true;
          }
          return this.append(next, forceRight).then((function() {
            return this.handleNextPrePaginated(forceRight, next, this.append);
          }).bind(this), (err) => {
            return err;
          }).then((function() {
            if (!this.isPaginated && this.settings.axis === "horizontal" && this.settings.direction === "rtl" && this.settings.rtlScrollType === "default") {
              this.scrollTo(this.container.scrollWidth, 0, true);
            }
            this.views.show();
          }).bind(this));
        }
      }
      prev() {
        var prev;
        var left;
        let dir = this.settings.direction;
        if (!this.views.length) return;
        if (this.isPaginated && this.settings.axis === "horizontal" && (!dir || dir === "ltr")) {
          this.scrollLeft = this.container.scrollLeft;
          left = this.container.scrollLeft;
          if (left > 0) {
            this.scrollBy(-this.layout.delta, 0, true);
          } else {
            prev = this.views.first().section.prev();
          }
        } else if (this.isPaginated && this.settings.axis === "horizontal" && dir === "rtl") {
          this.scrollLeft = this.container.scrollLeft;
          if (this.settings.rtlScrollType === "default") {
            left = this.container.scrollLeft + this.container.offsetWidth;
            if (left < this.container.scrollWidth) {
              this.scrollBy(-this.layout.delta, 0, true);
            } else {
              prev = this.views.first().section.prev();
            }
          } else {
            left = this.container.scrollLeft;
            if (left < 0) {
              this.scrollBy(-this.layout.delta, 0, true);
            } else {
              prev = this.views.first().section.prev();
            }
          }
        } else if (this.isPaginated && this.settings.axis === "vertical") {
          this.scrollTop = this.container.scrollTop;
          let top = this.container.scrollTop;
          if (top > 0) {
            this.scrollBy(0, -this.layout.height, true);
          } else {
            prev = this.views.first().section.prev();
          }
        } else {
          prev = this.views.first().section.prev();
        }
        if (prev) {
          this.clear();
          this.updateLayout();
          let forceRight = false;
          if (this.layout.name === "pre-paginated" && this.layout.divisor === 2 && typeof prev.prev() !== "object") {
            forceRight = true;
          }
          return this.prepend(prev, forceRight).then((function() {
            var left2;
            if (this.layout.name === "pre-paginated" && this.layout.divisor > 1) {
              left2 = prev.prev();
              if (left2) {
                return this.prepend(left2);
              }
            }
          }).bind(this), (err) => {
            return err;
          }).then((function() {
            if (this.isPaginated && this.settings.axis === "horizontal") {
              if (this.settings.direction === "rtl") {
                if (this.settings.rtlScrollType === "default") {
                  this.scrollTo(0, 0, true);
                } else {
                  this.scrollTo(this.container.scrollWidth * -1 + this.layout.delta, 0, true);
                }
              } else {
                this.scrollTo(this.container.scrollWidth - this.layout.delta, 0, true);
              }
            }
            this.views.show();
          }).bind(this));
        }
      }
      current() {
        var visible = this.visible();
        if (visible.length) {
          return visible[visible.length - 1];
        }
        return null;
      }
      clear() {
        if (this.views) {
          this.views.hide();
          this.scrollTo(0, 0, true);
          this.views.clear();
        }
      }
      currentLocation() {
        this.updateLayout();
        if (this.isPaginated && this.settings.axis === "horizontal") {
          this.location = this.paginatedLocation();
        } else {
          this.location = this.scrolledLocation();
        }
        return this.location;
      }
      scrolledLocation() {
        let visible = this.visible();
        let container = this.container.getBoundingClientRect();
        let pageHeight = container.height < window.innerHeight ? container.height : window.innerHeight;
        let pageWidth = container.width < window.innerWidth ? container.width : window.innerWidth;
        let vertical = this.settings.axis === "vertical";
        let rtl = this.settings.direction === "rtl";
        let offset = 0;
        let used = 0;
        if (this.settings.fullsize) {
          offset = vertical ? window.scrollY : window.scrollX;
        }
        let sections = visible.map((view) => {
          let {
            index,
            href
          } = view.section;
          let position = view.position();
          let width = view.width();
          let height = view.height();
          let startPos;
          let endPos;
          let stopPos;
          let totalPages;
          if (vertical) {
            startPos = offset + container.top - position.top + used;
            endPos = startPos + pageHeight - used;
            totalPages = this.layout.count(height, pageHeight).pages;
            stopPos = pageHeight;
          } else {
            startPos = offset + container.left - position.left + used;
            endPos = startPos + pageWidth - used;
            totalPages = this.layout.count(width, pageWidth).pages;
            stopPos = pageWidth;
          }
          let currPage = Math.ceil(startPos / stopPos);
          let pages = [];
          let endPage = Math.ceil(endPos / stopPos);
          if (this.settings.direction === "rtl" && !vertical) {
            let tempStartPage = currPage;
            currPage = totalPages - endPage;
            endPage = totalPages - tempStartPage;
          }
          pages = [];
          for (var i = currPage; i <= endPage; i++) {
            let pg = i + 1;
            pages.push(pg);
          }
          let mapping = this.mapping.page(view.contents, view.section.cfiBase, startPos, endPos);
          return {
            index,
            href,
            pages,
            totalPages,
            mapping
          };
        });
        return sections;
      }
      paginatedLocation() {
        let visible = this.visible();
        let container = this.container.getBoundingClientRect();
        let left = 0;
        let used = 0;
        if (this.settings.fullsize) {
          left = window.scrollX;
        }
        let sections = visible.map((view) => {
          let {
            index,
            href
          } = view.section;
          let offset;
          let position = view.position();
          let width = view.width();
          let start;
          let end;
          let pageWidth;
          if (this.settings.direction === "rtl") {
            offset = container.right - left;
            pageWidth = Math.min(Math.abs(offset - position.left), this.layout.width) - used;
            end = position.width - (position.right - offset) - used;
            start = end - pageWidth;
          } else {
            offset = container.left + left;
            pageWidth = Math.min(position.right - offset, this.layout.width) - used;
            start = offset - position.left + used;
            end = start + pageWidth;
          }
          used += pageWidth;
          let mapping = this.mapping.page(view.contents, view.section.cfiBase, start, end);
          let totalPages = this.layout.count(width).pages;
          let startPage = Math.floor(start / this.layout.pageWidth);
          let pages = [];
          let endPage = Math.floor(end / this.layout.pageWidth);
          if (startPage < 0) {
            startPage = 0;
            endPage = endPage + 1;
          }
          if (this.settings.direction === "rtl") {
            let tempStartPage = startPage;
            startPage = totalPages - endPage;
            endPage = totalPages - tempStartPage;
          }
          for (var i = startPage + 1; i <= endPage; i++) {
            let pg = i;
            pages.push(pg);
          }
          return {
            index,
            href,
            pages,
            totalPages,
            mapping
          };
        });
        return sections;
      }
      isVisible(view, offsetPrev, offsetNext, _container) {
        var position = view.position();
        var container = _container || this.bounds();
        if (this.settings.axis === "horizontal" && position.right > container.left - offsetPrev && position.left < container.right + offsetNext) {
          return true;
        } else if (this.settings.axis === "vertical" && position.bottom > container.top - offsetPrev && position.top < container.bottom + offsetNext) {
          return true;
        }
        return false;
      }
      visible() {
        var container = this.bounds();
        var views = this.views.displayed();
        var viewsLength = views.length;
        var visible = [];
        var isVisible;
        var view;
        for (var i = 0; i < viewsLength; i++) {
          view = views[i];
          isVisible = this.isVisible(view, 0, 0, container);
          if (isVisible === true) {
            visible.push(view);
          }
        }
        return visible;
      }
      scrollBy(x, y, silent) {
        let dir = this.settings.direction === "rtl" ? -1 : 1;
        if (silent) {
          this.ignore = true;
        }
        if (!this.settings.fullsize) {
          if (x) this.container.scrollLeft += x * dir;
          if (y) this.container.scrollTop += y;
        } else {
          window.scrollBy(x * dir, y * dir);
        }
        this.scrolled = true;
      }
      scrollTo(x, y, silent) {
        if (silent) {
          this.ignore = true;
        }
        if (!this.settings.fullsize) {
          this.container.scrollLeft = x;
          this.container.scrollTop = y;
        } else {
          window.scrollTo(x, y);
        }
        this.scrolled = true;
      }
      onScroll() {
        let scrollTop;
        let scrollLeft;
        if (!this.settings.fullsize) {
          scrollTop = this.container.scrollTop;
          scrollLeft = this.container.scrollLeft;
        } else {
          scrollTop = window.scrollY;
          scrollLeft = window.scrollX;
        }
        this.scrollTop = scrollTop;
        this.scrollLeft = scrollLeft;
        if (!this.ignore) {
          this.emit(_constants.EVENTS.MANAGERS.SCROLL, {
            top: scrollTop,
            left: scrollLeft
          });
          clearTimeout(this.afterScrolled);
          this.afterScrolled = setTimeout((function() {
            this.emit(_constants.EVENTS.MANAGERS.SCROLLED, {
              top: this.scrollTop,
              left: this.scrollLeft
            });
          }).bind(this), 20);
        } else {
          this.ignore = false;
        }
      }
      bounds() {
        var bounds;
        bounds = this.stage.bounds();
        return bounds;
      }
      applyLayout(layout) {
        this.layout = layout;
        this.updateLayout();
        if (this.views && this.views.length > 0 && this.layout.name === "pre-paginated") {
          this.display(this.views.first().section);
        }
      }
      updateLayout() {
        if (!this.stage) {
          return;
        }
        this._stageSize = this.stage.size();
        if (!this.isPaginated) {
          this.layout.calculate(this._stageSize.width, this._stageSize.height);
        } else {
          this.layout.calculate(this._stageSize.width, this._stageSize.height, this.settings.gap);
          this.settings.offset = this.layout.delta / this.layout.divisor;
        }
        this.viewSettings.width = this.layout.width;
        this.viewSettings.height = this.layout.height;
        this.setLayout(this.layout);
      }
      setLayout(layout) {
        this.viewSettings.layout = layout;
        this.mapping = new _mapping.default(layout.props, this.settings.direction, this.settings.axis);
        if (this.views) {
          this.views.forEach(function(view) {
            if (view) {
              view.setLayout(layout);
            }
          });
        }
      }
      updateWritingMode(mode) {
        this.writingMode = mode;
      }
      updateAxis(axis, forceUpdate) {
        if (!forceUpdate && axis === this.settings.axis) {
          return;
        }
        this.settings.axis = axis;
        this.stage && this.stage.axis(axis);
        this.viewSettings.axis = axis;
        if (this.mapping) {
          this.mapping = new _mapping.default(this.layout.props, this.settings.direction, this.settings.axis);
        }
        if (this.layout) {
          if (axis === "vertical") {
            this.layout.spread("none");
          } else {
            this.layout.spread(this.layout.settings.spread);
          }
        }
      }
      updateFlow(flow, defaultScrolledOverflow = "auto") {
        let isPaginated = flow === "paginated" || flow === "auto";
        this.isPaginated = isPaginated;
        if (flow === "scrolled-doc" || flow === "scrolled-continuous" || flow === "scrolled") {
          this.updateAxis("vertical");
        } else {
          this.updateAxis("horizontal");
        }
        this.viewSettings.flow = flow;
        if (!this.settings.overflow) {
          this.overflow = isPaginated ? "hidden" : defaultScrolledOverflow;
        } else {
          this.overflow = this.settings.overflow;
        }
        this.stage && this.stage.overflow(this.overflow);
        this.updateLayout();
      }
      getContents() {
        var contents = [];
        if (!this.views) {
          return contents;
        }
        this.views.forEach(function(view) {
          const viewContents = view && view.contents;
          if (viewContents) {
            contents.push(viewContents);
          }
        });
        return contents;
      }
      direction(dir = "ltr") {
        this.settings.direction = dir;
        this.stage && this.stage.direction(dir);
        this.viewSettings.direction = dir;
        this.updateLayout();
      }
      isRendered() {
        return this.rendered;
      }
    };
    (0, _eventEmitter.default)(DefaultViewManager.prototype);
    var _default = DefaultViewManager;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/helpers/snap.js
var require_snap = __commonJS({
  "node_modules/epubjs/lib/managers/helpers/snap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _constants = require_constants();
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PI_D2 = Math.PI / 2;
    var EASING_EQUATIONS = {
      easeOutSine: function(pos) {
        return Math.sin(pos * PI_D2);
      },
      easeInOutSine: function(pos) {
        return -0.5 * (Math.cos(Math.PI * pos) - 1);
      },
      easeInOutQuint: function(pos) {
        if ((pos /= 0.5) < 1) {
          return 0.5 * Math.pow(pos, 5);
        }
        return 0.5 * (Math.pow(pos - 2, 5) + 2);
      },
      easeInCubic: function(pos) {
        return Math.pow(pos, 3);
      }
    };
    var Snap = class {
      constructor(manager, options) {
        this.settings = (0, _core.extend)({
          duration: 80,
          minVelocity: 0.2,
          minDistance: 10,
          easing: EASING_EQUATIONS["easeInCubic"]
        }, options || {});
        this.supportsTouch = this.supportsTouch();
        if (this.supportsTouch) {
          this.setup(manager);
        }
      }
      setup(manager) {
        this.manager = manager;
        this.layout = this.manager.layout;
        this.fullsize = this.manager.settings.fullsize;
        if (this.fullsize) {
          this.element = this.manager.stage.element;
          this.scroller = window;
          this.disableScroll();
        } else {
          this.element = this.manager.stage.container;
          this.scroller = this.element;
          this.element.style["WebkitOverflowScrolling"] = "touch";
        }
        this.manager.settings.offset = this.layout.width;
        this.manager.settings.afterScrolledTimeout = this.settings.duration * 2;
        this.isVertical = this.manager.settings.axis === "vertical";
        if (!this.manager.isPaginated || this.isVertical) {
          return;
        }
        this.touchCanceler = false;
        this.resizeCanceler = false;
        this.snapping = false;
        this.scrollLeft;
        this.scrollTop;
        this.startTouchX = void 0;
        this.startTouchY = void 0;
        this.startTime = void 0;
        this.endTouchX = void 0;
        this.endTouchY = void 0;
        this.endTime = void 0;
        this.addListeners();
      }
      supportsTouch() {
        if ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) {
          return true;
        }
        return false;
      }
      disableScroll() {
        this.element.style.overflow = "hidden";
      }
      enableScroll() {
        this.element.style.overflow = "";
      }
      addListeners() {
        this._onResize = this.onResize.bind(this);
        window.addEventListener("resize", this._onResize);
        this._onScroll = this.onScroll.bind(this);
        this.scroller.addEventListener("scroll", this._onScroll);
        this._onTouchStart = this.onTouchStart.bind(this);
        this.scroller.addEventListener("touchstart", this._onTouchStart, {
          passive: true
        });
        this.on("touchstart", this._onTouchStart);
        this._onTouchMove = this.onTouchMove.bind(this);
        this.scroller.addEventListener("touchmove", this._onTouchMove, {
          passive: true
        });
        this.on("touchmove", this._onTouchMove);
        this._onTouchEnd = this.onTouchEnd.bind(this);
        this.scroller.addEventListener("touchend", this._onTouchEnd, {
          passive: true
        });
        this.on("touchend", this._onTouchEnd);
        this._afterDisplayed = this.afterDisplayed.bind(this);
        this.manager.on(_constants.EVENTS.MANAGERS.ADDED, this._afterDisplayed);
      }
      removeListeners() {
        window.removeEventListener("resize", this._onResize);
        this._onResize = void 0;
        this.scroller.removeEventListener("scroll", this._onScroll);
        this._onScroll = void 0;
        this.scroller.removeEventListener("touchstart", this._onTouchStart, {
          passive: true
        });
        this.off("touchstart", this._onTouchStart);
        this._onTouchStart = void 0;
        this.scroller.removeEventListener("touchmove", this._onTouchMove, {
          passive: true
        });
        this.off("touchmove", this._onTouchMove);
        this._onTouchMove = void 0;
        this.scroller.removeEventListener("touchend", this._onTouchEnd, {
          passive: true
        });
        this.off("touchend", this._onTouchEnd);
        this._onTouchEnd = void 0;
        this.manager.off(_constants.EVENTS.MANAGERS.ADDED, this._afterDisplayed);
        this._afterDisplayed = void 0;
      }
      afterDisplayed(view) {
        let contents = view.contents;
        ["touchstart", "touchmove", "touchend"].forEach((e) => {
          contents.on(e, (ev) => this.triggerViewEvent(ev, contents));
        });
      }
      triggerViewEvent(e, contents) {
        this.emit(e.type, e, contents);
      }
      onScroll(e) {
        this.scrollLeft = this.fullsize ? window.scrollX : this.scroller.scrollLeft;
        this.scrollTop = this.fullsize ? window.scrollY : this.scroller.scrollTop;
      }
      onResize(e) {
        this.resizeCanceler = true;
      }
      onTouchStart(e) {
        let {
          screenX,
          screenY
        } = e.touches[0];
        if (this.fullsize) {
          this.enableScroll();
        }
        this.touchCanceler = true;
        if (!this.startTouchX) {
          this.startTouchX = screenX;
          this.startTouchY = screenY;
          this.startTime = this.now();
        }
        this.endTouchX = screenX;
        this.endTouchY = screenY;
        this.endTime = this.now();
      }
      onTouchMove(e) {
        let {
          screenX,
          screenY
        } = e.touches[0];
        let deltaY = Math.abs(screenY - this.endTouchY);
        this.touchCanceler = true;
        if (!this.fullsize && deltaY < 10) {
          this.element.scrollLeft -= screenX - this.endTouchX;
        }
        this.endTouchX = screenX;
        this.endTouchY = screenY;
        this.endTime = this.now();
      }
      onTouchEnd(e) {
        if (this.fullsize) {
          this.disableScroll();
        }
        this.touchCanceler = false;
        let swipped = this.wasSwiped();
        if (swipped !== 0) {
          this.snap(swipped);
        } else {
          this.snap();
        }
        this.startTouchX = void 0;
        this.startTouchY = void 0;
        this.startTime = void 0;
        this.endTouchX = void 0;
        this.endTouchY = void 0;
        this.endTime = void 0;
      }
      wasSwiped() {
        let snapWidth = this.layout.pageWidth * this.layout.divisor;
        let distance = this.endTouchX - this.startTouchX;
        let absolute = Math.abs(distance);
        let time = this.endTime - this.startTime;
        let velocity = distance / time;
        let minVelocity = this.settings.minVelocity;
        if (absolute <= this.settings.minDistance || absolute >= snapWidth) {
          return 0;
        }
        if (velocity > minVelocity) {
          return -1;
        } else if (velocity < -minVelocity) {
          return 1;
        }
      }
      needsSnap() {
        let left = this.scrollLeft;
        let snapWidth = this.layout.pageWidth * this.layout.divisor;
        return left % snapWidth !== 0;
      }
      snap(howMany = 0) {
        let left = this.scrollLeft;
        let snapWidth = this.layout.pageWidth * this.layout.divisor;
        let snapTo = Math.round(left / snapWidth) * snapWidth;
        if (howMany) {
          snapTo += howMany * snapWidth;
        }
        return this.smoothScrollTo(snapTo);
      }
      smoothScrollTo(destination) {
        const deferred = new _core.defer();
        const start = this.scrollLeft;
        const startTime = this.now();
        const duration = this.settings.duration;
        const easing = this.settings.easing;
        this.snapping = true;
        function tick() {
          const now = this.now();
          const time = Math.min(1, (now - startTime) / duration);
          const timeFunction = easing(time);
          if (this.touchCanceler || this.resizeCanceler) {
            this.resizeCanceler = false;
            this.snapping = false;
            deferred.resolve();
            return;
          }
          if (time < 1) {
            window.requestAnimationFrame(tick.bind(this));
            this.scrollTo(start + (destination - start) * time, 0);
          } else {
            this.scrollTo(destination, 0);
            this.snapping = false;
            deferred.resolve();
          }
        }
        tick.call(this);
        return deferred.promise;
      }
      scrollTo(left = 0, top = 0) {
        if (this.fullsize) {
          window.scroll(left, top);
        } else {
          this.scroller.scrollLeft = left;
          this.scroller.scrollTop = top;
        }
      }
      now() {
        return "now" in window.performance ? performance.now() : (/* @__PURE__ */ new Date()).getTime();
      }
      destroy() {
        if (!this.scroller) {
          return;
        }
        if (this.fullsize) {
          this.enableScroll();
        }
        this.removeListeners();
        this.scroller = void 0;
      }
    };
    (0, _eventEmitter.default)(Snap.prototype);
    var _default = Snap;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/managers/continuous/index.js
var require_continuous = __commonJS({
  "node_modules/epubjs/lib/managers/continuous/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _default2 = _interopRequireDefault(require_default());
    var _snap = _interopRequireDefault(require_snap());
    var _constants = require_constants();
    var _debounce = _interopRequireDefault(require_debounce());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ContinuousViewManager = class extends _default2.default {
      constructor(options) {
        super(options);
        this.name = "continuous";
        this.settings = (0, _core.extend)(this.settings || {}, {
          infinite: true,
          overflow: void 0,
          axis: void 0,
          writingMode: void 0,
          flow: "scrolled",
          offset: 500,
          offsetDelta: 250,
          width: void 0,
          height: void 0,
          snap: false,
          afterScrolledTimeout: 10,
          allowScriptedContent: false,
          allowPopups: false
        });
        (0, _core.extend)(this.settings, options.settings || {});
        if (options.settings.gap != "undefined" && options.settings.gap === 0) {
          this.settings.gap = options.settings.gap;
        }
        this.viewSettings = {
          ignoreClass: this.settings.ignoreClass,
          axis: this.settings.axis,
          flow: this.settings.flow,
          layout: this.layout,
          width: 0,
          height: 0,
          forceEvenPages: false,
          allowScriptedContent: this.settings.allowScriptedContent,
          allowPopups: this.settings.allowPopups
        };
        this.scrollTop = 0;
        this.scrollLeft = 0;
      }
      display(section, target) {
        return _default2.default.prototype.display.call(this, section, target).then((function() {
          return this.fill();
        }).bind(this));
      }
      fill(_full) {
        var full = _full || new _core.defer();
        this.q.enqueue(() => {
          return this.check();
        }).then((result) => {
          if (result) {
            this.fill(full);
          } else {
            full.resolve();
          }
        });
        return full.promise;
      }
      moveTo(offset) {
        var distX = 0, distY = 0;
        var offsetX = 0, offsetY = 0;
        if (!this.isPaginated) {
          distY = offset.top;
          offsetY = offset.top + this.settings.offsetDelta;
        } else {
          distX = Math.floor(offset.left / this.layout.delta) * this.layout.delta;
          offsetX = distX + this.settings.offsetDelta;
        }
        if (distX > 0 || distY > 0) {
          this.scrollBy(distX, distY, true);
        }
      }
      afterResized(view) {
        this.emit(_constants.EVENTS.MANAGERS.RESIZE, view.section);
      }
      // Remove Previous Listeners if present
      removeShownListeners(view) {
        view.onDisplayed = function() {
        };
      }
      add(section) {
        var view = this.createView(section);
        this.views.append(view);
        view.on(_constants.EVENTS.VIEWS.RESIZED, (bounds) => {
          view.expanded = true;
        });
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        view.onDisplayed = this.afterDisplayed.bind(this);
        view.onResize = this.afterResized.bind(this);
        return view.display(this.request);
      }
      append(section) {
        var view = this.createView(section);
        view.on(_constants.EVENTS.VIEWS.RESIZED, (bounds) => {
          view.expanded = true;
        });
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        this.views.append(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        return view;
      }
      prepend(section) {
        var view = this.createView(section);
        view.on(_constants.EVENTS.VIEWS.RESIZED, (bounds) => {
          this.counter(bounds);
          view.expanded = true;
        });
        view.on(_constants.EVENTS.VIEWS.AXIS, (axis) => {
          this.updateAxis(axis);
        });
        view.on(_constants.EVENTS.VIEWS.WRITING_MODE, (mode) => {
          this.updateWritingMode(mode);
        });
        this.views.prepend(view);
        view.onDisplayed = this.afterDisplayed.bind(this);
        return view;
      }
      counter(bounds) {
        if (this.settings.axis === "vertical") {
          this.scrollBy(0, bounds.heightDelta, true);
        } else {
          this.scrollBy(bounds.widthDelta, 0, true);
        }
      }
      update(_offset) {
        var container = this.bounds();
        var views = this.views.all();
        var viewsLength = views.length;
        var visible = [];
        var offset = typeof _offset != "undefined" ? _offset : this.settings.offset || 0;
        var isVisible;
        var view;
        var updating = new _core.defer();
        var promises = [];
        for (var i = 0; i < viewsLength; i++) {
          view = views[i];
          isVisible = this.isVisible(view, offset, offset, container);
          if (isVisible === true) {
            if (!view.displayed) {
              let displayed = view.display(this.request).then(function(view2) {
                view2.show();
              }, (err) => {
                view.hide();
              });
              promises.push(displayed);
            } else {
              view.show();
            }
            visible.push(view);
          } else {
            this.q.enqueue(view.destroy.bind(view));
            clearTimeout(this.trimTimeout);
            this.trimTimeout = setTimeout((function() {
              this.q.enqueue(this.trim.bind(this));
            }).bind(this), 250);
          }
        }
        if (promises.length) {
          return Promise.all(promises).catch((err) => {
            updating.reject(err);
          });
        } else {
          updating.resolve();
          return updating.promise;
        }
      }
      check(_offsetLeft, _offsetTop) {
        var checking = new _core.defer();
        var newViews = [];
        var horizontal = this.settings.axis === "horizontal";
        var delta = this.settings.offset || 0;
        if (_offsetLeft && horizontal) {
          delta = _offsetLeft;
        }
        if (_offsetTop && !horizontal) {
          delta = _offsetTop;
        }
        var bounds = this._bounds;
        let offset = horizontal ? this.scrollLeft : this.scrollTop;
        let visibleLength = horizontal ? Math.floor(bounds.width) : bounds.height;
        let contentLength = horizontal ? this.container.scrollWidth : this.container.scrollHeight;
        let writingMode = this.writingMode && this.writingMode.indexOf("vertical") === 0 ? "vertical" : "horizontal";
        let rtlScrollType = this.settings.rtlScrollType;
        let rtl = this.settings.direction === "rtl";
        if (!this.settings.fullsize) {
          if (rtl && rtlScrollType === "default" && writingMode === "horizontal") {
            offset = contentLength - visibleLength - offset;
          }
          if (rtl && rtlScrollType === "negative" && writingMode === "horizontal") {
            offset = offset * -1;
          }
        } else {
          if (horizontal && rtl && rtlScrollType === "negative" || !horizontal && rtl && rtlScrollType === "default") {
            offset = offset * -1;
          }
        }
        let prepend = () => {
          let first = this.views.first();
          let prev = first && first.section.prev();
          if (prev) {
            newViews.push(this.prepend(prev));
          }
        };
        let append = () => {
          let last = this.views.last();
          let next = last && last.section.next();
          if (next) {
            newViews.push(this.append(next));
          }
        };
        let end = offset + visibleLength + delta;
        let start = offset - delta;
        if (end >= contentLength) {
          append();
        }
        if (start < 0) {
          prepend();
        }
        let promises = newViews.map((view) => {
          return view.display(this.request);
        });
        if (newViews.length) {
          return Promise.all(promises).then(() => {
            return this.check();
          }).then(() => {
            return this.update(delta);
          }, (err) => {
            return err;
          });
        } else {
          this.q.enqueue((function() {
            this.update();
          }).bind(this));
          checking.resolve(false);
          return checking.promise;
        }
      }
      trim() {
        var task = new _core.defer();
        var displayed = this.views.displayed();
        var first = displayed[0];
        var last = displayed[displayed.length - 1];
        var firstIndex = this.views.indexOf(first);
        var lastIndex = this.views.indexOf(last);
        var above = this.views.slice(0, firstIndex);
        var below = this.views.slice(lastIndex + 1);
        for (var i = 0; i < above.length - 1; i++) {
          this.erase(above[i], above);
        }
        for (var j = 1; j < below.length; j++) {
          this.erase(below[j]);
        }
        task.resolve();
        return task.promise;
      }
      erase(view, above) {
        var prevTop;
        var prevLeft;
        if (!this.settings.fullsize) {
          prevTop = this.container.scrollTop;
          prevLeft = this.container.scrollLeft;
        } else {
          prevTop = window.scrollY;
          prevLeft = window.scrollX;
        }
        var bounds = view.bounds();
        this.views.remove(view);
        if (above) {
          if (this.settings.axis === "vertical") {
            this.scrollTo(0, prevTop - bounds.height, true);
          } else {
            if (this.settings.direction === "rtl") {
              if (!this.settings.fullsize) {
                this.scrollTo(prevLeft, 0, true);
              } else {
                this.scrollTo(prevLeft + Math.floor(bounds.width), 0, true);
              }
            } else {
              this.scrollTo(prevLeft - Math.floor(bounds.width), 0, true);
            }
          }
        }
      }
      addEventListeners(stage) {
        window.addEventListener("unload", (function(e) {
          this.ignore = true;
          this.destroy();
        }).bind(this));
        this.addScrollListeners();
        if (this.isPaginated && this.settings.snap) {
          this.snapper = new _snap.default(this, this.settings.snap && typeof this.settings.snap === "object" && this.settings.snap);
        }
      }
      addScrollListeners() {
        var scroller;
        this.tick = _core.requestAnimationFrame;
        let dir = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
        this.scrollDeltaVert = 0;
        this.scrollDeltaHorz = 0;
        if (!this.settings.fullsize) {
          scroller = this.container;
          this.scrollTop = this.container.scrollTop;
          this.scrollLeft = this.container.scrollLeft;
        } else {
          scroller = window;
          this.scrollTop = window.scrollY * dir;
          this.scrollLeft = window.scrollX * dir;
        }
        this._onScroll = this.onScroll.bind(this);
        scroller.addEventListener("scroll", this._onScroll);
        this._scrolled = (0, _debounce.default)(this.scrolled.bind(this), 30);
        this.didScroll = false;
      }
      removeEventListeners() {
        var scroller;
        if (!this.settings.fullsize) {
          scroller = this.container;
        } else {
          scroller = window;
        }
        scroller.removeEventListener("scroll", this._onScroll);
        this._onScroll = void 0;
      }
      onScroll() {
        let scrollTop;
        let scrollLeft;
        let dir = this.settings.direction === "rtl" && this.settings.rtlScrollType === "default" ? -1 : 1;
        if (!this.settings.fullsize) {
          scrollTop = this.container.scrollTop;
          scrollLeft = this.container.scrollLeft;
        } else {
          scrollTop = window.scrollY * dir;
          scrollLeft = window.scrollX * dir;
        }
        this.scrollTop = scrollTop;
        this.scrollLeft = scrollLeft;
        if (!this.ignore) {
          this._scrolled();
        } else {
          this.ignore = false;
        }
        this.scrollDeltaVert += Math.abs(scrollTop - this.prevScrollTop);
        this.scrollDeltaHorz += Math.abs(scrollLeft - this.prevScrollLeft);
        this.prevScrollTop = scrollTop;
        this.prevScrollLeft = scrollLeft;
        clearTimeout(this.scrollTimeout);
        this.scrollTimeout = setTimeout((function() {
          this.scrollDeltaVert = 0;
          this.scrollDeltaHorz = 0;
        }).bind(this), 150);
        clearTimeout(this.afterScrolled);
        this.didScroll = false;
      }
      scrolled() {
        this.q.enqueue((function() {
          return this.check();
        }).bind(this));
        this.emit(_constants.EVENTS.MANAGERS.SCROLL, {
          top: this.scrollTop,
          left: this.scrollLeft
        });
        clearTimeout(this.afterScrolled);
        this.afterScrolled = setTimeout((function() {
          if (this.snapper && this.snapper.supportsTouch && this.snapper.needsSnap()) {
            return;
          }
          this.emit(_constants.EVENTS.MANAGERS.SCROLLED, {
            top: this.scrollTop,
            left: this.scrollLeft
          });
        }).bind(this), this.settings.afterScrolledTimeout);
      }
      next() {
        let delta = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
        if (!this.views.length) return;
        if (this.isPaginated && this.settings.axis === "horizontal") {
          this.scrollBy(delta, 0, true);
        } else {
          this.scrollBy(0, this.layout.height, true);
        }
        this.q.enqueue((function() {
          return this.check();
        }).bind(this));
      }
      prev() {
        let delta = this.layout.props.name === "pre-paginated" && this.layout.props.spread ? this.layout.props.delta * 2 : this.layout.props.delta;
        if (!this.views.length) return;
        if (this.isPaginated && this.settings.axis === "horizontal") {
          this.scrollBy(-delta, 0, true);
        } else {
          this.scrollBy(0, -this.layout.height, true);
        }
        this.q.enqueue((function() {
          return this.check();
        }).bind(this));
      }
      updateFlow(flow) {
        if (this.rendered && this.snapper) {
          this.snapper.destroy();
          this.snapper = void 0;
        }
        super.updateFlow(flow, "scroll");
        if (this.rendered && this.isPaginated && this.settings.snap) {
          this.snapper = new _snap.default(this, this.settings.snap && typeof this.settings.snap === "object" && this.settings.snap);
        }
      }
      destroy() {
        super.destroy();
        if (this.snapper) {
          this.snapper.destroy();
        }
      }
    };
    var _default = ContinuousViewManager;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/rendition.js
var require_rendition = __commonJS({
  "node_modules/epubjs/lib/rendition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _hook = _interopRequireDefault(require_hook());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _queue = _interopRequireDefault(require_queue());
    var _layout = _interopRequireDefault(require_layout());
    var _themes = _interopRequireDefault(require_themes());
    var _contents = _interopRequireDefault(require_contents());
    var _annotations = _interopRequireDefault(require_annotations());
    var _constants = require_constants();
    var _iframe = _interopRequireDefault(require_iframe());
    var _index = _interopRequireDefault(require_default());
    var _index2 = _interopRequireDefault(require_continuous());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Rendition = class {
      constructor(book, options) {
        this.settings = (0, _core.extend)(this.settings || {}, {
          width: null,
          height: null,
          ignoreClass: "",
          manager: "default",
          view: "iframe",
          flow: null,
          layout: null,
          spread: null,
          minSpreadWidth: 800,
          stylesheet: null,
          resizeOnOrientationChange: true,
          script: null,
          snap: false,
          defaultDirection: "ltr",
          allowScriptedContent: false,
          allowPopups: false
        });
        (0, _core.extend)(this.settings, options);
        if (typeof this.settings.manager === "object") {
          this.manager = this.settings.manager;
        }
        this.book = book;
        this.hooks = {};
        this.hooks.display = new _hook.default(this);
        this.hooks.serialize = new _hook.default(this);
        this.hooks.content = new _hook.default(this);
        this.hooks.unloaded = new _hook.default(this);
        this.hooks.layout = new _hook.default(this);
        this.hooks.render = new _hook.default(this);
        this.hooks.show = new _hook.default(this);
        this.hooks.content.register(this.handleLinks.bind(this));
        this.hooks.content.register(this.passEvents.bind(this));
        this.hooks.content.register(this.adjustImages.bind(this));
        this.book.spine.hooks.content.register(this.injectIdentifier.bind(this));
        if (this.settings.stylesheet) {
          this.book.spine.hooks.content.register(this.injectStylesheet.bind(this));
        }
        if (this.settings.script) {
          this.book.spine.hooks.content.register(this.injectScript.bind(this));
        }
        this.themes = new _themes.default(this);
        this.annotations = new _annotations.default(this);
        this.epubcfi = new _epubcfi.default();
        this.q = new _queue.default(this);
        this.location = void 0;
        this.q.enqueue(this.book.opened);
        this.starting = new _core.defer();
        this.started = this.starting.promise;
        this.q.enqueue(this.start);
      }
      /**
       * Set the manager function
       * @param {function} manager
       */
      setManager(manager) {
        this.manager = manager;
      }
      /**
       * Require the manager from passed string, or as a class function
       * @param  {string|object} manager [description]
       * @return {method}
       */
      requireManager(manager) {
        var viewManager;
        if (typeof manager === "string" && manager === "default") {
          viewManager = _index.default;
        } else if (typeof manager === "string" && manager === "continuous") {
          viewManager = _index2.default;
        } else {
          viewManager = manager;
        }
        return viewManager;
      }
      /**
       * Require the view from passed string, or as a class function
       * @param  {string|object} view
       * @return {view}
       */
      requireView(view) {
        var View;
        if (typeof view == "string" && view === "iframe") {
          View = _iframe.default;
        } else {
          View = view;
        }
        return View;
      }
      /**
       * Start the rendering
       * @return {Promise} rendering has started
       */
      start() {
        if (!this.settings.layout && (this.book.package.metadata.layout === "pre-paginated" || this.book.displayOptions.fixedLayout === "true")) {
          this.settings.layout = "pre-paginated";
        }
        switch (this.book.package.metadata.spread) {
          case "none":
            this.settings.spread = "none";
            break;
          case "both":
            this.settings.spread = true;
            break;
        }
        if (!this.manager) {
          this.ViewManager = this.requireManager(this.settings.manager);
          this.View = this.requireView(this.settings.view);
          this.manager = new this.ViewManager({
            view: this.View,
            queue: this.q,
            request: this.book.load.bind(this.book),
            settings: this.settings
          });
        }
        this.direction(this.book.package.metadata.direction || this.settings.defaultDirection);
        this.settings.globalLayoutProperties = this.determineLayoutProperties(this.book.package.metadata);
        this.flow(this.settings.globalLayoutProperties.flow);
        this.layout(this.settings.globalLayoutProperties);
        this.manager.on(_constants.EVENTS.MANAGERS.ADDED, this.afterDisplayed.bind(this));
        this.manager.on(_constants.EVENTS.MANAGERS.REMOVED, this.afterRemoved.bind(this));
        this.manager.on(_constants.EVENTS.MANAGERS.RESIZED, this.onResized.bind(this));
        this.manager.on(_constants.EVENTS.MANAGERS.ORIENTATION_CHANGE, this.onOrientationChange.bind(this));
        this.manager.on(_constants.EVENTS.MANAGERS.SCROLLED, this.reportLocation.bind(this));
        this.emit(_constants.EVENTS.RENDITION.STARTED);
        this.starting.resolve();
      }
      /**
       * Call to attach the container to an element in the dom
       * Container must be attached before rendering can begin
       * @param  {element} element to attach to
       * @return {Promise}
       */
      attachTo(element) {
        return this.q.enqueue((function() {
          this.manager.render(element, {
            "width": this.settings.width,
            "height": this.settings.height
          });
          this.emit(_constants.EVENTS.RENDITION.ATTACHED);
        }).bind(this));
      }
      /**
       * Display a point in the book
       * The request will be added to the rendering Queue,
       * so it will wait until book is opened, rendering started
       * and all other rendering tasks have finished to be called.
       * @param  {string} target Url or EpubCFI
       * @return {Promise}
       */
      display(target) {
        if (this.displaying) {
          this.displaying.resolve();
        }
        return this.q.enqueue(this._display, target);
      }
      /**
       * Tells the manager what to display immediately
       * @private
       * @param  {string} target Url or EpubCFI
       * @return {Promise}
       */
      _display(target) {
        if (!this.book) {
          return;
        }
        var isCfiString = this.epubcfi.isCfiString(target);
        var displaying = new _core.defer();
        var displayed = displaying.promise;
        var section;
        var moveTo;
        this.displaying = displaying;
        if (this.book.locations.length() && (0, _core.isFloat)(target)) {
          target = this.book.locations.cfiFromPercentage(parseFloat(target));
        }
        section = this.book.spine.get(target);
        if (!section) {
          displaying.reject(new Error("No Section Found"));
          return displayed;
        }
        this.manager.display(section, target).then(() => {
          displaying.resolve(section);
          this.displaying = void 0;
          this.emit(_constants.EVENTS.RENDITION.DISPLAYED, section);
          this.reportLocation();
        }, (err) => {
          this.emit(_constants.EVENTS.RENDITION.DISPLAY_ERROR, err);
        });
        return displayed;
      }
      /*
      render(view, show) {
      		// view.onLayout = this.layout.format.bind(this.layout);
      	view.create();
      		// Fit to size of the container, apply padding
      	this.manager.resizeView(view);
      		// Render Chain
      	return view.section.render(this.book.request)
      		.then(function(contents){
      			return view.load(contents);
      		}.bind(this))
      		.then(function(doc){
      			return this.hooks.content.trigger(view, this);
      		}.bind(this))
      		.then(function(){
      			this.layout.format(view.contents);
      			return this.hooks.layout.trigger(view, this);
      		}.bind(this))
      		.then(function(){
      			return view.display();
      		}.bind(this))
      		.then(function(){
      			return this.hooks.render.trigger(view, this);
      		}.bind(this))
      		.then(function(){
      			if(show !== false) {
      				this.q.enqueue(function(view){
      					view.show();
      				}, view);
      			}
      			// this.map = new Map(view, this.layout);
      			this.hooks.show.trigger(view, this);
      			this.trigger("rendered", view.section);
      			}.bind(this))
      		.catch(function(e){
      			this.trigger("loaderror", e);
      		}.bind(this));
      	}
      */
      /**
       * Report what section has been displayed
       * @private
       * @param  {*} view
       */
      afterDisplayed(view) {
        view.on(_constants.EVENTS.VIEWS.MARK_CLICKED, (cfiRange, data) => this.triggerMarkEvent(cfiRange, data, view.contents));
        this.hooks.render.trigger(view, this).then(() => {
          if (view.contents) {
            this.hooks.content.trigger(view.contents, this).then(() => {
              this.emit(_constants.EVENTS.RENDITION.RENDERED, view.section, view);
            });
          } else {
            this.emit(_constants.EVENTS.RENDITION.RENDERED, view.section, view);
          }
        });
      }
      /**
       * Report what has been removed
       * @private
       * @param  {*} view
       */
      afterRemoved(view) {
        this.hooks.unloaded.trigger(view, this).then(() => {
          this.emit(_constants.EVENTS.RENDITION.REMOVED, view.section, view);
        });
      }
      /**
       * Report resize events and display the last seen location
       * @private
       */
      onResized(size, epubcfi) {
        this.emit(_constants.EVENTS.RENDITION.RESIZED, {
          width: size.width,
          height: size.height
        }, epubcfi);
        if (this.location && this.location.start) {
          this.display(epubcfi || this.location.start.cfi);
        }
      }
      /**
       * Report orientation events and display the last seen location
       * @private
       */
      onOrientationChange(orientation) {
        this.emit(_constants.EVENTS.RENDITION.ORIENTATION_CHANGE, orientation);
      }
      /**
       * Move the Rendition to a specific offset
       * Usually you would be better off calling display()
       * @param {object} offset
       */
      moveTo(offset) {
        this.manager.moveTo(offset);
      }
      /**
       * Trigger a resize of the views
       * @param {number} [width]
       * @param {number} [height]
       * @param {string} [epubcfi] (optional)
       */
      resize(width, height, epubcfi) {
        if (width) {
          this.settings.width = width;
        }
        if (height) {
          this.settings.height = height;
        }
        this.manager.resize(width, height, epubcfi);
      }
      /**
       * Clear all rendered views
       */
      clear() {
        this.manager.clear();
      }
      /**
       * Go to the next "page" in the rendition
       * @return {Promise}
       */
      next() {
        return this.q.enqueue(this.manager.next.bind(this.manager)).then(this.reportLocation.bind(this));
      }
      /**
       * Go to the previous "page" in the rendition
       * @return {Promise}
       */
      prev() {
        return this.q.enqueue(this.manager.prev.bind(this.manager)).then(this.reportLocation.bind(this));
      }
      //-- http://www.idpf.org/epub/301/spec/epub-publications.html#meta-properties-rendering
      /**
       * Determine the Layout properties from metadata and settings
       * @private
       * @param  {object} metadata
       * @return {object} properties
       */
      determineLayoutProperties(metadata) {
        var properties;
        var layout = this.settings.layout || metadata.layout || "reflowable";
        var spread = this.settings.spread || metadata.spread || "auto";
        var orientation = this.settings.orientation || metadata.orientation || "auto";
        var flow = this.settings.flow || metadata.flow || "auto";
        var viewport = metadata.viewport || "";
        var minSpreadWidth = this.settings.minSpreadWidth || metadata.minSpreadWidth || 800;
        var direction = this.settings.direction || metadata.direction || "ltr";
        if ((this.settings.width === 0 || this.settings.width > 0) && (this.settings.height === 0 || this.settings.height > 0)) {
        }
        properties = {
          layout,
          spread,
          orientation,
          flow,
          viewport,
          minSpreadWidth,
          direction
        };
        return properties;
      }
      /**
       * Adjust the flow of the rendition to paginated or scrolled
       * (scrolled-continuous vs scrolled-doc are handled by different view managers)
       * @param  {string} flow
       */
      flow(flow) {
        var _flow = flow;
        if (flow === "scrolled" || flow === "scrolled-doc" || flow === "scrolled-continuous") {
          _flow = "scrolled";
        }
        if (flow === "auto" || flow === "paginated") {
          _flow = "paginated";
        }
        this.settings.flow = flow;
        if (this._layout) {
          this._layout.flow(_flow);
        }
        if (this.manager && this._layout) {
          this.manager.applyLayout(this._layout);
        }
        if (this.manager) {
          this.manager.updateFlow(_flow);
        }
        if (this.manager && this.manager.isRendered() && this.location) {
          this.manager.clear();
          this.display(this.location.start.cfi);
        }
      }
      /**
       * Adjust the layout of the rendition to reflowable or pre-paginated
       * @param  {object} settings
       */
      layout(settings) {
        if (settings) {
          this._layout = new _layout.default(settings);
          this._layout.spread(settings.spread, this.settings.minSpreadWidth);
          this._layout.on(_constants.EVENTS.LAYOUT.UPDATED, (props, changed) => {
            this.emit(_constants.EVENTS.RENDITION.LAYOUT, props, changed);
          });
        }
        if (this.manager && this._layout) {
          this.manager.applyLayout(this._layout);
        }
        return this._layout;
      }
      /**
       * Adjust if the rendition uses spreads
       * @param  {string} spread none | auto (TODO: implement landscape, portrait, both)
       * @param  {int} [min] min width to use spreads at
       */
      spread(spread, min) {
        this.settings.spread = spread;
        if (min) {
          this.settings.minSpreadWidth = min;
        }
        if (this._layout) {
          this._layout.spread(spread, min);
        }
        if (this.manager && this.manager.isRendered()) {
          this.manager.updateLayout();
        }
      }
      /**
       * Adjust the direction of the rendition
       * @param  {string} dir
       */
      direction(dir) {
        this.settings.direction = dir || "ltr";
        if (this.manager) {
          this.manager.direction(this.settings.direction);
        }
        if (this.manager && this.manager.isRendered() && this.location) {
          this.manager.clear();
          this.display(this.location.start.cfi);
        }
      }
      /**
       * Report the current location
       * @fires relocated
       * @fires locationChanged
       */
      reportLocation() {
        return this.q.enqueue((function reportedLocation() {
          requestAnimationFrame((function reportedLocationAfterRAF() {
            var location = this.manager.currentLocation();
            if (location && location.then && typeof location.then === "function") {
              location.then((function(result) {
                let located = this.located(result);
                if (!located || !located.start || !located.end) {
                  return;
                }
                this.location = located;
                this.emit(_constants.EVENTS.RENDITION.LOCATION_CHANGED, {
                  index: this.location.start.index,
                  href: this.location.start.href,
                  start: this.location.start.cfi,
                  end: this.location.end.cfi,
                  percentage: this.location.start.percentage
                });
                this.emit(_constants.EVENTS.RENDITION.RELOCATED, this.location);
              }).bind(this));
            } else if (location) {
              let located = this.located(location);
              if (!located || !located.start || !located.end) {
                return;
              }
              this.location = located;
              this.emit(_constants.EVENTS.RENDITION.LOCATION_CHANGED, {
                index: this.location.start.index,
                href: this.location.start.href,
                start: this.location.start.cfi,
                end: this.location.end.cfi,
                percentage: this.location.start.percentage
              });
              this.emit(_constants.EVENTS.RENDITION.RELOCATED, this.location);
            }
          }).bind(this));
        }).bind(this));
      }
      /**
       * Get the Current Location object
       * @return {displayedLocation | promise} location (may be a promise)
       */
      currentLocation() {
        var location = this.manager.currentLocation();
        if (location && location.then && typeof location.then === "function") {
          location.then((function(result) {
            let located = this.located(result);
            return located;
          }).bind(this));
        } else if (location) {
          let located = this.located(location);
          return located;
        }
      }
      /**
       * Creates a Rendition#locationRange from location
       * passed by the Manager
       * @returns {displayedLocation}
       * @private
       */
      located(location) {
        if (!location.length) {
          return {};
        }
        let start = location[0];
        let end = location[location.length - 1];
        let located = {
          start: {
            index: start.index,
            href: start.href,
            cfi: start.mapping.start,
            displayed: {
              page: start.pages[0] || 1,
              total: start.totalPages
            }
          },
          end: {
            index: end.index,
            href: end.href,
            cfi: end.mapping.end,
            displayed: {
              page: end.pages[end.pages.length - 1] || 1,
              total: end.totalPages
            }
          }
        };
        let locationStart = this.book.locations.locationFromCfi(start.mapping.start);
        let locationEnd = this.book.locations.locationFromCfi(end.mapping.end);
        if (locationStart != null) {
          located.start.location = locationStart;
          located.start.percentage = this.book.locations.percentageFromLocation(locationStart);
        }
        if (locationEnd != null) {
          located.end.location = locationEnd;
          located.end.percentage = this.book.locations.percentageFromLocation(locationEnd);
        }
        let pageStart = this.book.pageList.pageFromCfi(start.mapping.start);
        let pageEnd = this.book.pageList.pageFromCfi(end.mapping.end);
        if (pageStart != -1) {
          located.start.page = pageStart;
        }
        if (pageEnd != -1) {
          located.end.page = pageEnd;
        }
        if (end.index === this.book.spine.last().index && located.end.displayed.page >= located.end.displayed.total) {
          located.atEnd = true;
        }
        if (start.index === this.book.spine.first().index && located.start.displayed.page === 1) {
          located.atStart = true;
        }
        return located;
      }
      /**
       * Remove and Clean Up the Rendition
       */
      destroy() {
        this.manager && this.manager.destroy();
        this.book = void 0;
      }
      /**
       * Pass the events from a view's Contents
       * @private
       * @param  {Contents} view contents
       */
      passEvents(contents) {
        _constants.DOM_EVENTS.forEach((e) => {
          contents.on(e, (ev) => this.triggerViewEvent(ev, contents));
        });
        contents.on(_constants.EVENTS.CONTENTS.SELECTED, (e) => this.triggerSelectedEvent(e, contents));
      }
      /**
       * Emit events passed by a view
       * @private
       * @param  {event} e
       */
      triggerViewEvent(e, contents) {
        this.emit(e.type, e, contents);
      }
      /**
       * Emit a selection event's CFI Range passed from a a view
       * @private
       * @param  {string} cfirange
       */
      triggerSelectedEvent(cfirange, contents) {
        this.emit(_constants.EVENTS.RENDITION.SELECTED, cfirange, contents);
      }
      /**
       * Emit a markClicked event with the cfiRange and data from a mark
       * @private
       * @param  {EpubCFI} cfirange
       */
      triggerMarkEvent(cfiRange, data, contents) {
        this.emit(_constants.EVENTS.RENDITION.MARK_CLICKED, cfiRange, data, contents);
      }
      /**
       * Get a Range from a Visible CFI
       * @param  {string} cfi EpubCfi String
       * @param  {string} ignoreClass
       * @return {range}
       */
      getRange(cfi, ignoreClass) {
        var _cfi = new _epubcfi.default(cfi);
        var found = this.manager.visible().filter(function(view) {
          if (_cfi.spinePos === view.index) return true;
        });
        if (found.length) {
          return found[0].contents.range(_cfi, ignoreClass);
        }
      }
      /**
       * Hook to adjust images to fit in columns
       * @param  {Contents} contents
       * @private
       */
      adjustImages(contents) {
        if (this._layout.name === "pre-paginated") {
          return new Promise(function(resolve) {
            resolve();
          });
        }
        let computed = contents.window.getComputedStyle(contents.content, null);
        let height = (contents.content.offsetHeight - (parseFloat(computed.paddingTop) + parseFloat(computed.paddingBottom))) * 0.95;
        let horizontalPadding = parseFloat(computed.paddingLeft) + parseFloat(computed.paddingRight);
        contents.addStylesheetRules({
          "img": {
            "max-width": (this._layout.columnWidth ? this._layout.columnWidth - horizontalPadding + "px" : "100%") + "!important",
            "max-height": height + "px!important",
            "object-fit": "contain",
            "page-break-inside": "avoid",
            "break-inside": "avoid",
            "box-sizing": "border-box"
          },
          "svg": {
            "max-width": (this._layout.columnWidth ? this._layout.columnWidth - horizontalPadding + "px" : "100%") + "!important",
            "max-height": height + "px!important",
            "page-break-inside": "avoid",
            "break-inside": "avoid"
          }
        });
        return new Promise(function(resolve, reject) {
          setTimeout(function() {
            resolve();
          }, 1);
        });
      }
      /**
       * Get the Contents object of each rendered view
       * @returns {Contents[]}
       */
      getContents() {
        return this.manager ? this.manager.getContents() : [];
      }
      /**
       * Get the views member from the manager
       * @returns {Views}
       */
      views() {
        let views = this.manager ? this.manager.views : void 0;
        return views || [];
      }
      /**
       * Hook to handle link clicks in rendered content
       * @param  {Contents} contents
       * @private
       */
      handleLinks(contents) {
        if (contents) {
          contents.on(_constants.EVENTS.CONTENTS.LINK_CLICKED, (href) => {
            let relative = this.book.path.relative(href);
            this.display(relative);
          });
        }
      }
      /**
       * Hook to handle injecting stylesheet before
       * a Section is serialized
       * @param  {document} doc
       * @param  {Section} section
       * @private
       */
      injectStylesheet(doc, section) {
        let style = doc.createElement("link");
        style.setAttribute("type", "text/css");
        style.setAttribute("rel", "stylesheet");
        style.setAttribute("href", this.settings.stylesheet);
        doc.getElementsByTagName("head")[0].appendChild(style);
      }
      /**
       * Hook to handle injecting scripts before
       * a Section is serialized
       * @param  {document} doc
       * @param  {Section} section
       * @private
       */
      injectScript(doc, section) {
        let script = doc.createElement("script");
        script.setAttribute("type", "text/javascript");
        script.setAttribute("src", this.settings.script);
        script.textContent = " ";
        doc.getElementsByTagName("head")[0].appendChild(script);
      }
      /**
       * Hook to handle the document identifier before
       * a Section is serialized
       * @param  {document} doc
       * @param  {Section} section
       * @private
       */
      injectIdentifier(doc, section) {
        let ident = this.book.packaging.metadata.identifier;
        let meta = doc.createElement("meta");
        meta.setAttribute("name", "dc.relation.ispartof");
        if (ident) {
          meta.setAttribute("content", ident);
        }
        doc.getElementsByTagName("head")[0].appendChild(meta);
      }
    };
    (0, _eventEmitter.default)(Rendition.prototype);
    var _default = Rendition;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/archive.js
var require_archive = __commonJS({
  "node_modules/epubjs/lib/archive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _request = _interopRequireDefault(require_request());
    var _mime = _interopRequireDefault(require_mime());
    var _path = _interopRequireDefault(require_path2());
    var _jszip = _interopRequireDefault(require_jszip());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Archive = class {
      constructor() {
        this.zip = void 0;
        this.urlCache = {};
        this.checkRequirements();
      }
      /**
       * Checks to see if JSZip exists in global namspace,
       * Requires JSZip if it isn't there
       * @private
       */
      checkRequirements() {
        try {
          this.zip = new _jszip.default();
        } catch (e) {
          throw new Error("JSZip lib not loaded");
        }
      }
      /**
       * Open an archive
       * @param  {binary} input
       * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
       * @return {Promise} zipfile
       */
      open(input, isBase64) {
        return this.zip.loadAsync(input, {
          "base64": isBase64
        });
      }
      /**
       * Load and Open an archive
       * @param  {string} zipUrl
       * @param  {boolean} [isBase64] tells JSZip if the input data is base64 encoded
       * @return {Promise} zipfile
       */
      openUrl(zipUrl, isBase64) {
        return (0, _request.default)(zipUrl, "binary").then((function(data) {
          return this.zip.loadAsync(data, {
            "base64": isBase64
          });
        }).bind(this));
      }
      /**
       * Request a url from the archive
       * @param  {string} url  a url to request from the archive
       * @param  {string} [type] specify the type of the returned result
       * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
       */
      request(url, type) {
        var deferred = new _core.defer();
        var response;
        var path = new _path.default(url);
        if (!type) {
          type = path.extension;
        }
        if (type == "blob") {
          response = this.getBlob(url);
        } else {
          response = this.getText(url);
        }
        if (response) {
          response.then((function(r) {
            let result = this.handleResponse(r, type);
            deferred.resolve(result);
          }).bind(this));
        } else {
          deferred.reject({
            message: "File not found in the epub: " + url,
            stack: new Error().stack
          });
        }
        return deferred.promise;
      }
      /**
       * Handle the response from request
       * @private
       * @param  {any} response
       * @param  {string} [type]
       * @return {any} the parsed result
       */
      handleResponse(response, type) {
        var r;
        if (type == "json") {
          r = JSON.parse(response);
        } else if ((0, _core.isXml)(type)) {
          r = (0, _core.parse)(response, "text/xml");
        } else if (type == "xhtml") {
          r = (0, _core.parse)(response, "application/xhtml+xml");
        } else if (type == "html" || type == "htm") {
          r = (0, _core.parse)(response, "text/html");
        } else {
          r = response;
        }
        return r;
      }
      /**
       * Get a Blob from Archive by Url
       * @param  {string} url
       * @param  {string} [mimeType]
       * @return {Blob}
       */
      getBlob(url, mimeType) {
        var decodededUrl = window.decodeURIComponent(url.substr(1));
        var entry = this.zip.file(decodededUrl);
        if (entry) {
          mimeType = mimeType || _mime.default.lookup(entry.name);
          return entry.async("uint8array").then(function(uint8array) {
            return new Blob([uint8array], {
              type: mimeType
            });
          });
        }
      }
      /**
       * Get Text from Archive by Url
       * @param  {string} url
       * @param  {string} [encoding]
       * @return {string}
       */
      getText(url, encoding) {
        var decodededUrl = window.decodeURIComponent(url.substr(1));
        var entry = this.zip.file(decodededUrl);
        if (entry) {
          return entry.async("string").then(function(text) {
            return text;
          });
        }
      }
      /**
       * Get a base64 encoded result from Archive by Url
       * @param  {string} url
       * @param  {string} [mimeType]
       * @return {string} base64 encoded
       */
      getBase64(url, mimeType) {
        var decodededUrl = window.decodeURIComponent(url.substr(1));
        var entry = this.zip.file(decodededUrl);
        if (entry) {
          mimeType = mimeType || _mime.default.lookup(entry.name);
          return entry.async("base64").then(function(data) {
            return "data:" + mimeType + ";base64," + data;
          });
        }
      }
      /**
       * Create a Url from an unarchived item
       * @param  {string} url
       * @param  {object} [options.base64] use base64 encoding or blob url
       * @return {Promise} url promise with Url string
       */
      createUrl(url, options) {
        var deferred = new _core.defer();
        var _URL = window.URL || window.webkitURL || window.mozURL;
        var tempUrl;
        var response;
        var useBase64 = options && options.base64;
        if (url in this.urlCache) {
          deferred.resolve(this.urlCache[url]);
          return deferred.promise;
        }
        if (useBase64) {
          response = this.getBase64(url);
          if (response) {
            response.then((function(tempUrl2) {
              this.urlCache[url] = tempUrl2;
              deferred.resolve(tempUrl2);
            }).bind(this));
          }
        } else {
          response = this.getBlob(url);
          if (response) {
            response.then((function(blob) {
              tempUrl = _URL.createObjectURL(blob);
              this.urlCache[url] = tempUrl;
              deferred.resolve(tempUrl);
            }).bind(this));
          }
        }
        if (!response) {
          deferred.reject({
            message: "File not found in the epub: " + url,
            stack: new Error().stack
          });
        }
        return deferred.promise;
      }
      /**
       * Revoke Temp Url for a archive item
       * @param  {string} url url of the item in the archive
       */
      revokeUrl(url) {
        var _URL = window.URL || window.webkitURL || window.mozURL;
        var fromCache = this.urlCache[url];
        if (fromCache) _URL.revokeObjectURL(fromCache);
      }
      destroy() {
        var _URL = window.URL || window.webkitURL || window.mozURL;
        for (let fromCache in this.urlCache) {
          _URL.revokeObjectURL(fromCache);
        }
        this.zip = void 0;
        this.urlCache = {};
      }
    };
    var _default = Archive;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/store.js
var require_store = __commonJS({
  "node_modules/epubjs/lib/store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var _request = _interopRequireDefault(require_request());
    var _mime = _interopRequireDefault(require_mime());
    var _path = _interopRequireDefault(require_path2());
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _localforage = _interopRequireDefault(require_localforage());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Store = class {
      constructor(name, requester, resolver) {
        this.urlCache = {};
        this.storage = void 0;
        this.name = name;
        this.requester = requester || _request.default;
        this.resolver = resolver;
        this.online = true;
        this.checkRequirements();
        this.addListeners();
      }
      /**
       * Checks to see if localForage exists in global namspace,
       * Requires localForage if it isn't there
       * @private
       */
      checkRequirements() {
        try {
          let store;
          if (typeof _localforage.default === "undefined") {
            store = _localforage.default;
          }
          this.storage = store.createInstance({
            name: this.name
          });
        } catch (e) {
          throw new Error("localForage lib not loaded");
        }
      }
      /**
       * Add online and offline event listeners
       * @private
       */
      addListeners() {
        this._status = this.status.bind(this);
        window.addEventListener("online", this._status);
        window.addEventListener("offline", this._status);
      }
      /**
       * Remove online and offline event listeners
       * @private
       */
      removeListeners() {
        window.removeEventListener("online", this._status);
        window.removeEventListener("offline", this._status);
        this._status = void 0;
      }
      /**
       * Update the online / offline status
       * @private
       */
      status(event) {
        let online = navigator.onLine;
        this.online = online;
        if (online) {
          this.emit("online", this);
        } else {
          this.emit("offline", this);
        }
      }
      /**
       * Add all of a book resources to the store
       * @param  {Resources} resources  book resources
       * @param  {boolean} [force] force resaving resources
       * @return {Promise<object>} store objects
       */
      add(resources, force) {
        let mapped = resources.resources.map((item) => {
          let {
            href
          } = item;
          let url = this.resolver(href);
          let encodedUrl = window.encodeURIComponent(url);
          return this.storage.getItem(encodedUrl).then((item2) => {
            if (!item2 || force) {
              return this.requester(url, "binary").then((data) => {
                return this.storage.setItem(encodedUrl, data);
              });
            } else {
              return item2;
            }
          });
        });
        return Promise.all(mapped);
      }
      /**
       * Put binary data from a url to storage
       * @param  {string} url  a url to request from storage
       * @param  {boolean} [withCredentials]
       * @param  {object} [headers]
       * @return {Promise<Blob>}
       */
      put(url, withCredentials, headers) {
        let encodedUrl = window.encodeURIComponent(url);
        return this.storage.getItem(encodedUrl).then((result) => {
          if (!result) {
            return this.requester(url, "binary", withCredentials, headers).then((data) => {
              return this.storage.setItem(encodedUrl, data);
            });
          }
          return result;
        });
      }
      /**
       * Request a url
       * @param  {string} url  a url to request from storage
       * @param  {string} [type] specify the type of the returned result
       * @param  {boolean} [withCredentials]
       * @param  {object} [headers]
       * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
       */
      request(url, type, withCredentials, headers) {
        if (this.online) {
          return this.requester(url, type, withCredentials, headers).then((data) => {
            this.put(url);
            return data;
          });
        } else {
          return this.retrieve(url, type);
        }
      }
      /**
       * Request a url from storage
       * @param  {string} url  a url to request from storage
       * @param  {string} [type] specify the type of the returned result
       * @return {Promise<Blob | string | JSON | Document | XMLDocument>}
       */
      retrieve(url, type) {
        var deferred = new _core.defer();
        var response;
        var path = new _path.default(url);
        if (!type) {
          type = path.extension;
        }
        if (type == "blob") {
          response = this.getBlob(url);
        } else {
          response = this.getText(url);
        }
        return response.then((r) => {
          var deferred2 = new _core.defer();
          var result;
          if (r) {
            result = this.handleResponse(r, type);
            deferred2.resolve(result);
          } else {
            deferred2.reject({
              message: "File not found in storage: " + url,
              stack: new Error().stack
            });
          }
          return deferred2.promise;
        });
      }
      /**
       * Handle the response from request
       * @private
       * @param  {any} response
       * @param  {string} [type]
       * @return {any} the parsed result
       */
      handleResponse(response, type) {
        var r;
        if (type == "json") {
          r = JSON.parse(response);
        } else if ((0, _core.isXml)(type)) {
          r = (0, _core.parse)(response, "text/xml");
        } else if (type == "xhtml") {
          r = (0, _core.parse)(response, "application/xhtml+xml");
        } else if (type == "html" || type == "htm") {
          r = (0, _core.parse)(response, "text/html");
        } else {
          r = response;
        }
        return r;
      }
      /**
       * Get a Blob from Storage by Url
       * @param  {string} url
       * @param  {string} [mimeType]
       * @return {Blob}
       */
      getBlob(url, mimeType) {
        let encodedUrl = window.encodeURIComponent(url);
        return this.storage.getItem(encodedUrl).then(function(uint8array) {
          if (!uint8array) return;
          mimeType = mimeType || _mime.default.lookup(url);
          return new Blob([uint8array], {
            type: mimeType
          });
        });
      }
      /**
       * Get Text from Storage by Url
       * @param  {string} url
       * @param  {string} [mimeType]
       * @return {string}
       */
      getText(url, mimeType) {
        let encodedUrl = window.encodeURIComponent(url);
        mimeType = mimeType || _mime.default.lookup(url);
        return this.storage.getItem(encodedUrl).then(function(uint8array) {
          var deferred = new _core.defer();
          var reader = new FileReader();
          var blob;
          if (!uint8array) return;
          blob = new Blob([uint8array], {
            type: mimeType
          });
          reader.addEventListener("loadend", () => {
            deferred.resolve(reader.result);
          });
          reader.readAsText(blob, mimeType);
          return deferred.promise;
        });
      }
      /**
       * Get a base64 encoded result from Storage by Url
       * @param  {string} url
       * @param  {string} [mimeType]
       * @return {string} base64 encoded
       */
      getBase64(url, mimeType) {
        let encodedUrl = window.encodeURIComponent(url);
        mimeType = mimeType || _mime.default.lookup(url);
        return this.storage.getItem(encodedUrl).then((uint8array) => {
          var deferred = new _core.defer();
          var reader = new FileReader();
          var blob;
          if (!uint8array) return;
          blob = new Blob([uint8array], {
            type: mimeType
          });
          reader.addEventListener("loadend", () => {
            deferred.resolve(reader.result);
          });
          reader.readAsDataURL(blob, mimeType);
          return deferred.promise;
        });
      }
      /**
       * Create a Url from a stored item
       * @param  {string} url
       * @param  {object} [options.base64] use base64 encoding or blob url
       * @return {Promise} url promise with Url string
       */
      createUrl(url, options) {
        var deferred = new _core.defer();
        var _URL = window.URL || window.webkitURL || window.mozURL;
        var tempUrl;
        var response;
        var useBase64 = options && options.base64;
        if (url in this.urlCache) {
          deferred.resolve(this.urlCache[url]);
          return deferred.promise;
        }
        if (useBase64) {
          response = this.getBase64(url);
          if (response) {
            response.then((function(tempUrl2) {
              this.urlCache[url] = tempUrl2;
              deferred.resolve(tempUrl2);
            }).bind(this));
          }
        } else {
          response = this.getBlob(url);
          if (response) {
            response.then((function(blob) {
              tempUrl = _URL.createObjectURL(blob);
              this.urlCache[url] = tempUrl;
              deferred.resolve(tempUrl);
            }).bind(this));
          }
        }
        if (!response) {
          deferred.reject({
            message: "File not found in storage: " + url,
            stack: new Error().stack
          });
        }
        return deferred.promise;
      }
      /**
       * Revoke Temp Url for a archive item
       * @param  {string} url url of the item in the store
       */
      revokeUrl(url) {
        var _URL = window.URL || window.webkitURL || window.mozURL;
        var fromCache = this.urlCache[url];
        if (fromCache) _URL.revokeObjectURL(fromCache);
      }
      destroy() {
        var _URL = window.URL || window.webkitURL || window.mozURL;
        for (let fromCache in this.urlCache) {
          _URL.revokeObjectURL(fromCache);
        }
        this.urlCache = {};
        this.removeListeners();
      }
    };
    (0, _eventEmitter.default)(Store.prototype);
    var _default = Store;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/displayoptions.js
var require_displayoptions = __commonJS({
  "node_modules/epubjs/lib/displayoptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = require_core();
    var DisplayOptions = class {
      constructor(displayOptionsDocument) {
        this.interactive = "";
        this.fixedLayout = "";
        this.openToSpread = "";
        this.orientationLock = "";
        if (displayOptionsDocument) {
          this.parse(displayOptionsDocument);
        }
      }
      /**
       * Parse XML
       * @param  {document} displayOptionsDocument XML
       * @return {DisplayOptions} self
       */
      parse(displayOptionsDocument) {
        if (!displayOptionsDocument) {
          return this;
        }
        const displayOptionsNode = (0, _core.qs)(displayOptionsDocument, "display_options");
        if (!displayOptionsNode) {
          return this;
        }
        const options = (0, _core.qsa)(displayOptionsNode, "option");
        options.forEach((el) => {
          let value = "";
          if (el.childNodes.length) {
            value = el.childNodes[0].nodeValue;
          }
          switch (el.attributes.name.value) {
            case "interactive":
              this.interactive = value;
              break;
            case "fixed-layout":
              this.fixedLayout = value;
              break;
            case "open-to-spread":
              this.openToSpread = value;
              break;
            case "orientation-lock":
              this.orientationLock = value;
              break;
          }
        });
        return this;
      }
      destroy() {
        this.interactive = void 0;
        this.fixedLayout = void 0;
        this.openToSpread = void 0;
        this.orientationLock = void 0;
      }
    };
    var _default = DisplayOptions;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/book.js
var require_book = __commonJS({
  "node_modules/epubjs/lib/book.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _eventEmitter = _interopRequireDefault(require_event_emitter());
    var _core = require_core();
    var _url = _interopRequireDefault(require_url());
    var _path = _interopRequireDefault(require_path2());
    var _spine = _interopRequireDefault(require_spine());
    var _locations = _interopRequireDefault(require_locations());
    var _container = _interopRequireDefault(require_container());
    var _packaging = _interopRequireDefault(require_packaging());
    var _navigation = _interopRequireDefault(require_navigation());
    var _resources = _interopRequireDefault(require_resources());
    var _pagelist = _interopRequireDefault(require_pagelist());
    var _rendition = _interopRequireDefault(require_rendition());
    var _archive = _interopRequireDefault(require_archive());
    var _request2 = _interopRequireDefault(require_request());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _store = _interopRequireDefault(require_store());
    var _displayoptions = _interopRequireDefault(require_displayoptions());
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var CONTAINER_PATH = "META-INF/container.xml";
    var IBOOKS_DISPLAY_OPTIONS_PATH = "META-INF/com.apple.ibooks.display-options.xml";
    var INPUT_TYPE = {
      BINARY: "binary",
      BASE64: "base64",
      EPUB: "epub",
      OPF: "opf",
      MANIFEST: "json",
      DIRECTORY: "directory"
    };
    var Book = class {
      constructor(url, options) {
        if (typeof options === "undefined" && typeof url !== "string" && url instanceof Blob === false && url instanceof ArrayBuffer === false) {
          options = url;
          url = void 0;
        }
        this.settings = (0, _core.extend)(this.settings || {}, {
          requestMethod: void 0,
          requestCredentials: void 0,
          requestHeaders: void 0,
          encoding: void 0,
          replacements: void 0,
          canonical: void 0,
          openAs: void 0,
          store: void 0
        });
        (0, _core.extend)(this.settings, options);
        this.opening = new _core.defer();
        this.opened = this.opening.promise;
        this.isOpen = false;
        this.loading = {
          manifest: new _core.defer(),
          spine: new _core.defer(),
          metadata: new _core.defer(),
          cover: new _core.defer(),
          navigation: new _core.defer(),
          pageList: new _core.defer(),
          resources: new _core.defer(),
          displayOptions: new _core.defer()
        };
        this.loaded = {
          manifest: this.loading.manifest.promise,
          spine: this.loading.spine.promise,
          metadata: this.loading.metadata.promise,
          cover: this.loading.cover.promise,
          navigation: this.loading.navigation.promise,
          pageList: this.loading.pageList.promise,
          resources: this.loading.resources.promise,
          displayOptions: this.loading.displayOptions.promise
        };
        this.ready = Promise.all([this.loaded.manifest, this.loaded.spine, this.loaded.metadata, this.loaded.cover, this.loaded.navigation, this.loaded.resources, this.loaded.displayOptions]);
        this.isRendered = false;
        this.request = this.settings.requestMethod || _request2.default;
        this.spine = new _spine.default();
        this.locations = new _locations.default(this.spine, this.load.bind(this));
        this.navigation = void 0;
        this.pageList = void 0;
        this.url = void 0;
        this.path = void 0;
        this.archived = false;
        this.archive = void 0;
        this.storage = void 0;
        this.resources = void 0;
        this.rendition = void 0;
        this.container = void 0;
        this.packaging = void 0;
        this.displayOptions = void 0;
        if (this.settings.store) {
          this.store(this.settings.store);
        }
        if (url) {
          this.open(url, this.settings.openAs).catch((error) => {
            var err = new Error("Cannot load book at " + url);
            this.emit(_constants.EVENTS.BOOK.OPEN_FAILED, err);
          });
        }
      }
      /**
       * Open a epub or url
       * @param {string | ArrayBuffer} input Url, Path or ArrayBuffer
       * @param {string} [what="binary", "base64", "epub", "opf", "json", "directory"] force opening as a certain type
       * @returns {Promise} of when the book has been loaded
       * @example book.open("/path/to/book.epub")
       */
      open(input, what) {
        var opening;
        var type = what || this.determineType(input);
        if (type === INPUT_TYPE.BINARY) {
          this.archived = true;
          this.url = new _url.default("/", "");
          opening = this.openEpub(input);
        } else if (type === INPUT_TYPE.BASE64) {
          this.archived = true;
          this.url = new _url.default("/", "");
          opening = this.openEpub(input, type);
        } else if (type === INPUT_TYPE.EPUB) {
          this.archived = true;
          this.url = new _url.default("/", "");
          opening = this.request(input, "binary", this.settings.requestCredentials, this.settings.requestHeaders).then(this.openEpub.bind(this));
        } else if (type == INPUT_TYPE.OPF) {
          this.url = new _url.default(input);
          opening = this.openPackaging(this.url.Path.toString());
        } else if (type == INPUT_TYPE.MANIFEST) {
          this.url = new _url.default(input);
          opening = this.openManifest(this.url.Path.toString());
        } else {
          this.url = new _url.default(input);
          opening = this.openContainer(CONTAINER_PATH).then(this.openPackaging.bind(this));
        }
        return opening;
      }
      /**
       * Open an archived epub
       * @private
       * @param  {binary} data
       * @param  {string} [encoding]
       * @return {Promise}
       */
      openEpub(data, encoding) {
        return this.unarchive(data, encoding || this.settings.encoding).then(() => {
          return this.openContainer(CONTAINER_PATH);
        }).then((packagePath) => {
          return this.openPackaging(packagePath);
        });
      }
      /**
       * Open the epub container
       * @private
       * @param  {string} url
       * @return {string} packagePath
       */
      openContainer(url) {
        return this.load(url).then((xml) => {
          this.container = new _container.default(xml);
          return this.resolve(this.container.packagePath);
        });
      }
      /**
       * Open the Open Packaging Format Xml
       * @private
       * @param  {string} url
       * @return {Promise}
       */
      openPackaging(url) {
        this.path = new _path.default(url);
        return this.load(url).then((xml) => {
          this.packaging = new _packaging.default(xml);
          return this.unpack(this.packaging);
        });
      }
      /**
       * Open the manifest JSON
       * @private
       * @param  {string} url
       * @return {Promise}
       */
      openManifest(url) {
        this.path = new _path.default(url);
        return this.load(url).then((json) => {
          this.packaging = new _packaging.default();
          this.packaging.load(json);
          return this.unpack(this.packaging);
        });
      }
      /**
       * Load a resource from the Book
       * @param  {string} path path to the resource to load
       * @return {Promise}     returns a promise with the requested resource
       */
      load(path) {
        var resolved = this.resolve(path);
        if (this.archived) {
          return this.archive.request(resolved);
        } else {
          return this.request(resolved, null, this.settings.requestCredentials, this.settings.requestHeaders);
        }
      }
      /**
       * Resolve a path to it's absolute position in the Book
       * @param  {string} path
       * @param  {boolean} [absolute] force resolving the full URL
       * @return {string}          the resolved path string
       */
      resolve(path, absolute) {
        if (!path) {
          return;
        }
        var resolved = path;
        var isAbsolute = path.indexOf("://") > -1;
        if (isAbsolute) {
          return path;
        }
        if (this.path) {
          resolved = this.path.resolve(path);
        }
        if (absolute != false && this.url) {
          resolved = this.url.resolve(resolved);
        }
        return resolved;
      }
      /**
       * Get a canonical link to a path
       * @param  {string} path
       * @return {string} the canonical path string
       */
      canonical(path) {
        var url = path;
        if (!path) {
          return "";
        }
        if (this.settings.canonical) {
          url = this.settings.canonical(path);
        } else {
          url = this.resolve(path, true);
        }
        return url;
      }
      /**
       * Determine the type of they input passed to open
       * @private
       * @param  {string} input
       * @return {string}  binary | directory | epub | opf
       */
      determineType(input) {
        var url;
        var path;
        var extension;
        if (this.settings.encoding === "base64") {
          return INPUT_TYPE.BASE64;
        }
        if (typeof input != "string") {
          return INPUT_TYPE.BINARY;
        }
        url = new _url.default(input);
        path = url.path();
        extension = path.extension;
        if (extension) {
          extension = extension.replace(/\?.*$/, "");
        }
        if (!extension) {
          return INPUT_TYPE.DIRECTORY;
        }
        if (extension === "epub") {
          return INPUT_TYPE.EPUB;
        }
        if (extension === "opf") {
          return INPUT_TYPE.OPF;
        }
        if (extension === "json") {
          return INPUT_TYPE.MANIFEST;
        }
      }
      /**
       * unpack the contents of the Books packaging
       * @private
       * @param {Packaging} packaging object
       */
      unpack(packaging) {
        this.package = packaging;
        if (this.packaging.metadata.layout === "") {
          this.load(this.url.resolve(IBOOKS_DISPLAY_OPTIONS_PATH)).then((xml) => {
            this.displayOptions = new _displayoptions.default(xml);
            this.loading.displayOptions.resolve(this.displayOptions);
          }).catch((err) => {
            this.displayOptions = new _displayoptions.default();
            this.loading.displayOptions.resolve(this.displayOptions);
          });
        } else {
          this.displayOptions = new _displayoptions.default();
          this.loading.displayOptions.resolve(this.displayOptions);
        }
        this.spine.unpack(this.packaging, this.resolve.bind(this), this.canonical.bind(this));
        this.resources = new _resources.default(this.packaging.manifest, {
          archive: this.archive,
          resolver: this.resolve.bind(this),
          request: this.request.bind(this),
          replacements: this.settings.replacements || (this.archived ? "blobUrl" : "base64")
        });
        this.loadNavigation(this.packaging).then(() => {
          this.loading.navigation.resolve(this.navigation);
        });
        if (this.packaging.coverPath) {
          this.cover = this.resolve(this.packaging.coverPath);
        }
        this.loading.manifest.resolve(this.packaging.manifest);
        this.loading.metadata.resolve(this.packaging.metadata);
        this.loading.spine.resolve(this.spine);
        this.loading.cover.resolve(this.cover);
        this.loading.resources.resolve(this.resources);
        this.loading.pageList.resolve(this.pageList);
        this.isOpen = true;
        if (this.archived || this.settings.replacements && this.settings.replacements != "none") {
          this.replacements().then(() => {
            this.loaded.displayOptions.then(() => {
              this.opening.resolve(this);
            });
          }).catch((err) => {
            console.error(err);
          });
        } else {
          this.loaded.displayOptions.then(() => {
            this.opening.resolve(this);
          });
        }
      }
      /**
       * Load Navigation and PageList from package
       * @private
       * @param {Packaging} packaging
       */
      loadNavigation(packaging) {
        let navPath = packaging.navPath || packaging.ncxPath;
        let toc = packaging.toc;
        if (toc) {
          return new Promise((resolve, reject) => {
            this.navigation = new _navigation.default(toc);
            if (packaging.pageList) {
              this.pageList = new _pagelist.default(packaging.pageList);
            }
            resolve(this.navigation);
          });
        }
        if (!navPath) {
          return new Promise((resolve, reject) => {
            this.navigation = new _navigation.default();
            this.pageList = new _pagelist.default();
            resolve(this.navigation);
          });
        }
        return this.load(navPath, "xml").then((xml) => {
          this.navigation = new _navigation.default(xml);
          this.pageList = new _pagelist.default(xml);
          return this.navigation;
        });
      }
      /**
       * Gets a Section of the Book from the Spine
       * Alias for `book.spine.get`
       * @param {string} target
       * @return {Section}
       */
      section(target) {
        return this.spine.get(target);
      }
      /**
       * Sugar to render a book to an element
       * @param  {element | string} element element or string to add a rendition to
       * @param  {object} [options]
       * @return {Rendition}
       */
      renderTo(element, options) {
        this.rendition = new _rendition.default(this, options);
        this.rendition.attachTo(element);
        return this.rendition;
      }
      /**
       * Set if request should use withCredentials
       * @param {boolean} credentials
       */
      setRequestCredentials(credentials) {
        this.settings.requestCredentials = credentials;
      }
      /**
       * Set headers request should use
       * @param {object} headers
       */
      setRequestHeaders(headers) {
        this.settings.requestHeaders = headers;
      }
      /**
       * Unarchive a zipped epub
       * @private
       * @param  {binary} input epub data
       * @param  {string} [encoding]
       * @return {Archive}
       */
      unarchive(input, encoding) {
        this.archive = new _archive.default();
        return this.archive.open(input, encoding);
      }
      /**
       * Store the epubs contents
       * @private
       * @param  {binary} input epub data
       * @param  {string} [encoding]
       * @return {Store}
       */
      store(name) {
        let replacementsSetting = this.settings.replacements && this.settings.replacements !== "none";
        let originalUrl = this.url;
        let requester = this.settings.requestMethod || _request2.default.bind(this);
        this.storage = new _store.default(name, requester, this.resolve.bind(this));
        this.request = this.storage.request.bind(this.storage);
        this.opened.then(() => {
          if (this.archived) {
            this.storage.requester = this.archive.request.bind(this.archive);
          }
          let substituteResources = (output, section) => {
            section.output = this.resources.substitute(output, section.url);
          };
          this.resources.settings.replacements = replacementsSetting || "blobUrl";
          this.resources.replacements().then(() => {
            return this.resources.replaceCss();
          });
          this.storage.on("offline", () => {
            this.url = new _url.default("/", "");
            this.spine.hooks.serialize.register(substituteResources);
          });
          this.storage.on("online", () => {
            this.url = originalUrl;
            this.spine.hooks.serialize.deregister(substituteResources);
          });
        });
        return this.storage;
      }
      /**
       * Get the cover url
       * @return {Promise<?string>} coverUrl
       */
      coverUrl() {
        return this.loaded.cover.then(() => {
          if (!this.cover) {
            return null;
          }
          if (this.archived) {
            return this.archive.createUrl(this.cover);
          } else {
            return this.cover;
          }
        });
      }
      /**
       * Load replacement urls
       * @private
       * @return {Promise} completed loading urls
       */
      replacements() {
        this.spine.hooks.serialize.register((output, section) => {
          section.output = this.resources.substitute(output, section.url);
        });
        return this.resources.replacements().then(() => {
          return this.resources.replaceCss();
        });
      }
      /**
       * Find a DOM Range for a given CFI Range
       * @param  {EpubCFI} cfiRange a epub cfi range
       * @return {Promise}
       */
      getRange(cfiRange) {
        var cfi = new _epubcfi.default(cfiRange);
        var item = this.spine.get(cfi.spinePos);
        var _request = this.load.bind(this);
        if (!item) {
          return new Promise((resolve, reject) => {
            reject("CFI could not be found");
          });
        }
        return item.load(_request).then(function(contents) {
          var range = cfi.toRange(item.document);
          return range;
        });
      }
      /**
       * Generates the Book Key using the identifier in the manifest or other string provided
       * @param  {string} [identifier] to use instead of metadata identifier
       * @return {string} key
       */
      key(identifier) {
        var ident = identifier || this.packaging.metadata.identifier || this.url.filename;
        return `epubjs:${_constants.EPUBJS_VERSION}:${ident}`;
      }
      /**
       * Destroy the Book and all associated objects
       */
      destroy() {
        this.opened = void 0;
        this.loading = void 0;
        this.loaded = void 0;
        this.ready = void 0;
        this.isOpen = false;
        this.isRendered = false;
        this.spine && this.spine.destroy();
        this.locations && this.locations.destroy();
        this.pageList && this.pageList.destroy();
        this.archive && this.archive.destroy();
        this.resources && this.resources.destroy();
        this.container && this.container.destroy();
        this.packaging && this.packaging.destroy();
        this.rendition && this.rendition.destroy();
        this.displayOptions && this.displayOptions.destroy();
        this.spine = void 0;
        this.locations = void 0;
        this.pageList = void 0;
        this.archive = void 0;
        this.resources = void 0;
        this.container = void 0;
        this.packaging = void 0;
        this.rendition = void 0;
        this.navigation = void 0;
        this.url = void 0;
        this.path = void 0;
        this.archived = false;
      }
    };
    (0, _eventEmitter.default)(Book.prototype);
    var _default = Book;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/epub.js
var require_epub = __commonJS({
  "node_modules/epubjs/lib/epub.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _book = _interopRequireDefault(require_book());
    var _rendition = _interopRequireDefault(require_rendition());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _contents = _interopRequireDefault(require_contents());
    var utils = _interopRequireWildcard(require_core());
    var _constants = require_constants();
    var _iframe = _interopRequireDefault(require_iframe());
    var _default2 = _interopRequireDefault(require_default());
    var _continuous = _interopRequireDefault(require_continuous());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ePub(url, options) {
      return new _book.default(url, options);
    }
    ePub.VERSION = _constants.EPUBJS_VERSION;
    if (typeof global !== "undefined") {
      global.EPUBJS_VERSION = _constants.EPUBJS_VERSION;
    }
    ePub.Book = _book.default;
    ePub.Rendition = _rendition.default;
    ePub.Contents = _contents.default;
    ePub.CFI = _epubcfi.default;
    ePub.utils = utils;
    var _default = ePub;
    exports.default = _default;
  }
});

// node_modules/epubjs/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/epubjs/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Book", {
      enumerable: true,
      get: function() {
        return _book.default;
      }
    });
    Object.defineProperty(exports, "Contents", {
      enumerable: true,
      get: function() {
        return _contents.default;
      }
    });
    Object.defineProperty(exports, "EpubCFI", {
      enumerable: true,
      get: function() {
        return _epubcfi.default;
      }
    });
    Object.defineProperty(exports, "Layout", {
      enumerable: true,
      get: function() {
        return _layout.default;
      }
    });
    Object.defineProperty(exports, "Rendition", {
      enumerable: true,
      get: function() {
        return _rendition.default;
      }
    });
    exports.default = void 0;
    var _book = _interopRequireDefault(require_book());
    var _epubcfi = _interopRequireDefault(require_epubcfi());
    var _rendition = _interopRequireDefault(require_rendition());
    var _contents = _interopRequireDefault(require_contents());
    var _layout = _interopRequireDefault(require_layout());
    var _epub = _interopRequireDefault(require_epub());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = _epub.default;
    exports.default = _default;
  }
});

// node_modules/react-reader/lib/EpubView/style.js
var require_style = __commonJS({
  "node_modules/react-reader/lib/EpubView/style.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EpubViewStyle = void 0;
    var EpubViewStyle = {
      viewHolder: {
        position: "relative",
        height: "100%",
        width: "100%"
      },
      view: {
        height: "100%"
      }
    };
    exports.EpubViewStyle = EpubViewStyle;
  }
});

// node_modules/react-reader/lib/EpubView/EpubView.js
var require_EpubView = __commonJS({
  "node_modules/react-reader/lib/EpubView/EpubView.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _index = _interopRequireDefault(require_lib2());
    var _style = require_style();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var EpubView = function(_Component) {
      _inherits(EpubView2, _Component);
      var _super = _createSuper(EpubView2);
      function EpubView2(props) {
        var _this;
        _classCallCheck(this, EpubView2);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "onLocationChange", function(loc) {
          var _this$props = _this.props, location = _this$props.location, locationChanged = _this$props.locationChanged;
          var newLocation = loc && loc.start;
          if (location !== newLocation) {
            _this.location = newLocation;
            locationChanged && locationChanged(newLocation);
          }
        });
        _defineProperty(_assertThisInitialized(_this), "handleKeyPress", function(_ref) {
          var key = _ref.key;
          key && key === "ArrowRight" && _this.nextPage();
          key && key === "ArrowLeft" && _this.prevPage();
        });
        _this.state = {
          isLoaded: false,
          toc: []
        };
        _this.viewerRef = _react.default.createRef();
        _this.location = props.location;
        _this.book = _this.rendition = _this.prevPage = _this.nextPage = null;
        return _this;
      }
      _createClass(EpubView2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.initBook(true);
          document.addEventListener("keyup", this.handleKeyPress, false);
        }
      }, {
        key: "initBook",
        value: function initBook() {
          var _this2 = this;
          var _this$props2 = this.props, url = _this$props2.url, tocChanged = _this$props2.tocChanged, epubInitOptions = _this$props2.epubInitOptions;
          if (this.book) {
            this.book.destroy();
          }
          this.book = new _index.default(url, epubInitOptions);
          this.book.loaded.navigation.then(function(_ref2) {
            var toc = _ref2.toc;
            _this2.setState({
              isLoaded: true,
              toc
            }, function() {
              tocChanged && tocChanged(toc);
              _this2.initReader();
            });
          });
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (this.book) {
            this.book.destroy();
          }
          this.book = this.rendition = this.prevPage = this.nextPage = null;
          document.removeEventListener("keyup", this.handleKeyPress, false);
        }
      }, {
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps) {
          return !this.state.isLoaded || nextProps.location !== this.props.location || nextProps.url !== this.props.url;
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (prevProps.location !== this.props.location && this.location !== this.props.location) {
            this.rendition.display(this.props.location);
          }
          if (prevProps.url !== this.props.url) {
            this.initBook();
          }
        }
      }, {
        key: "initReader",
        value: function initReader() {
          var _this3 = this;
          var toc = this.state.toc;
          var _this$props3 = this.props, location = _this$props3.location, epubOptions = _this$props3.epubOptions, getRendition = _this$props3.getRendition;
          var node = this.viewerRef.current;
          this.rendition = this.book.renderTo(node, _objectSpread({
            contained: true,
            width: "100%",
            height: "100%"
          }, epubOptions));
          this.prevPage = function() {
            _this3.rendition.prev();
          };
          this.nextPage = function() {
            _this3.rendition.next();
          };
          this.registerEvents();
          getRendition && getRendition(this.rendition);
          if (typeof location === "string" || typeof location === "number") {
            this.rendition.display(location);
          } else if (toc.length > 0 && toc[0].href) {
            this.rendition.display(toc[0].href);
          } else {
            this.rendition.display();
          }
        }
      }, {
        key: "registerEvents",
        value: function registerEvents() {
          var _this$props4 = this.props, handleKeyPress = _this$props4.handleKeyPress, handleTextSelected = _this$props4.handleTextSelected;
          this.rendition.on("locationChanged", this.onLocationChange);
          this.rendition.on("keyup", handleKeyPress || this.handleKeyPress);
          if (handleTextSelected) {
            this.rendition.on("selected", handleTextSelected);
          }
        }
      }, {
        key: "renderBook",
        value: function renderBook() {
          var epubViewStyles = this.props.epubViewStyles;
          return _react.default.createElement("div", {
            ref: this.viewerRef,
            style: epubViewStyles.view
          });
        }
      }, {
        key: "render",
        value: function render() {
          var isLoaded = this.state.isLoaded;
          var _this$props5 = this.props, loadingView = _this$props5.loadingView, epubViewStyles = _this$props5.epubViewStyles;
          return _react.default.createElement("div", {
            style: epubViewStyles.viewHolder
          }, isLoaded && this.renderBook() || loadingView);
        }
      }]);
      return EpubView2;
    }(_react.Component);
    EpubView.defaultProps = {
      loadingView: null,
      locationChanged: null,
      tocChanged: null,
      epubViewStyles: _style.EpubViewStyle,
      epubOptions: {},
      epubInitOptions: {}
    };
    EpubView.propTypes = {
      url: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.instanceOf(ArrayBuffer)]),
      loadingView: _propTypes.default.element,
      location: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]),
      locationChanged: _propTypes.default.func,
      tocChanged: _propTypes.default.func,
      epubViewStyles: _propTypes.default.object,
      epubInitOptions: _propTypes.default.object,
      epubOptions: _propTypes.default.object,
      getRendition: _propTypes.default.func,
      handleKeyPress: _propTypes.default.func,
      handleTextSelected: _propTypes.default.func
    };
    var _default = EpubView;
    exports.default = _default;
  }
});

// node_modules/react-swipeable/es/index.js
var es_exports = {};
__export(es_exports, {
  DOWN: () => DOWN,
  LEFT: () => LEFT,
  RIGHT: () => RIGHT,
  UP: () => UP,
  useSwipeable: () => useSwipeable
});
function getDirection(absX, absY, deltaX, deltaY) {
  if (absX > absY) {
    if (deltaX > 0) {
      return RIGHT;
    }
    return LEFT;
  } else if (deltaY > 0) {
    return DOWN;
  }
  return UP;
}
function rotateXYByAngle(pos, angle) {
  if (angle === 0)
    return pos;
  const angleInRadians = Math.PI / 180 * angle;
  const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);
  const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);
  return [x, y];
}
function getHandlers(set, handlerProps) {
  const onStart = (event) => {
    const isTouch = "touches" in event;
    if (isTouch && event.touches.length > 1)
      return;
    set((state, props) => {
      if (props.trackMouse && !isTouch) {
        document.addEventListener(mouseMove, onMove);
        document.addEventListener(mouseUp, onUp);
      }
      const { clientX, clientY } = isTouch ? event.touches[0] : event;
      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);
      props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({ event });
      return Object.assign(Object.assign(Object.assign({}, state), initialState), { initial: xy.slice(), xy, start: event.timeStamp || 0 });
    });
  };
  const onMove = (event) => {
    set((state, props) => {
      const isTouch = "touches" in event;
      if (isTouch && event.touches.length > 1) {
        return state;
      }
      if (event.timeStamp - state.start > props.swipeDuration) {
        return state.swiping ? Object.assign(Object.assign({}, state), { swiping: false }) : state;
      }
      const { clientX, clientY } = isTouch ? event.touches[0] : event;
      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);
      const deltaX = x - state.xy[0];
      const deltaY = y - state.xy[1];
      const absX = Math.abs(deltaX);
      const absY = Math.abs(deltaY);
      const time = (event.timeStamp || 0) - state.start;
      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);
      const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];
      const dir = getDirection(absX, absY, deltaX, deltaY);
      const delta = typeof props.delta === "number" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;
      if (absX < delta && absY < delta && !state.swiping)
        return state;
      const eventData = {
        absX,
        absY,
        deltaX,
        deltaY,
        dir,
        event,
        first: state.first,
        initial: state.initial,
        velocity,
        vxvy
      };
      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);
      props.onSwiping && props.onSwiping(eventData);
      let cancelablePageSwipe = false;
      if (props.onSwiping || props.onSwiped || props[`onSwiped${dir}`]) {
        cancelablePageSwipe = true;
      }
      if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {
        event.preventDefault();
      }
      return Object.assign(Object.assign({}, state), {
        // first is now always false
        first: false,
        eventData,
        swiping: true
      });
    });
  };
  const onEnd = (event) => {
    set((state, props) => {
      let eventData;
      if (state.swiping && state.eventData) {
        if (event.timeStamp - state.start < props.swipeDuration) {
          eventData = Object.assign(Object.assign({}, state.eventData), { event });
          props.onSwiped && props.onSwiped(eventData);
          const onSwipedDir = props[`onSwiped${eventData.dir}`];
          onSwipedDir && onSwipedDir(eventData);
        }
      } else {
        props.onTap && props.onTap({ event });
      }
      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });
      return Object.assign(Object.assign(Object.assign({}, state), initialState), { eventData });
    });
  };
  const cleanUpMouse = () => {
    document.removeEventListener(mouseMove, onMove);
    document.removeEventListener(mouseUp, onUp);
  };
  const onUp = (e) => {
    cleanUpMouse();
    onEnd(e);
  };
  const attachTouch = (el, props) => {
    let cleanup = () => {
    };
    if (el && el.addEventListener) {
      const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);
      const tls = [
        [touchStart, onStart, baseOptions],
        // preventScrollOnSwipe option supersedes touchEventOptions.passive
        [
          touchMove,
          onMove,
          Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? { passive: false } : {})
        ],
        [touchEnd, onEnd, baseOptions]
      ];
      tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));
      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));
    }
    return cleanup;
  };
  const onRef = (el) => {
    if (el === null)
      return;
    set((state, props) => {
      if (state.el === el)
        return state;
      const addState = {};
      if (state.el && state.el !== el && state.cleanUpTouch) {
        state.cleanUpTouch();
        addState.cleanUpTouch = void 0;
      }
      if (props.trackTouch && el) {
        addState.cleanUpTouch = attachTouch(el, props);
      }
      return Object.assign(Object.assign(Object.assign({}, state), { el }), addState);
    });
  };
  const output = {
    ref: onRef
  };
  if (handlerProps.trackMouse) {
    output.onMouseDown = onStart;
  }
  return [output, attachTouch];
}
function updateTransientState(state, props, previousProps, attachTouch) {
  if (!props.trackTouch || !state.el) {
    if (state.cleanUpTouch) {
      state.cleanUpTouch();
    }
    return Object.assign(Object.assign({}, state), { cleanUpTouch: void 0 });
  }
  if (!state.cleanUpTouch) {
    return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });
  }
  if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {
    state.cleanUpTouch();
    return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });
  }
  return state;
}
function useSwipeable(options) {
  const { trackMouse } = options;
  const transientState = React.useRef(Object.assign({}, initialState));
  const transientProps = React.useRef(Object.assign({}, defaultProps));
  const previousProps = React.useRef(Object.assign({}, transientProps.current));
  previousProps.current = Object.assign({}, transientProps.current);
  transientProps.current = Object.assign(Object.assign({}, defaultProps), options);
  let defaultKey;
  for (defaultKey in defaultProps) {
    if (transientProps.current[defaultKey] === void 0) {
      transientProps.current[defaultKey] = defaultProps[defaultKey];
    }
  }
  const [handlers, attachTouch] = React.useMemo(() => getHandlers((stateSetter) => transientState.current = stateSetter(transientState.current, transientProps.current), { trackMouse }), [trackMouse]);
  transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);
  return handlers;
}
var React, LEFT, RIGHT, UP, DOWN, defaultProps, initialState, mouseMove, mouseUp, touchEnd, touchMove, touchStart;
var init_es = __esm({
  "node_modules/react-swipeable/es/index.js"() {
    React = __toESM(require_react());
    LEFT = "Left";
    RIGHT = "Right";
    UP = "Up";
    DOWN = "Down";
    defaultProps = {
      delta: 10,
      preventScrollOnSwipe: false,
      rotationAngle: 0,
      trackMouse: false,
      trackTouch: true,
      swipeDuration: Infinity,
      touchEventOptions: { passive: true }
    };
    initialState = {
      first: true,
      initial: [0, 0],
      start: 0,
      swiping: false,
      xy: [0, 0]
    };
    mouseMove = "mousemove";
    mouseUp = "mouseup";
    touchEnd = "touchend";
    touchMove = "touchmove";
    touchStart = "touchstart";
  }
});

// node_modules/react-reader/lib/ReactReader/style.js
var require_style2 = __commonJS({
  "node_modules/react-reader/lib/ReactReader/style.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ReactReaderStyle = void 0;
    var ReactReaderStyle = {
      container: {
        overflow: "hidden",
        position: "relative",
        height: "100%"
      },
      readerArea: {
        position: "relative",
        zIndex: 1,
        height: "100%",
        width: "100%",
        backgroundColor: "#fff",
        transition: "all .3s ease"
      },
      containerExpanded: {
        transform: "translateX(256px)"
      },
      titleArea: {
        position: "absolute",
        top: 20,
        left: 50,
        right: 50,
        textAlign: "center",
        color: "#999"
      },
      reader: {
        position: "absolute",
        top: 50,
        left: 50,
        bottom: 20,
        right: 50
      },
      swipeWrapper: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        zIndex: 200
      },
      prev: {
        left: 1
      },
      next: {
        right: 1
      },
      arrow: {
        outline: "none",
        border: "none",
        background: "none",
        position: "absolute",
        top: "50%",
        marginTop: -32,
        fontSize: 64,
        padding: "0 10px",
        color: "#E2E2E2",
        fontFamily: "arial, sans-serif",
        cursor: "pointer",
        userSelect: "none",
        appearance: "none",
        fontWeight: "normal"
      },
      arrowHover: {
        color: "#777"
      },
      tocBackground: {
        position: "absolute",
        left: 256,
        top: 0,
        bottom: 0,
        right: 0,
        zIndex: 1
      },
      tocArea: {
        position: "absolute",
        left: 0,
        top: 0,
        bottom: 0,
        zIndex: 0,
        width: 256,
        overflowY: "auto",
        WebkitOverflowScrolling: "touch",
        background: "#f2f2f2",
        padding: "10px 0"
      },
      tocAreaButton: {
        userSelect: "none",
        appearance: "none",
        background: "none",
        border: "none",
        display: "block",
        fontFamily: "sans-serif",
        width: "100%",
        fontSize: ".9em",
        textAlign: "left",
        padding: ".9em 1em",
        borderBottom: "1px solid #ddd",
        color: "#aaa",
        boxSizing: "border-box",
        outline: "none",
        cursor: "pointer"
      },
      tocButton: {
        background: "none",
        border: "none",
        width: 32,
        height: 32,
        position: "absolute",
        top: 10,
        left: 10,
        borderRadius: 2,
        outline: "none",
        cursor: "pointer"
      },
      tocButtonExpanded: {
        background: "#f2f2f2"
      },
      tocButtonBar: {
        position: "absolute",
        width: "60%",
        background: "#ccc",
        height: 2,
        left: "50%",
        margin: "-1px -30%",
        top: "50%",
        transition: "all .5s ease"
      },
      tocButtonBarTop: {
        top: "35%"
      },
      tocButtonBottom: {
        top: "66%"
      },
      loadingView: {
        position: "absolute",
        top: "50%",
        left: "10%",
        right: "10%",
        color: "#ccc",
        textAlign: "center",
        margintop: "-.5em"
      }
    };
    exports.ReactReaderStyle = ReactReaderStyle;
  }
});

// node_modules/react-reader/lib/ReactReader/ReactReader.js
var require_ReactReader = __commonJS({
  "node_modules/react-reader/lib/ReactReader/ReactReader.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactSwipeable = (init_es(), __toCommonJS(es_exports));
    var _ = require_lib3();
    var _style = require_style2();
    var _excluded = ["children"];
    var _excluded2 = ["title", "showToc", "loadingView", "readerStyles", "locationChanged", "swipeable", "epubViewStyles"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    var Swipeable = function Swipeable2(_ref) {
      var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded);
      var handlers = (0, _reactSwipeable.useSwipeable)(props);
      return _react.default.createElement("div", handlers, children);
    };
    var TocItem = function(_PureComponent) {
      _inherits(TocItem2, _PureComponent);
      var _super = _createSuper(TocItem2);
      function TocItem2() {
        var _this;
        _classCallCheck(this, TocItem2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "setLocation", function() {
          _this.props.setLocation(_this.props.href);
        });
        return _this;
      }
      _createClass(TocItem2, [{
        key: "render",
        value: function render() {
          var _this2 = this;
          var _this$props = this.props, label = _this$props.label, styles = _this$props.styles, subitems = _this$props.subitems;
          return _react.default.createElement("div", null, _react.default.createElement("button", {
            onClick: this.setLocation,
            style: styles
          }, label), subitems && subitems.length > 0 && _react.default.createElement("div", {
            style: {
              paddingLeft: 10
            }
          }, subitems.map(function(item, i) {
            return _react.default.createElement(TocItem2, _extends({
              key: i
            }, _this2.props, item));
          })));
        }
      }]);
      return TocItem2;
    }(_react.PureComponent);
    TocItem.propTypes = {
      label: _propTypes.default.string,
      href: _propTypes.default.string,
      setLocation: _propTypes.default.func,
      styles: _propTypes.default.object
    };
    var ReactReader = function(_PureComponent2) {
      _inherits(ReactReader2, _PureComponent2);
      var _super2 = _createSuper(ReactReader2);
      function ReactReader2(props) {
        var _this3;
        _classCallCheck(this, ReactReader2);
        _this3 = _super2.call(this, props);
        _defineProperty(_assertThisInitialized(_this3), "toggleToc", function() {
          _this3.setState({
            expandedToc: !_this3.state.expandedToc
          });
        });
        _defineProperty(_assertThisInitialized(_this3), "next", function() {
          var node = _this3.readerRef.current;
          node.nextPage();
        });
        _defineProperty(_assertThisInitialized(_this3), "prev", function() {
          var node = _this3.readerRef.current;
          node.prevPage();
        });
        _defineProperty(_assertThisInitialized(_this3), "onTocChange", function(toc) {
          var tocChanged = _this3.props.tocChanged;
          _this3.setState({
            toc
          }, function() {
            return tocChanged && tocChanged(toc);
          });
        });
        _defineProperty(_assertThisInitialized(_this3), "setLocation", function(loc) {
          var locationChanged = _this3.props.locationChanged;
          _this3.setState({
            expandedToc: false
          }, function() {
            return locationChanged && locationChanged(loc);
          });
        });
        _this3.readerRef = _react.default.createRef();
        _this3.state = {
          expandedToc: false,
          toc: false
        };
        return _this3;
      }
      _createClass(ReactReader2, [{
        key: "renderToc",
        value: function renderToc() {
          var _this4 = this;
          var _this$state = this.state, toc = _this$state.toc, expandedToc = _this$state.expandedToc;
          var readerStyles = this.props.readerStyles;
          return _react.default.createElement("div", null, _react.default.createElement("div", {
            style: readerStyles.tocArea
          }, _react.default.createElement("div", {
            style: readerStyles.toc
          }, toc.map(function(item, i) {
            return _react.default.createElement(TocItem, _extends({}, item, {
              key: i,
              setLocation: _this4.setLocation,
              styles: readerStyles.tocAreaButton
            }));
          }))), expandedToc && _react.default.createElement("div", {
            style: readerStyles.tocBackground,
            onClick: this.toggleToc
          }));
        }
      }, {
        key: "renderTocToggle",
        value: function renderTocToggle() {
          var expandedToc = this.state.expandedToc;
          var readerStyles = this.props.readerStyles;
          return _react.default.createElement("button", {
            style: Object.assign({}, readerStyles.tocButton, expandedToc ? readerStyles.tocButtonExpanded : {}),
            onClick: this.toggleToc
          }, _react.default.createElement("span", {
            style: Object.assign({}, readerStyles.tocButtonBar, readerStyles.tocButtonBarTop)
          }), _react.default.createElement("span", {
            style: Object.assign({}, readerStyles.tocButtonBar, readerStyles.tocButtonBottom)
          }));
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props2 = this.props, title = _this$props2.title, showToc = _this$props2.showToc, loadingView = _this$props2.loadingView, readerStyles = _this$props2.readerStyles, locationChanged = _this$props2.locationChanged, swipeable = _this$props2.swipeable, epubViewStyles = _this$props2.epubViewStyles, props = _objectWithoutProperties(_this$props2, _excluded2);
          var _this$state2 = this.state, toc = _this$state2.toc, expandedToc = _this$state2.expandedToc;
          return _react.default.createElement("div", {
            style: readerStyles.container
          }, _react.default.createElement("div", {
            style: Object.assign({}, readerStyles.readerArea, expandedToc ? readerStyles.containerExpanded : {})
          }, showToc && this.renderTocToggle(), _react.default.createElement("div", {
            style: readerStyles.titleArea
          }, title), _react.default.createElement(Swipeable, {
            onSwipedRight: this.prev,
            onSwipedLeft: this.next,
            trackMouse: true
          }, _react.default.createElement("div", {
            style: readerStyles.reader
          }, _react.default.createElement(_.EpubView, _extends({
            ref: this.readerRef,
            loadingView,
            epubViewStyles
          }, props, {
            tocChanged: this.onTocChange,
            locationChanged
          })), swipeable && _react.default.createElement("div", {
            style: readerStyles.swipeWrapper
          }))), _react.default.createElement("button", {
            style: Object.assign({}, readerStyles.arrow, readerStyles.prev),
            onClick: this.prev
          }, "‹"), _react.default.createElement("button", {
            style: Object.assign({}, readerStyles.arrow, readerStyles.next),
            onClick: this.next
          }, "›")), showToc && toc && this.renderToc());
        }
      }]);
      return ReactReader2;
    }(_react.PureComponent);
    ReactReader.defaultProps = {
      loadingView: _react.default.createElement("div", {
        style: _style.ReactReaderStyle.loadingView
      }, "Loading…"),
      locationChanged: null,
      tocChanged: null,
      showToc: true,
      readerStyles: _style.ReactReaderStyle
    };
    ReactReader.propTypes = {
      title: _propTypes.default.string,
      loadingView: _propTypes.default.element,
      showToc: _propTypes.default.bool,
      locationChanged: _propTypes.default.func,
      tocChanged: _propTypes.default.func,
      readerStyles: _propTypes.default.object,
      epubViewStyles: _propTypes.default.object,
      swipeable: _propTypes.default.bool
    };
    var _default = ReactReader;
    exports.default = _default;
  }
});

// node_modules/react-reader/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/react-reader/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "EpubView", {
      enumerable: true,
      get: function get() {
        return _EpubView.default;
      }
    });
    Object.defineProperty(exports, "EpubViewStyle", {
      enumerable: true,
      get: function get() {
        return _style.EpubViewStyle;
      }
    });
    Object.defineProperty(exports, "ReactReader", {
      enumerable: true,
      get: function get() {
        return _ReactReader.default;
      }
    });
    Object.defineProperty(exports, "ReactReaderStyle", {
      enumerable: true,
      get: function get() {
        return _style2.ReactReaderStyle;
      }
    });
    var _EpubView = _interopRequireDefault(require_EpubView());
    var _style = require_style();
    var _ReactReader = _interopRequireDefault(require_ReactReader());
    var _style2 = require_style2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});
export default require_lib3();
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=react-reader.js.map
